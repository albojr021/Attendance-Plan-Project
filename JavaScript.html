<script>
  // NEW: Include jQuery first (Select2 dependency)
  document.write('<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"><\/script>');
  // NEW: Include Select2
  document.write('<script src="https://cdnjs.cloudflare.com/ajax/libs/select2/4.0.13/js/select2.min.js"><\/script>');
  
  // *** NEW: Include jQuery UI (for Datepicker) ***
  document.write('<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.css">');
  document.write('<script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js"><\/script>');
  // ****************************************
  
  // *** NEW: Custom style para itago ang calendar view ***
  document.write('<style>');
  // CRITICAL: Itago ang calendar table at tiyakin na centered ang button pane
  document.write('.ui-month-year-only .ui-datepicker-calendar { display: none !important; }');
  document.write('.ui-month-year-only .ui-datepicker-buttonpane { text-align: center; }');
  document.write('</style>');
  
  // Global state variables
  let contractList = [];
  let currentContract = null;
  const CONTRACT_ID_CACHE_KEY = 'current_contract_id'; 
  
  // *** NEW: Global state for Employee Master Data ***
  let employeeMasterList = []; 
  // NEW: Global state for Signatory Master Data
  let signatoryMasterList = [];
  
  // *** NEW: Global state for Group Number (Read-only input value) ***
  // We use the input's value directly as the source of truth, but keep this variable for consistency checks.
  let currentGroup = 'G1'; 
  // -----------------------------------------------------------

  // *** DATE NAVIGATION VARIABLE ***
  let currentPlanningDate = new Date(); 
  // Ang status codes
  const fixedStatusCodes = ['RD', 'RH', 'SH', '', 'NA']; 
  const shiftPeriods = [
    { key: '1stHalf', label: '1st Half (1st to 15th)' },
    { key: '2ndHalf', label: '2nd Half (16th to End)' }
  ];
  const maxDays = 31; 
  const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
  // *** FIXED STATUS OPTIONS PARA SA FLOATING DROPDOWN ***
  let selectedCellData = {}; 

  // *** NEW: Global state for Bulk Selection ***
  let isBulkSelectionMode = false;
  let bulkSelectedCells = []; 
  // --- NEW DRAG STATE VARIABLES ---
  let isDragging = false;
  let dragStartCell = null;
  let dragEndCell = null;
  let cellsFromCurrentDrag = []; 
  // ---------------------------------------------
  
  // *** NEW: Global state for tracking ng changes ***
  let pendingAttendanceChanges = {}; 
  // UPDATED: Ngayon may `isDeleted` property na
  let pendingEmployeeInfoChanges = {}; 
  
  // NEW: Global state for locked ID map {ID: Ref#}
  let lockedIdRefMap = {};
  
  // --- NEW GLOBAL STATE FOR PRINT LOCKING ---
  let isPlanSheetFullyLocked = false;
  // ---------------------------------------------
  
  // *** NEW GLOBAL STATE FOR BULK UNLOCK SELECTION ***
  // Stores {id: 'ID', ref: 'REF#', name: 'NAME'} pairs
  let bulkUnlockSelected = []; 

  // *** NEW GLOBAL STATE FOR SIGNATORIES ***
  let selectedSignatories = {
      preparedBy: '',
      checkedBy: ['', '', '', '', ''], // Up to 5 checkedBy
      approvedBy: ''
  };

  const fixedStatusOptions = [
    { value: 'RD', label: 'Rest Day (RD)', color: 'status-rd text-red-700' },
    { value: 'RH', label: 'Regular Holiday (RH)', color: 'status-rh text-blue-700' },
    { value: 'SH', label: 'Special Holiday (SH)', color: 'status-sh text-yellow-700' },
    { value: '', label: 'Clear/Blank (Work Schedule)', color: 'bg-gray-200 text-gray-700' },
    // NEW: Not Applicable / Excluded Status
    { value: 'NA', label: 'Not Applicable (NA) / Excluded', color: 'status-na text-gray-500' },
  ];
  
  // NEW: Global variable para sa validation (HH:MM-HH:MM) - HINDI NA GANOONG KA-STRICT DAHIL SA TYPE="TIME"
  const TIME_FORMAT_REGEX = /^([01]?[0-9]|2[0-3]):[0-5][0-9]-([01]?[0-9]|2[0-3]):[0-5][0-9]$/;
  // NEW: Regex for Personnel Info validation
  const PERSONNEL_ID_REGEX = /^[0-9]+$/; // Only numbers
  // FIX: Nagdagdag ng DASH (-) sa allowed characters
  const SAFE_TEXT_REGEX = /^[A-Z0-9\s.,-]+$/; 
  
  // *** NEW REGEX FOR SIGNATORY NAMES (Letters, Space, Dash, Comma, Period only) ***
  const SIGNATORY_REGEX = /^[A-Z\s.,-]+$/; 
  const SAFE_NAME_REGEX = /[^A-Z\s.,-]/g; 
  // ---------------------------------------------

  // --- NEW: Time Option Generator for Dropdowns ---
  function generateTimeOptions() {
      const times = [];
      for (let h = 0; h < 24; h++) {
          for (let m = 0; m < 60; m += 30) {
              const hour = String(h).padStart(2, '0');
              const minute = String(m).padStart(2, '0');
              times.push(`${hour}:${minute}`);
          }
      }
      return times;
  }
  const TIME_OPTIONS = generateTimeOptions();

  // --- NEW HELPER: Normalize Name for Comparison (Removes all non-alphanumeric) ---
  function normalizeNameForComparison(name) {
      if (!name) return '';
      
      const upperName = name.toUpperCase();
      let cleanedName = upperName.replace(/[^A-Z\s]/g, ''); 
      
      const sortedWords = cleanedName.split(/\s+/) 
                                   .filter(word => word.length > 0) 
                                   .sort()
                                   .join(''); 
      
      return sortedWords;
  }
  // --- END HELPER ---
  
  // --- NEW FUNCTION: Fetch and Populate Master Employee Data ---
  function fetchEmployeeMasterData(sfcRef) {
       google.script.run
            .withSuccessHandler(populateDataLists)
            .withFailureHandler(handleError)
            .getEmployeeMasterData(sfcRef);
  }
  
  function populateDataLists(masterList) {
      employeeMasterList = masterList; 
      const idList = document.getElementById('employee-id-list');
      const nameList = document.getElementById('employee-name-list');
      
      const positionList = document.getElementById('employee-position-list');
      const areaList = document.getElementById('employee-area-list');

      // Clear existing options
      idList.innerHTML = '';
      nameList.innerHTML = '';
      if (positionList) positionList.innerHTML = '';
      if (areaList) areaList.innerHTML = '';

      const uniquePositions = new Set();
      const uniqueAreas = new Set();
      
      employeeMasterList.forEach(emp => {
          // ID Datalist
          const idOption = document.createElement('option');
          idOption.value = emp.id;
          idOption.textContent = `${emp.name} (${emp.position})`;
          idList.appendChild(idOption);
          
          // Name Datalist
          const nameOption = document.createElement('option');
          nameOption.value = emp.name;
          nameOption.textContent = `${emp.id} (${emp.position})`;
          nameList.appendChild(nameOption);

          // Collect unique position/area
          if (emp.position) uniquePositions.add(emp.position.trim());
          if (emp.area) uniqueAreas.add(emp.area.trim());
      });
      
      // Populate Position Datalist
      if (positionList) {
          uniquePositions.forEach(pos => {
              const posOption = document.createElement('option');
              posOption.value = pos;
              positionList.appendChild(posOption);
          });
      }

      // Populate Area Datalist
      if (areaList) {
          uniqueAreas.forEach(area => {
              const areaOption = document.createElement('option');
              areaOption.value = area;
              areaList.appendChild(areaOption);
          });
      }
      
      console.log(`Datalists populated with ${masterList.length} employees. (${uniquePositions.size} positions, ${uniqueAreas.size} areas)`);
  }
  // --- END NEW DATALIST FUNCTIONS ---
  
  // *** NEW FUNCTIONS: Fetch and Populate Signatory Master Data ***
  function fetchSignatoryMasterData() {
       google.script.run
            .withSuccessHandler(populateSignatoryDataLists)
            .withFailureHandler(handleError)
            .getSignatoryMasterData(); 
  }

  function populateSignatoryDataLists(masterList) {
      signatoryMasterList = masterList;
      const signatoryList = document.getElementById('signatory-master-list');

      signatoryList.innerHTML = '';
      
      signatoryMasterList.forEach(name => {
          const option = document.createElement('option');
          option.value = name;
          signatoryList.appendChild(option);
      });

      console.log(`Signatory datalist populated with ${masterList.length} names for Checked/Approved By.`);
  }
  // *** END NEW SIGNATORY FETCH FUNCTIONS ***


  // --- NEW FUNCTION: KUNIN ANG ACTIVE IDS SA GRID PARA SA VALIDATION (FIXED LOGIC) ---
function isDuplicateId(newId, originalSavedId, currentNo) {
    const trimmedNewId = newId.trim();
    if (!trimmedNewId) return false;

    let duplicateFound = false;
    document.querySelectorAll('input[data-field="id"]').forEach(input => {
        const row = input.closest('tr');
        const rowKey = row.dataset.stableKey;
        const currentIdInInput = (input.value || '').trim();
        
        // 1. Skip the row currently being validated/edited.
        if (rowKey === originalSavedId || rowKey === `TEMP_${currentNo}`) {
            return;
        }
        
        // 2. Skip rows marked for deletion (they are inactive for planning).
        if (row.classList.contains('line-through')) {
            return;
        }
        
        // 3. Check for conflict.
        if (currentIdInInput === trimmedNewId) {
            duplicateFound = true;
        }
    });

    return duplicateFound;
}
// --- END DUPLICATE ID FUNCTION ---

// *** UPDATED FUNCTION: KUNIN ANG ACTIVE NAMES SA GRID PARA SA VALIDATION (FIXED LOGIC) ***
function isDuplicateName(newName, originalSavedId, currentNo) {
    const normalizedNewName = normalizeNameForComparison(newName); 
    if (!normalizedNewName) return false;
    
    let duplicateFound = false;
    document.querySelectorAll('input[data-field="name"]').forEach(input => {
        const row = input.closest('tr');
        const rowKey = row.dataset.stableKey;
        const currentNameInInput = (input.value || '').trim();
        const normalizedCurrentName = normalizeNameForComparison(currentNameInInput);
        
        // 1. Skip the row currently being edited/validated
        if (rowKey === originalSavedId || rowKey === `TEMP_${currentNo}`) {
            return;
        }
        
        // 2. Skip rows marked for deletion
        if (row.classList.contains('line-through')) {
            return;
        }
        
        // 3. Check for conflict (using normalized names)
        if (normalizedCurrentName === normalizedNewName) {
            duplicateFound = true;
        }
    });
    
    return duplicateFound;
}
  // --- END DUPLICATE NAME FUNCTION ---
  
  // --- HELPER FUNCTION: KUNIN ANG ACTIVE EMPLOYEES SA GRID ---
  function getActiveEmployeesInGrid() {
    const activeEmployees = [];
    
    const renderedEmployees = currentContract?.employees || [];
    
    renderedEmployees.forEach((employee, index) => {
        const stableKey = employee.id || `TEMP_${index + 1}`; 
        const pendingInfo = pendingEmployeeInfoChanges[stableKey];
        
        if (pendingInfo && pendingInfo.isDeleted) return; 

        const displayId = (pendingInfo && pendingInfo.id) ? pendingInfo.id : employee.id;
        const displayName = (pendingInfo && pendingInfo.name) ? pendingInfo.name : employee.name;
        
        if (!displayId.trim()) return; 
        
        activeEmployees.push({
            id: displayId.trim(),
            name: displayName.trim(),
            planCells: [] 
        });
    });
    
    const gridRows = document.querySelectorAll('#attendance-table-container tbody tr');
    gridRows.forEach(row => {
        const stableKey = row.dataset.stableKey;
        if (!stableKey.startsWith('TEMP_')) return; 

        const pendingInfo = pendingEmployeeInfoChanges[stableKey];
        if (pendingInfo && pendingInfo.isDeleted) return; 
        if (!pendingInfo) return; 

        const displayId = pendingInfo.id;
        const displayName = pendingInfo.name;
        
        if (displayId && displayName) {
             activeEmployees.push({
                 id: displayId.trim(),
                 name: displayName.trim(),
                 planCells: [] 
             });
        }
    });

    return activeEmployees;
  }
  // --- END HELPER FUNCTION ---

// --- NEW FUNCTION: Kumuha ng Listahan ng Locked Employees (FOR MODAL) ---
function getLockedEmployeesList() {
    const lockedList = [];
    const gridRows = document.querySelectorAll('#attendance-table-container tbody tr');

    gridRows.forEach(row => {
        if (row.classList.contains('locked-row') && !row.classList.contains('line-through')) {
            const stableKey = row.dataset.stableKey;
            
            const idInput = row.querySelector('[data-field="id"]');
            const nameInput = row.querySelector('[data-field="name"]');
            
            const personnelId = (idInput?.value || '').trim();
            const personnelName = (nameInput?.value || '').trim();
            
            const lockedRefNum = lockedIdRefMap[stableKey]; 

            if (personnelId && lockedRefNum) {
                const isSelected = bulkUnlockSelected.some(item => item.id === personnelId);
                
                lockedList.push({
                    id: personnelId,
                    name: personnelName,
                    ref: lockedRefNum,
                    stableKey: stableKey, 
                    isSelected: isSelected
                });
            }
        }
    });

    return lockedList;
}

// --- NEW FUNCTION: Open Unlock Selection Modal ---
function openUnlockSelectionModal() {
    const lockedEmployees = getLockedEmployeesList();
    const listContainer = document.getElementById('locked-employee-list-container');
    const modal = document.getElementById('unlock-selection-modal');
    const selectAllCheckbox = document.getElementById('select-all-unlock');

    if (lockedEmployees.length === 0) {
        showNotification('No schedules are currently locked for this period.', false);
        return;
    }
    
    listContainer.innerHTML = '';
    
    lockedEmployees.forEach(emp => {
        const listItem = document.createElement('li');
        const itemBgClass = emp.isSelected ? 'bg-yellow-100 border-yellow-400' : 'bg-gray-50 border-gray-200';
        
        listItem.className = `flex items-center space-x-3 p-2 rounded-lg border hover:bg-yellow-50 transition duration-150 cursor-pointer ${itemBgClass}`;
        
        listItem.innerHTML = `
            <input type="checkbox" id="unlock-check-${emp.id}" 
                   data-id="${emp.id}" 
                   data-ref="${emp.ref}"
                   data-name="${emp.name}"
                   class="unlock-checkbox h-4 w-4 text-red-600 border-gray-300 rounded focus:ring-red-500" 
                   ${emp.isSelected ? 'checked' : ''}>
            <label for="unlock-check-${emp.id}" class="flex-grow text-sm font-medium text-gray-800">
                <span class="font-bold">${emp.name || emp.id}</span> 
                <span class="text-xs text-gray-500">(ID: ${emp.id})</span>
            </label>
            <span class="text-xs font-semibold text-blue-700 bg-blue-100 px-2 py-0.5 rounded-full whitespace-nowrap">REF #${emp.ref}</span>
        `;
        
        const checkbox = listItem.querySelector('.unlock-checkbox');
        checkbox.addEventListener('change', (e) => {
            updateBulkUnlockSelection(e);
            listItem.classList.toggle('bg-yellow-100', e.target.checked);
            listItem.classList.toggle('border-yellow-400', e.target.checked);
            listItem.classList.toggle('bg-gray-50', !e.target.checked);
            listItem.classList.toggle('border-gray-200', !e.target.checked);
        });
        
        listContainer.appendChild(listItem);
    });
    
    updateUnlockModalState();

    if (selectAllCheckbox) {
        selectAllCheckbox.removeEventListener('change', toggleSelectAll);
        selectAllCheckbox.addEventListener('change', toggleSelectAll);
        selectAllCheckbox.checked = (lockedEmployees.length > 0 && bulkUnlockSelected.length === lockedEmployees.length);
    }
    

    document.getElementById('unlock-modal-cancel-btn').onclick = () => modal.classList.add('hidden');
    document.getElementById('unlock-modal-send-btn').onclick = handleBulkUnlockRequest;

    modal.classList.remove('hidden');
}

// --- NEW FUNCTION: Select All Logic ---
function toggleSelectAll(event) {
    const isChecked = event.target.checked;
    const checkboxes = document.querySelectorAll('#locked-employee-list-container .unlock-checkbox');
    
    bulkUnlockSelected = []; 

    checkboxes.forEach(checkbox => {
        checkbox.checked = isChecked;
        
        const id = checkbox.dataset.id;
        const ref = checkbox.dataset.ref;
        const name = checkbox.dataset.name;
        const listItem = checkbox.closest('li');
        
        if (isChecked) {
            bulkUnlockSelected.push({ id, ref, name });
            listItem.classList.add('bg-yellow-100', 'border-yellow-400');
            listItem.classList.remove('bg-gray-50', 'border-gray-200');
        } else {
            listItem.classList.remove('bg-yellow-100', 'border-yellow-400');
            listItem.classList.add('bg-gray-50', 'border-gray-200');
        }
    });
    
    updateUnlockModalState();
}


// Helper to update global array and modal state on checkbox change
function updateBulkUnlockSelection(event) {
    const checkbox = event.target;
    const id = checkbox.dataset.id;
    const ref = checkbox.dataset.ref;
    const name = checkbox.dataset.name;
    const isChecked = checkbox.checked;

    const existingIndex = bulkUnlockSelected.findIndex(item => item.id === id);

    if (isChecked && existingIndex === -1) {
        bulkUnlockSelected.push({ id, ref, name });
    } else if (!isChecked && existingIndex > -1) {
        bulkUnlockSelected.splice(existingIndex, 1);
    }
    
    const selectAllCheckbox = document.getElementById('select-all-unlock');
    const totalLocked = getLockedEmployeesList().length;

    if (selectAllCheckbox) {
        selectAllCheckbox.checked = (bulkUnlockSelected.length === totalLocked);
    }
    
    updateUnlockModalState();
}

// Helper to update count display and button enablement
function updateUnlockModalState() {
    const count = bulkUnlockSelected.length;
    document.getElementById('unlock-selection-count').textContent = count;
    document.getElementById('unlock-modal-send-btn').disabled = count === 0;
    document.getElementById('unlock-modal-send-btn').textContent = `Send Unlock Request (${count})`;
}

// Function to call server for bulk request (repurposed from previous logic)
function handleBulkUnlockRequest() {
    document.getElementById('unlock-selection-modal').classList.add('hidden');

    if (bulkUnlockSelected.length === 0) {
        showNotification('No schedules were selected for unlock.', false);
        return;
    }
    
    const currentYear = currentPlanningDate.getFullYear();
    const currentMonth = currentPlanningDate.getMonth();
    const currentShift = document.getElementById('shift-period-select').value;
    const sfcRef = currentContract?.sfcRef;

    const ids = bulkUnlockSelected.map(item => item.id);
    const refs = bulkUnlockSelected.map(item => item.ref);
    const names = bulkUnlockSelected.map(item => item.name); 

    if (!sfcRef || ids.length === 0) {
        showNotification('CRITICAL ERROR: Missing contract or employee IDs.', false);
        return;
    }

    toggleLoading(true);
    showNotification(`Sending Unlock Request Email for ${ids.length} schedules...`, true);
    
    bulkUnlockSelected = []; 

    google.script.run
        .withSuccessHandler((response) => {
            showNotification(response.message, response.success);
            toggleLoading(false);
        })
        .withFailureHandler((error) => {
            handleError(error); 
        })
        .requestUnlockEmailNotification(sfcRef, currentYear, currentMonth, currentShift, ids, refs, names);
}


  // --- UI HANDLERS ---

  function toggleLoading(isLoading) {
    document.getElementById('loading-alert').classList.toggle('hidden', !isLoading);
  }

  function showNotification(message, isSuccess = true) {
    const notification = document.getElementById('notification-area');
    notification.textContent = message;
    notification.classList.remove('opacity-0', 'bg-red-100', 'text-red-800', 'bg-green-100', 'text-green-800');
    
    if (isSuccess) {
      notification.classList.add('bg-green-100', 'text-green-800');
    } else {
      notification.classList.add('bg-red-100', 'text-red-800');
    }

    notification.classList.add('opacity-100');
    
    setTimeout(() => {
      notification.classList.remove('opacity-100');
      notification.classList.add('opacity-0');
    }, 3000);
  }

  function handleError(error) {
    console.error("APPS SCRIPT ERROR:", error);
    showNotification(`Error: ${error.message || 'An unknown error occurred in the script.'}`, false);
    toggleLoading(false);
  }
  
  // --- NEW: RELOAD PLAN HELPER ---
  function reloadPlanAndCheckExistence() {
      if (currentContract && currentContract.sfcRef) {
          document.getElementById('planning-area').classList.add('hidden'); 
          checkIfPlanExists(currentContract.sfcRef);
      } else {
          renderAttendancePlan(); 
      }
  }

  // *** NEW FUNCTION: Fetch the next sequential Group Number and update UI ***
  function fetchNextGroupNumberAndSetUI() {
    const sfcRef = currentContract?.sfcRef;
    const currentYear = currentPlanningDate.getFullYear();
    const currentMonth = currentPlanningDate.getMonth();
    const currentShift = document.getElementById('shift-period-select').value;
    const groupInput = document.getElementById('group-number-input');
    
    if (!sfcRef || !groupInput) return;

    // Set a temporary value while loading (Read-only input will show this)
    groupInput.value = 'Loading...';
    
    google.script.run
        .withSuccessHandler((nextGroup) => {
            currentGroup = nextGroup;
            groupInput.value = currentGroup;
            showNotification(`Next Group # set to ${currentGroup}.`, true);
        })
        .withFailureHandler((error) => {
            handleError(error);
            currentGroup = 'G1'; // Fallback
            groupInput.value = currentGroup;
            showNotification('Failed to auto-set Group #. Defaulting to G1.', false);
        })
        .getNextGroupNumber(sfcRef, currentYear, currentMonth, currentShift);
  }


  // --- CONTRACT SELECTION & DATA FETCHING ---

  function handleContractList(contracts) {
    contractList = contracts;
    const select = document.getElementById('contract-select');
    select.innerHTML = '<option value="">-- Choose Contract Group ID --</option>';

    contracts.forEach(contract => {
      const option = document.createElement('option');
      option.value = contract.id;
      // Gumamit ng Contract ID at SFC Ref# para sa mas madaling hanapin
      option.textContent = `${contract.id} - ${contract.status} (Ref#: ${contract.sfcRef})`;
      select.appendChild(option);
    });

    setTimeout(() => {
        $('#contract-select').select2({
            placeholder: "-- Choose Contract Group ID --",
            allowClear: true,
            width: '100%',
        }).on('select2:select', handleSelect2Change) 
          .on('select2:unselect', handleSelect2Change) 
          .on('change', handleSelect2Change); 

        toggleLoading(false);
        
        const picker = $('#month-year-picker');
        
        picker.datepicker({
            changeMonth: true,
            changeYear: true,
            showButtonPanel: true,
            dateFormat: 'MM yy', 
            onClose: function(dateText, inst) {
                const month = $("#ui-datepicker-div .ui-datepicker-month :selected").val();
                const year = $("#ui-datepicker-div .ui-datepicker-year :selected").val();
                
                if (month !== undefined && year !== undefined) {
                    const newDate = new Date(year, month, 1);
                    
                    const currentYear = currentPlanningDate.getFullYear();
                    const currentMonth = currentPlanningDate.getMonth();

                    if (newDate.getFullYear() !== currentYear || newDate.getMonth() !== currentMonth) {
                        currentPlanningDate = newDate;
                        
                        $(this).datepicker('setDate', newDate);
                        reloadPlanAndCheckExistence(); 
                    }
                }
                inst.dpDiv.removeClass('ui-month-year-only');
            },
            beforeShow: function(input, inst) {
                inst.dpDiv.addClass('ui-month-year-only');
                setTimeout(function(){
                    inst.dpDiv.find('.ui-datepicker-calendar').hide();
                    inst.dpDiv.find('.ui-datepicker-close').text('Select Period'); 
                }, 1);
            }
        });
        // Set the initial value
        updateDatePickerDisplay(currentPlanningDate.getFullYear(), currentPlanningDate.getMonth());
    }, 100); 

    // Populate Shift Periods
    const shiftSelect = document.getElementById('shift-period-select');
    shiftPeriods.forEach(period => {
      const option = document.createElement('option');
      option.value = period.key;
      option.textContent = period.label;
      shiftSelect.appendChild(option);
    });

    // Set default shift to 1st Half
    shiftSelect.value = '1stHalf';

    document.getElementById('shift-period-select').addEventListener('change', reloadPlanAndCheckExistence);
    // *** NEW: Listener for Save All Button ***
    document.getElementById('save-all-changes-btn').addEventListener('click', handleSaveAllChanges); 
    
    // *** NEW: Listener for Print Button (Calls server function) ***
    document.getElementById('print-plan-btn').addEventListener('click', handlePrintPlan);
    
    // *** NEW: Listener for Request Unlock Button (Modal Opener) ***
    document.getElementById('request-unlock-modal-btn').addEventListener('click', openUnlockSelectionModal);

    // *** NEW: Attach Bulk Listeners ***
    document.getElementById('start-bulk-select-btn').addEventListener('click', startBulkSelectionMode);
    document.getElementById('bulk-cancel-btn').addEventListener('click', exitBulkSelectionMode);
    document.getElementById('bulk-save-btn').addEventListener('click', (event) => saveBulkSchedule(event, null));
    
    // ** NEW: Group Number Input initialization **
    const groupInput = document.getElementById('group-number-input');
    if (groupInput) {
        // REMOVED: Manual input handler
        currentGroup = groupInput.value.trim().toUpperCase();
    }
  }

  // NEW: I-create ang handler para sa Select2 change
  function handleSelect2Change(event) {
      const contractId = $('#contract-select').val(); 
      
      if (!contractId || contractId === "") {
          document.getElementById('contract-details-area').classList.add('hidden');
          document.getElementById('planning-area').classList.add('hidden');
          document.getElementById('plan-action-area').classList.add('hidden');
          document.getElementById('initial-placeholder').classList.remove('hidden');
          currentContract = null;
          lockedIdRefMap = {}; 
          employeeMasterList = []; 
          sessionStorage.removeItem(CONTRACT_ID_CACHE_KEY); 
          
          isPlanSheetFullyLocked = false;
          updatePrintButtonState();
          return;
      }
      
      currentContract = contractList.find(c => c.id === contractId);
      sessionStorage.setItem(CONTRACT_ID_CACHE_KEY, currentContract.id); 
      
      if (currentContract) {
          displayContractDetails(currentContract);
          fetchEmployeeMasterData(currentContract.sfcRef); 
          fetchSignatoryMasterData(); 
          checkIfPlanExists(currentContract.sfcRef); 
      }
  }


function displayContractDetails(contract) {
    document.getElementById('sfc-ref').textContent = contract.sfcRef;
    document.getElementById('payor-company').textContent = contract.payorCompany;
    document.getElementById('agency').textContent = contract.agency;
    document.getElementById('service-type').textContent = contract.serviceType;
    document.getElementById('head-count').textContent = contract.headCount;
    // NEW: Display new contract fields
    document.getElementById('prop-grp-code').textContent = contract.propOrGrpCode;
    document.getElementById('sector').textContent = contract.sector;
    
    document.getElementById('contract-details-area').classList.remove('hidden');
    document.getElementById('initial-placeholder').classList.add('hidden');
    
    document.getElementById('plan-action-area').classList.add('hidden'); 
}

// NEW: Function to check if the plan sheets already exist
function checkIfPlanExists(sfcRef) {
    toggleLoading(true);
    
    const currentYear = currentPlanningDate.getFullYear();
    const currentMonth = currentPlanningDate.getMonth();
    const currentShift = document.getElementById('shift-period-select').value;
    
    google.script.run
        .withSuccessHandler(handlePlanExistence)
        .withFailureHandler(handleError)
        .checkContractSheets(sfcRef, currentYear, currentMonth, currentShift); 
}

// --- NEW FUNCTION: Update the Plan Period display based on current date/shift ---
  function updatePlanPeriodDisplay(year, month, shift) {
    const date = new Date(year, month, 1);
    const monthName = date.toLocaleString('en-US', { month: 'long' });
    const yearNum = date.getFullYear();
    const daysInMonth = getDaysInMonth(year, month);
    
    let dateRange = '';
    if (shift === '1stHalf') {
        dateRange = `${monthName} 1-15, ${yearNum} (${shift})`;
    } else {
        dateRange = `${monthName} 16-${daysInMonth}, ${yearNum} (${shift})`;
    }

    document.getElementById('plan-period-display').textContent = dateRange;
  }
  // --- END NEW FUNCTION ---
  
  // *** NEW HELPER: Update the Datepicker Input Field ***
  function updateDatePickerDisplay(year, month) {
    const date = new Date(year, month, 1);
    const monthYearText = date.toLocaleString('en-US', { month: 'long', year: 'numeric' });
    document.getElementById('month-year-picker').value = monthYearText;
    
    const picker = $('#month-year-picker');
    picker.datepicker('setDate', date);
  }
  // *** END NEW HELPER ***

// NEW: Handles the response from checkContractSheets
function handlePlanExistence(exists) {
    toggleLoading(false);
    const planArea = document.getElementById('planning-area');
    const actionArea = document.getElementById('plan-action-area');
    const statusText = document.getElementById('plan-status-text');
    const sfcRef = currentContract ? currentContract.sfcRef : null;

    const currentYear = currentPlanningDate.getFullYear();
    const currentMonth = currentPlanningDate.getMonth();
    const currentShift = document.getElementById('shift-period-select').value;
    updatePlanPeriodDisplay(currentYear, currentMonth, currentShift); 
    updateDatePickerDisplay(currentYear, currentMonth); 

    actionArea.classList.add('hidden'); 

    // CRITICAL: Fetch the calculated group number first
    fetchNextGroupNumberAndSetUI();

    // Since the sheet is consolidated, it always 'exists' if it's been initialized once.
    statusText.textContent = 'Attendance Plan Status: Loading Consolidated Plan Data...';
    fetchAttendanceData(sfcRef); 
}

// NEW WORKFLOW: Show blank plan (No server call) - Now triggered after failed fetchAttendanceData
function showBlankPlan() {
    if (!currentContract) {
        showNotification('Please select a Contract Group ID first.', false);
        return;
    }

    const currentYear = currentPlanningDate.getFullYear();
    const currentMonth = currentPlanningDate.getMonth();
    const currentShift = document.getElementById('shift-period-select').value;
    updatePlanPeriodDisplay(currentYear, currentMonth, currentShift); 
    
    currentContract.employees = []; 
    currentContract.planMap = {}; 
    lockedIdRefMap = {}; 
    
    pendingAttendanceChanges = {}; 
    pendingEmployeeInfoChanges = {}; 
    
    // CRITICAL: Fetch the next group number on blank plan load as well
    fetchNextGroupNumberAndSetUI();

    document.getElementById('planning-area').classList.remove('hidden'); 
    showNotification('Ready to plan. No existing data found for this period. Changes will be saved as V1.0.', true);

    renderAttendancePlan(); 
    toggleLoading(false);
    
    isPlanSheetFullyLocked = false;
    updatePrintButtonState(); 
}


function fetchAttendanceData(sfcRef) {
    toggleLoading(true);
    pendingAttendanceChanges = {}; 
    pendingEmployeeInfoChanges = {}; 
    
    const currentYear = currentPlanningDate.getFullYear();
    const currentMonth = currentPlanningDate.getMonth(); 
    const currentShift = document.getElementById('shift-period-select').value;

    updatePlanPeriodDisplay(currentYear, currentMonth, currentShift); 

    google.script.run
      .withSuccessHandler(handleAttendanceData)
      .withFailureHandler(handleError)
      .getAttendancePlan(sfcRef, currentYear, currentMonth, currentShift); 
}


function handleAttendanceData(data) {
    currentContract.employees = data.employees;
    currentContract.planMap = data.planMap;
    
    lockedIdRefMap = data.lockedIdRefMap || {}; 
    const lockedIds = Object.keys(lockedIdRefMap);
    
    document.getElementById('planning-area').classList.remove('hidden'); 
    
    if (data.employees.length === 0) {
        // If plan exists but has no data for the current period (first entry point)
        showBlankPlan();
        return;
    }

    showNotification(`Attendance Plan loaded successfully! (Locked Schedules: ${lockedIds.length})`, true);

    renderAttendancePlan();
    toggleLoading(false);
    
    checkPlanSheetLockState(); 
}

// --- DATE NAVIGATION ---

  function navigateMonth(direction) {
    currentPlanningDate.setMonth(currentPlanningDate.getMonth() + direction);
    currentPlanningDate.setDate(1); 
  }

  function getDaysInMonth(year, month) {
    return new Date(year, month + 1, 0).getDate();
  }

  function renderAttendancePlan() {
    if (!currentContract) return;

    const year = currentPlanningDate.getFullYear();
    const month = currentPlanningDate.getMonth();
    const daysInMonth = getDaysInMonth(year, month);
    const selectedShift = document.getElementById('shift-period-select').value;
    
    const monthName = currentPlanningDate.toLocaleString('en-US', { month: 'short' }); 

    updateDatePickerDisplay(year, month); 

    // UPDATED LOGIC FOR DAY1-DAY16 COLUMN MAPPING
    const startColIndex = 1;
    const endColIndex = 16;
    const startDayOfMonth = selectedShift === '1stHalf' ? 1 : 16;
    
    const lockedIds = Object.keys(lockedIdRefMap);

    const tableContainer = document.getElementById('attendance-table-container');
    tableContainer.innerHTML = '';

    const table = document.createElement('table');
    table.className = 'w-full text-sm text-left text-gray-700 border-collapse';
    
    // --- TABLE HEAD ---
    const thead = table.createTHead();
    const headerRow1 = thead.insertRow();
    const headerRow2 = thead.insertRow();
    
    // UPDATED FIXED HEADERS (5 fixed employee info columns)
    const empInfoHeader = ['No.', 'Personnel ID', 'Personnel Name', 'POSITION', 'AREA POSTING']; 
    
    // --- 1. Header Row 1 (Main Fixed Labels & Date/Month) ---
    empInfoHeader.forEach((headerText, index) => {
        const th = document.createElement('th');
        th.scope = 'col';
        th.textContent = headerText;
        th.className = 'sticky-col-header text-xs font-semibold uppercase tracking-wider p-3 bg-gray-100 border-r border-b border-gray-300 z-20'; 
        
        // Freeze first few columns
        if (index <= 1) th.classList.add('freeze-1', 'z-30'); // No. and ID
        if (index === 2) th.classList.add('freeze-2', 'z-30'); // Name
        headerRow1.appendChild(th);
    });
    
    // --- 2. Header Row 2 (Empty Fixed Cells & Day Name) ---
    empInfoHeader.forEach((headerText, index) => {
        const th = document.createElement('th');
        th.scope = 'col';
        th.textContent = ''; // Empty content for alignment
        th.className = 'sticky-col-header text-xs font-semibold uppercase tracking-wider p-3 bg-gray-50 border-r border-gray-300 z-20'; 

        // Freeze first few columns
        if (index <= 1) th.classList.add('freeze-1', 'z-30'); // No. and ID
        if (index === 2) th.classList.add('freeze-2', 'z-30'); // Name
        headerRow2.appendChild(th);
    });


    // Date/Day Headers (Starts at index 5)
    // NEW: Loop through column index (1-16) and calculate the actual day (d)
    for (let colIndex = startColIndex; colIndex <= endColIndex; colIndex++) {
        const d = startDayOfMonth + colIndex - 1; // Actual Day of the Month

        if (d > daysInMonth) continue; // Skip if actual day exceeds max days in month (e.g., Nov 31)
        
        // **NEW FIX: Stop 1st Half at 15**
        if (selectedShift === '1stHalf' && d > 15) continue; // <--- ADDED LINE
        
        const dayOfMonth = new Date(year, month, d);
        const dayName = dayNames[dayOfMonth.getDay()];
        const dateColWidth = '70px';
        
        // --- HEADER ROW 1 (Date/Month) ---
        const th = document.createElement('th');
        th.scope = 'col';
        th.style.width = dateColWidth;
        th.style.minWidth = dateColWidth;
        th.className = 'text-xs font-semibold uppercase tracking-wider p-1 text-center border-r border-b bg-gray-100'; 
        // Display the actual day (d)
        th.innerHTML = `<span>${d}</span><span class="block font-medium text-[10px] uppercase text-gray-500">${monthName}</span>`; 
        headerRow1.appendChild(th);
        
        // --- HEADER ROW 2 (Day Name) ---
        const thDay = document.createElement('th');
        thDay.scope = 'col';
        thDay.textContent = dayName;
        thDay.style.width = dateColWidth;
        thDay.style.minWidth = dateColWidth;
        thDay.className = 'text-xs font-medium uppercase tracking-wider p-3 text-center border-r bg-gray-50'; 
        headerRow2.appendChild(thDay);
    }
    
    // --- TABLE BODY ---
    const tbody = table.createTBody();

    let rowsToRender = currentContract.employees.slice() || [];
    
    Object.keys(pendingEmployeeInfoChanges).forEach(stableKey => {
         const change = pendingEmployeeInfoChanges[stableKey];
         const isUnsavedNewRow = change.originalEmployeeId === '';
         
         if (isUnsavedNewRow) {
             if (!rowsToRender.some(e => e.id === change.id || e.id === stableKey)) {
                 rowsToRender.push({
                     no: 0, 
                     id: change.id, 
                     name: change.name, 
                     position: change.position, 
                     area: change.area,
                     isNew: true,
                 });
             }
         }
    });

    const maxRenderedRows = Math.max(currentContract.headCount, rowsToRender.length);
    
    rowsToRender = rowsToRender.map((emp, index) => ({
        ...emp,
        no: index + 1 
    }));


    for (let i = 0; i < maxRenderedRows; i++) {
        const employee = rowsToRender[i] || { 
            no: i + 1, 
            id: '', 
            name: '', 
            position: '', 
            area: '' 
        };
        
        const stableLookupKey = employee.id || `TEMP_${employee.no}`; 
        
        const pendingInfo = pendingEmployeeInfoChanges[stableLookupKey]; 
        
        const displayId = (pendingInfo && pendingInfo.id) ? pendingInfo.id : employee.id;
        const displayName = (pendingInfo && pendingInfo.name) ? pendingInfo.name : employee.name;
        const displayPosition = (pendingInfo && pendingInfo.position) ? pendingInfo.position : employee.position;
        const displayArea = (pendingInfo && pendingInfo.area) ? pendingInfo.area : employee.area;
        
        const isSavedRow = !!(employee.id || (pendingInfo && pendingInfo.originalEmployeeId)); 
        const isMarkedForDeletion = pendingInfo && pendingInfo.isDeleted; 
        
        const lockedRefNum = lockedIdRefMap[employee.id]; 
        const isPrintLocked = !!lockedRefNum && !isMarkedForDeletion; 
        
        const isRowBlank = !displayId.trim() && !displayName.trim() && !Object.keys(pendingInfo || {}).length;

        const tr = tbody.insertRow();
        tr.dataset.stableKey = stableLookupKey; 
        
        if (isRowBlank || isMarkedForDeletion) {
             tr.classList.add('print-empty-row'); 
        }
        
        if (isMarkedForDeletion) {
            tr.classList.add('bg-red-200', 'opacity-50', 'line-through');
        } else if (isPrintLocked) {
             tr.classList.add('bg-gray-300', 'opacity-80', 'locked-row'); 
        }

        
        // 1. Employee Info Cells (Fixed Columns)
        // No. 
        let td = tr.insertCell();
        td.className = 'sticky-col text-center p-0 bg-gray-50 font-bold border-r border-b z-10 freeze-1 relative'; 
        
        let innerHTML = `<span class="block py-2">${employee.no}</span>`;
        
        td.innerHTML = innerHTML;
        
        if (isSavedRow || !isRowBlank) { 
            const actionContainer = document.createElement('div');
            actionContainer.className = 'absolute top-1/2 right-0 transform -translate-y-1/2 flex space-x-0.5 pr-1 print-hidden';
            
            const deleteButton = document.createElement('button');
            deleteButton.type = 'button';
            const isDeleteDisabled = isPrintLocked;
            deleteButton.className = `action-icon p-1 text-red-600 hover:bg-red-200 transition duration-150 delete-row-btn rounded-full ${isMarkedForDeletion ? 'bg-red-400' : ''} ${isDeleteDisabled ? 'cursor-not-allowed opacity-40' : ''}`; 
            deleteButton.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 0 00-1 1v3M4 7h16" />
                </svg>
            `;
            deleteButton.dataset.stableKey = stableLookupKey;
            deleteButton.dataset.isDeleted = isMarkedForDeletion ? 'true' : 'false';
            
            if (!isDeleteDisabled) {
               deleteButton.addEventListener('click', handleDeleteRowToggle);
            }
            
            actionContainer.appendChild(deleteButton);
            td.appendChild(actionContainer);
        }
        
        if (!isRowBlank && !isSavedRow) {
             const newLabel = document.createElement('span');
             newLabel.textContent = 'NEW';
             newLabel.className = 'new-label-no-col absolute top-1/2 right-0 transform -translate-y-1/2 mr-1 text-[8px] font-bold text-green-700 bg-green-200 px-1 py-0.5 rounded print-hidden';
             td.appendChild(newLabel);
        }

        // Personnel ID (Input) - Index 1
        td = tr.insertCell();
        let input = document.createElement('input');
        input.type = 'text';
        input.setAttribute('list', 'employee-id-list'); 
        input.value = displayId;
        input.placeholder = 'ID';
        input.maxLength = 20; 
        input.readOnly = isSavedRow || isMarkedForDeletion || isPrintLocked; 
        input.dataset.oldPersonnelId = stableLookupKey; 
        input.dataset.field = 'id';
        input.dataset.rowNo = employee.no; 
        input.className = 'personnel-info-input text-center p-1 border-none focus:ring-blue-400 w-full bg-transparent ' + (input.readOnly ? 'read-only' : ''); 
        td.appendChild(input);
        td.className = 'sticky-col p-0 bg-white border-r border-b z-10 freeze-1 relative'; 
        
        // --- UNLOCK BUTTON IN PERSONNEL ID COLUMN (for locked rows) ---
        if (isPrintLocked) {
            const unlockButton = document.createElement('button');
            unlockButton.type = 'button';
            unlockButton.title = `Request Admin Unlock for ID ${employee.id} (Ref #${lockedRefNum})`;
            unlockButton.className = `action-icon p-1 text-purple-600 hover:bg-purple-200 transition duration-150 rounded-full unlock-row-btn print-hidden`;
            unlockButton.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M8 11V7a4 4 0 118 0v4m-5 9h2m-5-3h10a2 2 0 002-2v-6a2 2 0 00-2-2H8a2 2 0 00-2 2v6a2 2 0 002 2z" />
                </svg>
            `;
            unlockButton.addEventListener('click', () => {
                bulkUnlockSelected = [{ id: stableLookupKey, ref: lockedRefNum, name: displayName }];
                handleBulkUnlockRequest(); 
            });
            
            const unlockContainer = document.createElement('div');
            unlockContainer.className = 'absolute top-1/2 right-1 transform -translate-y-1/2 print-hidden flex space-x-0.5 pr-1 z-30';
            unlockContainer.appendChild(unlockButton);
            td.appendChild(unlockContainer);
            
            const lockTag = document.createElement('span');
            lockTag.className = 'text-[9px] font-extrabold text-blue-800 bg-blue-200 px-1.5 py-0.5 rounded-full whitespace-nowrap absolute top-1 left-1 print-hidden';
            lockTag.title = `Locked by Print Ref. #${lockedRefNum}`;
            lockTag.textContent = `REF ${lockedRefNum}`;
            td.appendChild(lockTag);
        }
        // --- END UNLOCK BUTTON ---
        
        // Personnel Name (Input) - Index 2
        td = tr.insertCell();
        input = document.createElement('input');
        input.type = 'text';
        input.setAttribute('list', 'employee-name-list'); 
        input.value = displayName; 
        input.placeholder = 'Full Name';
        input.readOnly = isSavedRow || isMarkedForDeletion || isPrintLocked; 
        input.dataset.oldPersonnelId = stableLookupKey; 
        input.dataset.field = 'name';
        input.className = 'personnel-info-input p-1 border-none focus:ring-blue-400 w-full bg-transparent ' + (input.readOnly ? 'read-only' : ''); 
        td.appendChild(input);
        td.className = 'sticky-col p-0 bg-white border-r border-b z-10 freeze-2';
        
        // Position (Input) - Index 3
        td = tr.insertCell();
        input = document.createElement('input');
        input.type = 'text';
        input.setAttribute('list', 'employee-position-list'); 
        input.value = displayPosition; 
        input.placeholder = 'Position';
        input.readOnly = isSavedRow || isMarkedForDeletion || isPrintLocked; 
        input.dataset.oldPersonnelId = stableLookupKey; 
        input.dataset.field = 'position';
        input.className = 'personnel-info-input p-1 border-none focus:ring-blue-400 w-full bg-transparent ' + (input.readOnly ? 'read-only' : ''); 
        td.appendChild(input);
        td.className = 'p-0 bg-white border-r border-b';
        
        // Area Posting (Input) - Index 4
        td = tr.insertCell();
        input = document.createElement('input');
        input.type = 'text';
        input.setAttribute('list', 'employee-area-list'); 
        input.value = displayArea; 
        input.placeholder = 'Area';
        input.readOnly = isSavedRow || isMarkedForDeletion || isPrintLocked; 
        input.dataset.oldPersonnelId = stableLookupKey; 
        input.dataset.field = 'area';
        input.className = 'personnel-info-input p-1 border-none focus:ring-blue-400 w-full bg-transparent ' + (input.readOnly ? 'read-only' : ''); 
        td.appendChild(input);
        td.className = 'p-0 bg-white border-r border-b';


        // Add event listeners for Personnel Info updates
        if (!isSavedRow && !isPrintLocked && !isMarkedForDeletion) {
            tr.querySelectorAll('.personnel-info-input').forEach(infoInput => {
                infoInput.addEventListener('input', (e) => handlePersonnelInfoChange(e, employee));
                infoInput.addEventListener('change', (e) => handlePersonnelInfoChange(e, employee));
            });
        }


        // 2. Attendance Plan Cells (Dynamic Dates) - Starts at index 5
        const currentPersonnelId = displayId; 
        let hasScheduleForShift = false; 
        
        // NEW LOGIC: Loop through column index (1-16) and calculate the actual day (d)
        for (let colIndex = startColIndex; colIndex <= endColIndex; colIndex++) {
            const d = startDayOfMonth + colIndex - 1; // Actual Day of the Month

            if (d > daysInMonth) continue; // Skip if actual day exceeds max days in month
            
            // **NEW FIX: Stop 1st Half at 15**
            if (selectedShift === '1stHalf' && d > 15) continue; // <--- ADDED LINE
            
            const dayKeyUnpadded = `${year}-${month + 1}-${d}`;
            
            const trimmedCurrentId = currentPersonnelId.toString().trim();
            const trimmedEmployeeId = employee.id.toString().trim();
            const trimmedShift = selectedShift.toString().trim();
            const trimmedDayKey = dayKeyUnpadded.toString().trim(); 

            const planKey = `${trimmedCurrentId}_${trimmedDayKey}_${trimmedShift}`;
            const pendingStatus = pendingAttendanceChanges[planKey];

            const savedDataKeyUnpadded = `${trimmedEmployeeId}_${trimmedDayKey}_${trimmedShift}`;
            const savedStatusUnpadded = currentContract.planMap[savedDataKeyUnpadded] || '';


            let status = pendingStatus !== undefined ? pendingStatus : '';

            if (status === '') {
                 if (savedStatusUnpadded !== '') {
                    status = savedStatusUnpadded;
                 }
            }

            if (status !== '') {
                hasScheduleForShift = true; 
            }
            
            td = tr.insertCell();
            const isSelected = bulkSelectedCells.includes(td);
            const isCellLocked = isPrintLocked || isMarkedForDeletion;
            const cursorClass = isCellLocked ? 'cursor-not-allowed' : (isBulkSelectionMode ? 'cursor-crosshair' : 'cursor-pointer');
            
            td.className = `cell-container text-center border-r border-b transition duration-100 ease-in-out ${cursorClass} ${isSelected ? 'cell-selected' : ''}`;
            
            const dateColWidth = '70px';
            td.style.width = dateColWidth;
            td.style.minWidth = dateColWidth;
            
            updateCellVisuals(td, status, dayKeyUnpadded); 

            td.dataset.dayKey = dayKeyUnpadded; 
            td.dataset.shiftKey = trimmedShift;
            td.dataset.originalId = employee.id; 
            
            if (!isCellLocked) {
                td.addEventListener('click', handleCellClick);
                
                if (isBulkSelectionMode) {
                    td.removeEventListener('click', handleCellClick);
                }
            }
        }
    }
    
    tableContainer.appendChild(table);
  }

  // NEW FUNCTION: Apply Schedule Pattern to a specific grid row
function applySchedulePatternToRow(rowElement, personnelId, patternMap) {
    const currentShift = document.getElementById('shift-period-select').value;
    const year = currentPlanningDate.getFullYear();
    const month = currentPlanningDate.getMonth();
    
    const originalId = rowElement.dataset.stableKey.startsWith('TEMP_') ? '' : rowElement.dataset.stableKey;

    // UPDATED LOGIC: Loop through column index (1-16)
    const startColIndex = 1;
    const endColIndex = 16;
    const startDayOfMonth = currentShift === '1stHalf' ? 1 : 16;
    const daysInMonth = getDaysInMonth(year, month);
    
    rowElement.querySelectorAll('.cell-container').forEach((cellElement, cellColIndex) => {
        
        // Calculate the actual day based on the cell's position relative to the 6th column (index 5)
        const colIndex = cellColIndex + 1; // 1 to 16
        const d = startDayOfMonth + colIndex - 1; 

        if (d > daysInMonth) return; // Skip if actual day exceeds max days in month

        // **NEW FIX: Stop 1st Half at 15**
        if (currentShift === '1stHalf' && d > 15) return; // <--- ADDED LINE

        const dayKey = `${year}-${month + 1}-${d}`; 
        
        const [y, m, day] = dayKey.split('-').map(Number);
        const date = new Date(y, m - 1, day); 
        const dayOfWeek = date.getDay(); 
        
        const newStatus = patternMap[dayOfWeek.toString()] || ''; 

        const currentVisualStatus = cellElement.querySelector('.attendance-cell-bg').textContent.trim();
        if (newStatus && currentVisualStatus === '') { 
            const currentPlanKey = `${personnelId}_${dayKey}_${currentShift}`;
            const originalPlanKey = `${originalId}_${dayKey}_${currentShift}`;

            const originalStatus = currentContract.planMap[originalPlanKey] || '';

            if (originalStatus !== newStatus) {
                pendingAttendanceChanges[currentPlanKey] = newStatus; 
            } else {
                delete pendingAttendanceChanges[currentPlanKey];
            }
            
            updateCellVisuals(cellElement, newStatus, dayKey);
        }
    });

    checkPlanSheetLockState(); 
}
// --- END NEW FUNCTION ---
  
  // NEW FUNCTION: Handle Delete Row Toggle
  function handleDeleteRowToggle(event) {
      const button = event.currentTarget;
      const row = button.closest('tr');
      const stableKey = button.dataset.stableKey;
      const isCurrentlyDeleted = button.dataset.isDeleted === 'true';
      const inputs = row.querySelectorAll('.personnel-info-input');
      
      const employee = currentContract.employees.find(e => e.id === stableKey) || { 
          id: '', 
          name: '', 
          position: '', 
          area: '' 
      };
      
      if (lockedIdRefMap[employee.id]) {
          showNotification('Cannot delete: This employee\'s schedule has been printed and locked (Ref #'+ lockedIdRefMap[employee.id] +').', false);
          return;
      }
      
      let pendingChange = pendingEmployeeInfoChanges[stableKey] || {
          id: employee.id, 
          name: employee.name, 
          position: employee.position, 
          area: employee.area,
          isNew: !employee.id,
          originalEmployeeId: employee.id,
          isDeleted: false 
      };
      
      if (!isCurrentlyDeleted) {
          // MARK FOR DELETION
          
          const idInput = row.querySelector('[data-field="id"]');
          const currentIdInInput = idInput.value.trim();
          
          const customConfirm = (message, onConfirm, onCancel) => {
              const modalHtml = `
                  <div id="delete-confirm-modal" class="fixed inset-0 bg-gray-600 bg-opacity-50 z-[60] flex justify-center items-center p-4">
                      <div class="bg-white rounded-lg shadow-2xl p-6 w-full max-w-sm">
                          <h3 class="text-lg font-bold mb-4 text-red-700">Confirm Deletion</h3>
                          <p class="text-gray-700 mb-6">${message}</p>
                          <div class="flex justify-end space-x-3">
                              <button id="delete-cancel-btn" class="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300">Cancel</button>
                              <button id="delete-confirm-btn" class="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700">Confirm Delete</button>
                          </div>
                      </div>
                  </div>
              `;
              document.body.insertAdjacentHTML('beforeend', modalHtml);
              
              document.getElementById('delete-confirm-btn').addEventListener('click', () => {
                  document.getElementById('delete-confirm-modal').remove();
                  onConfirm();
              });
              
              document.getElementById('delete-cancel-btn').addEventListener('click', () => {
                  document.getElementById('delete-confirm-modal').remove();
                  onCancel();
              });
          };

          customConfirm(`Are you sure you want to mark employee "${employee.name || stableKey}" (ID: ${employee.id}) for deletion? This will clear all schedule changes and data locally. You must click 'Save All Changes' to permanently delete from Sheets.`, 
            () => { // On Confirm
                pendingChange.isDeleted = true;
                pendingEmployeeInfoChanges[stableKey] = pendingChange;
                
                inputs.forEach(input => {
                    input.value = '';
                    input.readOnly = true;
                    input.classList.add('read-only');
                });
                
                Object.keys(pendingAttendanceChanges).forEach(key => {
                    if (key.startsWith(currentIdInInput + '_')) { 
                        delete pendingAttendanceChanges[key];
                    }
                });

                button.dataset.isDeleted = 'true';
                button.classList.add('bg-red-400');
                showNotification(`Employee ${employee.id} marked for DELETION. Click Save All Changes to proceed.`, false);
                renderAttendancePlan(); 
                checkPlanSheetLockState(); 
            }, 
            () => { 
              
            }
          );
          
      } else {
          // UNDO DELETION (Revert to Original Data)
          delete pendingEmployeeInfoChanges[stableKey];
          
          inputs.forEach(input => {
              const field = input.dataset.field;
              input.value = employee[field];
              const isSaved = employeeMasterList.some(e => e.id === employee.id); 
              input.readOnly = isSaved;
              input.classList.toggle('read-only', isSaved);
          });
          
          if (Object.keys(pendingEmployeeInfoChanges[stableKey] || {}).length === 0) {
              delete pendingEmployeeInfoChanges[stableKey];
          }

          button.dataset.isDeleted = 'false';
          button.classList.remove('bg-red-400');
          showNotification(`Deletion for Employee ${employee.id} UNDONE.`, true);
          renderAttendancePlan(); 
          checkPlanSheetLockState(); 
      }
      
  }
  
  // --- EMPLOYEE INFO HANDLERS (Manual Save) ---
  
  function handlePersonnelInfoChange(event, employee) {
      const input = event.target;
      const field = input.dataset.field;
      const oldPersonnelKey = input.dataset.oldPersonnelId; 
      let newValue = input.value;
      
      let pendingChange = pendingEmployeeInfoChanges[oldPersonnelKey] || {
          id: employee.id, 
          name: employee.name, 
          position: employee.position, 
          area: employee.area,
          isNew: !employee.id,
          originalEmployeeId: employee.id,
          isDeleted: false 
      };
      
      const previousIdValue = pendingChange.id; 

      if (employee.id || pendingChange.isDeleted || lockedIdRefMap[employee.id]) {
           showNotification('Cannot edit: Saved row is locked. You must delete and re-add to change info.', false);
           input.value = employee[field];
           return;
      }

      const row = input.closest('tr');
      let masterRecordFound = null; 
      let masterRecord = null;
      if (field === 'id') {
           masterRecord = employeeMasterList.find(e => e.id === newValue.trim());
      } else if (field === 'name') {
           masterRecord = employeeMasterList.find(e => e.name === newValue.trim());
      }
      
      const isSaved = employeeMasterList.some(e => e.id === employee.id);

      if (masterRecord) {
          masterRecordFound = masterRecord; 
          row.querySelector('[data-field="id"]').value = masterRecord.id;
          row.querySelector('[data-field="name"]').value = masterRecord.name;
          row.querySelector('[data-field="position"]').value = masterRecord.position;
          row.querySelector('[data-field="area"]').value = masterRecord.area;
          
          pendingChange.id = masterRecord.id;
          pendingChange.name = masterRecord.name;
          pendingChange.position = masterRecord.position;
          pendingChange.area = masterRecord.area;
          
          showNotification(`Employee details auto-filled for ${masterRecord.name}. Click 'Save All Changes' to save this new entry.`, true);

      } else {
         pendingChange[field] = newValue;
      }

      if (field === 'id') {
          const cleanId = pendingChange.id; 
          
          if (cleanId && !PERSONNEL_ID_REGEX.test(cleanId)) {
               showNotification('Personnel ID must contain numbers only.', false);
               input.value = employee.id; 
               return; 
          }
          
          if (cleanId) {
              if (isDuplicateId(cleanId, employee.id, employee.no)) { 
                  showNotification(`Personnel ID "${cleanId}" is already used in another row (saved or pending).`, false);
                  
                  const nameInput = row.querySelector('[data-field="name"]');
                  const positionInput = row.querySelector('[data-field="position"]');
                  const areaInput = row.querySelector('[data-field="area"]');
                  
                  input.value = employee.id; 
                  if (nameInput) nameInput.value = employee.name; 
                  if (positionInput) positionInput.value = employee.position; 
                  if (areaInput) areaInput.value = employee.area;
                  
                  pendingChange.id = employee.id;
                  pendingChange.name = employee.name; 
                  pendingChange.position = employee.position; 
                  pendingChange.area = employee.area;
                  
                  if (employee.id === input.value) { 
                      delete pendingEmployeeInfoChanges[oldPersonnelKey];
                  }
                  return; 
              }
          }
      } else if (field === 'name' || field === 'position' || field === 'area') {
          if (!masterRecord) { 
              let cleanedValue = pendingChange[field].toUpperCase(); 
              let regexToUse = '';
              
              if (field === 'name') {
                  regexToUse = /[^A-Z\s.,-]/g; 
              } else {
                  regexToUse = /[^A-Z0-9\s.,-]/g; 
              }

              cleanedValue = cleanedValue.replace(regexToUse, ''); 
              
              if (cleanedValue !== pendingChange[field].toUpperCase()) { 
                  showNotification(`Special characters and/or numbers removed from ${field}.`, false);
              }
              
              input.value = cleanedValue;
              pendingChange[field] = cleanedValue;
          }

          
          if (field === 'name' && pendingChange.name) {
              if (isDuplicateName(pendingChange.name, employee.id, employee.no)) {
                  showNotification(`FATAL ERROR: Personnel Name "${pendingChange.name}" is already used by another employee. Please edit the name to be unique (e.g., add initials/middle name) before saving.`, false);
                  
                  const idInput = row.querySelector('[data-field="id"]');
                  const positionInput = row.querySelector('[data-field="position"]');
                  const areaInput = row.querySelector('[data-field="area"]');
                  
                  input.value = employee.name; 
                  if (idInput) idInput.value = employee.id; 
                  if (positionInput) positionInput.value = employee.position; 
                  if (areaInput) areaInput.value = employee.area;
                  
                  pendingChange.id = employee.id;
                  pendingChange.name = employee.name; 
                  pendingChange.position = employee.position; 
                  pendingChange.area = employee.area;
                  
                  if (employee.name === input.value) { 
                      delete pendingEmployeeInfoChanges[oldPersonnelKey];
                  }
                  return; 
              }
          }
      }

      
      if (field === 'id') {
          
          if (pendingChange.id === '' && previousIdValue !== '') {
              const row = input.closest('tr');
              const idToClear = previousIdValue; 

              if (idToClear) {
                  const nameInput = row.querySelector('[data-field="name"]');
                  const positionInput = row.querySelector('[data-field="position"]');
                  const areaInput = row.querySelector('[data-field="area"]');
                  
                  if (nameInput) nameInput.value = '';
                  if (positionInput) positionInput.value = '';
                  if (areaInput) areaInput.value = '';
                  
                  pendingChange.name = '';
                  pendingChange.position = '';
                  pendingChange.area = '';

                  Object.keys(pendingAttendanceChanges).forEach(key => {
                      if (key.startsWith(idToClear + '_')) { 
                          delete pendingAttendanceChanges[key];
                      }
                  });
                  
                  row.querySelectorAll('.cell-container').forEach(cell => {
                       const dayKey = cell.dataset.dayKey;
                       updateCellVisuals(cell, currentContract.planMap[`${employee.id}_${dayKey}_${cell.dataset.shiftKey}`] || '', dayKey); 
                  });
                  showNotification('Personnel info and schedule cleared locally as Personnel ID was made blank.', false);
                  checkPlanSheetLockState(); 
              }
          }
      }

      if (masterRecordFound && !isSaved && !pendingChange.isDeleted && !lockedIdRefMap[oldPersonnelKey]) {
          const currentIdInInput = row.querySelector('[data-field="id"]').value.trim();
          if (currentIdInInput === masterRecordFound.id) {
               google.script.run
                   .withSuccessHandler((patternMap) => {
                       if (Object.keys(patternMap).length > 0) {
                           applySchedulePatternToRow(row, masterRecordFound.id, patternMap);
                           showNotification(`Schedule pattern found and auto-filled for ${masterRecordFound.name}. Review changes and click 'Save All Changes'.`, true);
                       }
                   })
                   .withFailureHandler(handleError)
                   .getEmployeeSchedulePattern(currentContract.sfcRef, masterRecordFound.id);
          }
      }
      
      const isChanged = (pendingChange.id.trim() !== employee.id || 
                         pendingChange.name.trim() !== employee.name || 
                         pendingChange.position.trim() !== employee.position || 
                         pendingChange.area.trim() !== employee.area ||
                         (pendingChange.originalEmployeeId === '' && pendingChange.id.trim() !== '')); 

      if (isChanged) {
          pendingEmployeeInfoChanges[oldPersonnelKey] = pendingChange;
      } else {
          delete pendingEmployeeInfoChanges[oldPersonnelKey];
          
          if (field === 'id' || field === 'name') {
              const row = input.closest('tr');
              const attendanceId = employee.id; 

              if (attendanceId) {
                  if (employee.id !== '') {
                      Object.keys(pendingAttendanceChanges).forEach(key => {
                          if (key.startsWith(attendanceId + '_')) { 
                              delete pendingAttendanceChanges[key];
                          }
                      });
                      
                      row.querySelectorAll('.cell-container').forEach(cell => {
                           const dayKey = cell.dataset.dayKey;
                           updateCellVisuals(cell, currentContract.planMap[`${employee.id}_${dayKey}_${cell.dataset.shiftKey}`] || '', dayKey); 
                      });
                  }
              }
          }
      }
  }


  // --- ATTENDANCE PLAN HANDLERS (Manual Save) ---

  function updateCellVisuals(cell, status, dayKey) {
    const dayOfMonth = new Date(dayKey);
    const dayOfWeek = dayOfMonth.getDay(); 

    const isDeletedRow = cell.closest('tr').classList.contains('line-through');
    const isLockedRow = cell.closest('tr').classList.contains('locked-row');
    
    const isSelected = bulkSelectedCells.includes(cell);
    const isCellLocked = isLockedRow || isDeletedRow;
    const cursorClass = isCellLocked ? 'cursor-not-allowed' : (isBulkSelectionMode ? 'cursor-crosshair' : 'cursor-pointer');
    
    cell.className = `cell-container text-center border-r border-b transition duration-100 ease-in-out ${cursorClass} ${isSelected ? 'cell-selected' : ''}`;
    
    cell.innerHTML = `<div class="p-2 h-full w-full flex items-center justify-center text-sm font-medium attendance-cell-bg">${status}</div>`;
    const innerDiv = cell.querySelector('.attendance-cell-bg');

    let bgColor = 'bg-white';
    let textColor = 'text-gray-900';
    let isWork = false;

    if (status.length > 0) {
      if (status === 'RD') {
        bgColor = 'status-rd';
        textColor = 'text-red-700 font-bold';
      } else if (status === 'RH') {
        bgColor = 'status-rh';
        textColor = 'text-blue-700 font-bold';
      } else if (status === 'SH') {
        bgColor = 'status-sh';
        textColor = 'text-yellow-700 font-bold';
        isWork = true;
      } else if (status === 'NA') { 
        bgColor = 'status-na'; 
        textColor = 'text-gray-500 font-bold';
      } else {
        bgColor = 'status-work';
        textColor = 'text-green-700 font-bold';
        isWork = true;
      }
    } else {
      bgColor = 'bg-gray-100';
      textColor = 'text-gray-500';
    }
    
    if (!isWork && !status && (dayOfWeek === 0 || dayOfWeek === 6)) {
        bgColor = 'bg-gray-200'; 
    }
    
    if (isDeletedRow) {
        bgColor = 'bg-red-300';
        textColor = 'text-red-500';
        status = 'DELETED';
        innerDiv.textContent = status;
    } else if (isLockedRow) { 
        bgColor = 'bg-gray-400';
        textColor = 'text-gray-700';
        innerDiv.textContent = status || 'LOCKED';
    }
    
     innerDiv.className = `p-2 h-full w-full flex items-center justify-center text-sm font-medium attendance-cell-bg ${bgColor} ${textColor}`;
  }


  function handleCellClick(event) {
    if (isBulkSelectionMode) return; 
    
    const targetCell = event.currentTarget;
    const row = targetCell.closest('tr'); 
    
    const isCellLocked = row.classList.contains('line-through') || row.classList.contains('locked-row');
    if (isCellLocked) {
        const originalId = targetCell.dataset.originalId || '';
        showNotification('Cannot edit: This employee\'s schedule has been printed and locked (Ref #'+ lockedIdRefMap[originalId] +').', false);
        return;
    }
    
    const idInput = row.querySelector('[data-field="id"]');
    const personnelId = (idInput?.value || '').trim(); 
    
    const originalId = (targetCell.dataset.originalId || '').trim(); 
    const dayKey = targetCell.dataset.dayKey;
    const shiftKey = targetCell.dataset.shiftKey;
    
    if (!personnelId || !PERSONNEL_ID_REGEX.test(personnelId)) { 
        showNotification('Cannot edit: Personnel ID is either empty or invalid (must be numbers only). Please correct the ID field first.', false);
        return;
    }

    const planKey = `${personnelId}_${dayKey}_${shiftKey}`;
    
    const currentStatus = pendingAttendanceChanges[planKey] !== undefined 
                          ? pendingAttendanceChanges[planKey] 
                          : currentContract.planMap[`${originalId}_${dayKey}_${shiftKey}`] || '';

    selectedCellData = {
      personnelId, 
      originalId,  
      dayKey,
      shiftKey,
      cellElement: targetCell
    };

    const modal = document.getElementById('floating-status-modal');
    const inputStartTime = document.getElementById('schedule-start-time');
    const inputEndTime = document.getElementById('schedule-end-time');
    
    const fixedOptionsContainer = document.getElementById('fixed-status-options-container');

    fixedOptionsContainer.innerHTML = '';
    
    fixedStatusOptions.forEach(option => {
        const button = document.createElement('button');
        button.type = 'button';
        button.textContent = option.label;
        button.value = option.value;
        button.className = `w-full px-4 py-2 text-sm rounded-lg border hover:shadow-md transition duration-150 ${option.color} ${option.value === currentStatus ? 'bg-opacity-70 border-2 border-blue-500' : 'bg-opacity-50 border-gray-300'}`;
        button.addEventListener('click', (e) => saveSchedule(e, option.value));
        fixedOptionsContainer.appendChild(button);
    });
    
    // 1. Clear and Populate Dropdowns
    inputStartTime.innerHTML = '<option value="">-- Start Time --</option>';
    inputEndTime.innerHTML = '<option value="">-- End Time --</option>';

    TIME_OPTIONS.forEach(time => {
        let optionStart = document.createElement('option');
        optionStart.value = time;
        optionStart.textContent = time;
        inputStartTime.appendChild(optionStart);
        
        let optionEnd = document.createElement('option');
        optionEnd.value = time;
        optionEnd.textContent = time;
        inputEndTime.appendChild(optionEnd);
    });


    // 2. Set Selected Values
    if (currentStatus && !fixedStatusCodes.includes(currentStatus)) {
        const parts = currentStatus.split('-');
        inputStartTime.value = parts[0] || '';
        inputEndTime.value = parts[1] || '';
    } else {
        inputStartTime.value = '';
        inputEndTime.value = '';
    }

    modal.classList.remove('hidden');
    inputStartTime.focus(); 
  }
  
  document.getElementById('cancel-status-btn').addEventListener('click', () => {
      document.getElementById('floating-status-modal').classList.add('hidden');
  });
  
  document.getElementById('save-schedule-btn').addEventListener('click', (event) => {
      saveSchedule(event, null); 
  });


  function saveSchedule(event, fixedStatusValue) {
    document.getElementById('floating-status-modal').classList.add('hidden');
    
    if (!selectedCellData.personnelId && !selectedCellData.originalId) return; 

    const { personnelId, originalId, dayKey, shiftKey, cellElement } = selectedCellData;
    
    if (lockedIdRefMap[originalId]) {
        showNotification('Cannot save: This employee\'s schedule has been printed and locked (Ref #'+ lockedIdRefMap[originalId] +').', false);
        return;
    }

    let finalStatus;
    
    if (event.type === 'click' && fixedStatusValue !== null) {
        finalStatus = fixedStatusValue;
    } else {
        const inputStartTime = document.getElementById('schedule-start-time').value.trim();
        const inputEndTime = document.getElementById('schedule-end-time').value.trim();

        if (inputStartTime && inputEndTime) {
            finalStatus = `${inputStartTime}-${inputEndTime}`;
        } else if (inputStartTime || inputEndTime) {
            showNotification('Please select both start and end times, or use the fixed status buttons.', false); 
            setTimeout(() => handleCellClick({ currentTarget: selectedCellData.cellElement }), 100); 
            return;
        } else {
            finalStatus = '';
        }
    }
    
    if (!personnelId) {
        showNotification('Cannot save plan: Personnel ID is missing for this row.', false);
        return;
    }

    if (!fixedStatusCodes.includes(finalStatus) && finalStatus.length > 0) {
        if (finalStatus.length !== 11 || finalStatus.charAt(5) !== '-') {
             showNotification('Invalid schedule format detected.', false);
             setTimeout(() => handleCellClick({ currentTarget: selectedCellData.cellElement }), 100); 
             return;
        }
        
        const [startTime, endTime] = finalStatus.split('-');
        const startTimeValue = parseInt(startTime.replace(':', ''), 10);
        const endTimeValue = parseInt(endTime.replace(':', ''), 10);
        
        if (endTimeValue < startTimeValue) {
             showNotification('FATAL ERROR: End Time cannot be earlier than Start Time. Please correct the schedule.', false);
             setTimeout(() => handleCellClick({ currentTarget: selectedCellData.cellElement }), 100); 
             return;
        }
    }

    const currentPlanKey = `${personnelId}_${dayKey}_${shiftKey}`;
    const originalPlanKey = `${originalId}_${dayKey}_${shiftKey}`;

    const originalStatus = currentContract.planMap[originalPlanKey] || '';

    if (originalStatus !== finalStatus) {
        pendingAttendanceChanges[currentPlanKey] = finalStatus; 
    } else {
        delete pendingAttendanceChanges[currentPlanKey];
    }
    
    updateCellVisuals(cellElement, finalStatus, dayKey);
    
    showNotification('Change saved locally. Click "Save All Changes" to save to Sheets.', true);
    
    checkPlanSheetLockState(); 
  }
  
  function handleSaveAllChanges() {
    const sfcRefToSave = currentContract ? currentContract.sfcRef : null;
    const currentYear = currentPlanningDate.getFullYear();
    const currentMonth = currentPlanningDate.getMonth();
    const currentShift = document.getElementById('shift-period-select').value;
    
    const groupInput = document.getElementById('group-number-input');
    // CRITICAL: Get the value directly from the readonly input, which was set by the server success handler.
    const groupNumber = groupInput ? groupInput.value.trim().toUpperCase() : ''; 
    
    // --- NEW VALIDATION: GROUP NUMBER ---
    if (!groupNumber || groupNumber === 'LOADING...') { 
        showNotification('FATAL ERROR: Group Number (GROUP) is still loading or invalid. Please wait or refresh.', false);
        groupInput?.classList.add('border-red-500');
        return;
    }
    groupInput?.classList.remove('border-red-500'); // Remove error visual
    // --- END NEW VALIDATION ---


    if (isBulkSelectionMode) {
        exitBulkSelectionMode();
        showNotification('Bulk Selection Mode was active. Please review the selection before saving.', false);
    }

    const empChanges = Object.keys(pendingEmployeeInfoChanges)
    .filter(stableKey => { 
        const change = pendingEmployeeInfoChanges[stableKey];
        const isNewAndEmpty = change.originalEmployeeId === '' && 
                              !change.isDeleted && 
                              !change.id.trim() && !change.name.trim() && 
                              !change.position.trim() && !change.area.trim();
                              
        return !isNewAndEmpty;
    }) 
    .map(stableKey => {
        const change = pendingEmployeeInfoChanges[stableKey];
        const isMasterEmployee = employeeMasterList.some(masterEmp => masterEmp.id === change.id.trim());
        const isExistingEmployeeAdded = change.originalEmployeeId === '' && isMasterEmployee; 
        
        return {
            oldPersonnelId: change.originalEmployeeId, 
            id: change.id.trim(), 
            name: change.name.trim(), 
            position: change.position.trim(), 
            area: change.area.trim(), 
            isNew: change.originalEmployeeId === '', 
            isDeleted: change.isDeleted || false, 
            isExistingEmployeeAdded: isExistingEmployeeAdded 
        };
    })
    
    const finalEmpChanges = [];
    empChanges.forEach(e => {
        if (e.isDeleted) {
            finalEmpChanges.push(e); 
        } else if (e.isExistingEmployeeAdded) {
             if (e.id !== '' && e.name !== '' && e.position !== '' && e.area !== '') {
                 finalEmpChanges.push(e);
             }
        }
        else if (e.isNew) {
            if (e.id !== '' && e.name !== '' && e.position !== '' && e.area !== '') {
                 finalEmpChanges.push(e);
            }
        }
    });
    
    
    // === CRITICAL 3: FINAL CHECK FOR EMPTY ID/NAME ON ACTIVE ROWS (FIX for User Issue) ===
    const allRows = document.querySelectorAll('#attendance-table-container tbody tr');
    
    const incompleteRow = Array.from(allRows).find(row => {
        const stableKey = row.dataset.stableKey;
        if (lockedIdRefMap[stableKey] && !pendingEmployeeInfoChanges[stableKey]?.isDeleted) return false;

        const idInput = row.querySelector('[data-field="id"]');
        const nameInput = row.querySelector('[data-field="name"]');
        const positionInput = row.querySelector('[data-field="position"]'); 
        const areaInput = row.querySelector('[data-field="area"]');         

        const displayId = (idInput?.value || '').trim();
        const displayName = (nameInput?.value || '').trim();
        const displayPosition = (positionInput?.value || '').trim();       
        const displayArea = (areaInput?.value || '').trim();               
        
        if (row.classList.contains('line-through')) return false; 
        
        if (displayId || displayName || displayPosition || displayArea) {
             return displayId === '' || 
                    displayName === '' || 
                    displayPosition === '' || 
                    displayArea === '';        
        }
        
        return false; 
    });

    if (incompleteRow) {
        const rowElement = incompleteRow;
        const rowNo = rowElement.querySelector('.sticky-col:first-child > span').textContent.trim();

        let idInput = incompleteRow.querySelector('[data-field="id"]');
        let nameInput = incompleteRow.querySelector('[data-field="name"]');
        let positionInput = incompleteRow.querySelector('[data-field="position"]');
        let areaInput = incompleteRow.querySelector('[data-field="area"]');
        
        const displayId = (idInput?.value || '').trim();
        const displayName = (nameInput?.value || '').trim();
        const displayPosition = (positionInput?.value || '').trim();
        const displayArea = (areaInput?.value || '').trim();
        
        let missingField = '';
        if (displayId === '') missingField = 'Personnel ID';
        else if (displayName === '') missingField = missingField = 'Personnel Name';
        else if (displayPosition === '') missingField = 'Position';
        else if (displayArea === '') missingField = 'Area Posting';
        
        const identifier = displayId || displayName ? 
                           `${displayId || displayName}` : 
                           `Row ${rowNo}`;
                           
        showNotification(`FATAL ERROR: Cannot save. ${identifier} is missing a required ${missingField}. All active employee rows must have all four info fields (ID, Name, Position, Area Posting).`, false);
        return; 
    }
    // === END FINAL CHECK FOR EMPTY ID/NAME ===


    // === CRITICAL 1: FINAL DUPLICATE NAME CHECK BEFORE SAVE ===
    if (finalEmpChanges.length > 0) { 
        
        const namesToCheck = {};
        let duplicateNameFound = false;
        
        employeeMasterList.forEach(emp => {
            const isPendingDelete = pendingEmployeeInfoChanges[emp.id]?.isDeleted;
            if (!isPendingDelete && !lockedIdRefMap[emp.id]) {
                const normalizedName = normalizeNameForComparison(emp.name);
                const isPendingUpdate = finalEmpChanges.some(change => change.oldPersonnelId === emp.id);
                if (!isPendingUpdate) {
                   namesToCheck[normalizedName] = emp.id;
                }
            }
        });

        for (const change of finalEmpChanges) {
            if (change.isDeleted) continue; 

            if (change.isExistingEmployeeAdded) {
                continue; 
            }

            const normalizedNameKey = normalizeNameForComparison(change.name);
            const existingId = namesToCheck[normalizedNameKey];

            if (existingId && existingId !== change.oldPersonnelId) {
                duplicateNameFound = true;
                break;
            }

            namesToCheck[normalizedNameKey] = change.id || change.oldPersonnelId;
        }

        if (duplicateNameFound) {
            showNotification('FATAL ERROR: Cannot save. Duplicate Personnel Name detected. Please edit the name to be unique (e.g., add initials/middle name) before saving.', false);
            return; 
        }
    }
    // === END FINAL DUPLICATE NAME CHECK ===
    
    // === CRITICAL 2: CHECK FOR BLANK ATTENDANCE COLUMNS (STRICT ALL-OR-NOTHING CHECK) ===
    
    const rowsToValidate = [];
    
    document.querySelectorAll('#attendance-table-container tbody tr').forEach(row => {
        const stableKey = row.dataset.stableKey;
        
        if (lockedIdRefMap[stableKey] || row.classList.contains('line-through') || row.classList.contains('print-empty-row')) return;
        
        const employeeId = row.querySelector('[data-field="id"]')?.value; 
        const displayName = row.querySelector('[data-field="name"]')?.value.trim();
        
        if (!employeeId) return; 

        let isCurrentPlanIncomplete = false;
        const planCells = [];
        
        row.querySelectorAll('.cell-container').forEach(cell => {
            const status = cell.querySelector('.attendance-cell-bg').textContent.trim();
            planCells.push({ status });

            if (status === '') { 
                 isCurrentPlanIncomplete = true;
            }
        });
        
        if (isCurrentPlanIncomplete) {
             rowsToValidate.push({ id: employeeId, name: displayName, planCells, stableKey });
        }
    });

    let incompleteColumnFound = false;
    let employeeNameIncomplete = '';

    for (const employee of rowsToValidate) {
        for (const cell of employee.planCells) {
            if (cell.status === '') {
                incompleteColumnFound = true;
                employeeNameIncomplete = employee.name;
                break;
            }
        }
        if (incompleteColumnFound) break;
    }

    if (incompleteColumnFound) {
        showNotification(`FATAL ERROR: Cannot save. Attendance Plan incomplete for employee: ${employeeNameIncomplete}. All days in the current shift/period must have a status (Work, RD, RH, SH, or NA).`, false);
        return; 
    }
    // === END CRITICAL 2 CHECK ===


    const attChanges = Object.keys(pendingAttendanceChanges).map(key => {
        const [personnelId, dayKey, shift] = key.split('_');
        return { personnelId, dayKey, shift, status: pendingAttendanceChanges[key] };
    });

    if (finalEmpChanges.length === 0 && attChanges.length === 0) {
        showNotification('No changes detected to save.', false);
        return;
    }
    
    const finalEmpChangesAfterValidation = [];
    finalEmpChanges.forEach(e => {
        if (e.isDeleted) {
            finalEmpChangesAfterValidation.push(e); 
        } else if (e.isExistingEmployeeAdded) {
             if (e.id !== '' && e.name !== '' && e.position !== '' && e.area !== '') {
                 finalEmpChangesAfterValidation.push(e);
             }
        }
        else if (e.isNew) {
            if (e.id !== '' && e.name !== '' && e.position !== '' && e.area !== '') {
                 finalEmpChangesAfterValidation.push(e);
            }
        }
    });
    
    if (finalEmpChangesAfterValidation.some(e => !e.isDeleted && !PERSONNEL_ID_REGEX.test(e.id))) { 
        showNotification('Personnel ID error detected (must be numbers only). Please check your inputs.', false);
        return;
    }
    
    if (!sfcRefToSave) {
        showNotification('CRITICAL ERROR: Contract data is not loaded. Please select a Contract Group ID and retry.', false);
        return;
    }
    
    // 2. I-prepare ang Contract Info (UPDATED WITH NEW METADATA)
    const contractInfo = {
        payor: currentContract.payorCompany,
        agency: currentContract.agency,
        serviceType: currentContract.serviceType,
        headCount: currentContract.headCount,
        // NEW METADATA FIELDS
        propOrGrpCode: currentContract.propOrGrpCode, 
        sector: currentContract.sector
    };

    toggleLoading(true);
    
    google.script.run
        .withSuccessHandler(handleSaveAllSuccess)
        .withFailureHandler(handleSaveAllError)
        // PASS CONTRACT INFO AND GROUP NUMBER
        .saveAllData(sfcRefToSave, contractInfo, finalEmpChangesAfterValidation, attChanges, currentYear, currentMonth, currentShift, groupNumber); 
}

  function handleSaveAllSuccess(response) {
      showNotification('All changes saved successfully! Refreshing data...', true);
      pendingAttendanceChanges = {}; 
      pendingEmployeeInfoChanges = {}; 
      
      if (currentContract && currentContract.sfcRef) {
          fetchEmployeeMasterData(currentContract.sfcRef);
      }
      
      reloadPlanAndCheckExistence(); 
  }

  function handleSaveAllError(error) {
       console.error("SAVE ALL ERROR:", error);
       showNotification(`FATAL SAVE ERROR: ${error.message || 'An unknown error occurred in the script.'}`, false);
       toggleLoading(false); 
  }
  
  // --- NEW FUNCTION: DYNAMIC ROW FILTERING ---
  function filterEmptyScheduleRows() {
    const rowsToHide = [];
    const gridRows = document.querySelectorAll('#attendance-table-container tbody tr');

    gridRows.forEach(row => {
        const isMarkedForDeletion = row.classList.contains('line-through');
        const isAlreadyBlank = row.classList.contains('print-empty-row');
        
        if (isMarkedForDeletion || isAlreadyBlank) return; 

        const idInput = row.querySelector('[data-field="id"]');
        const nameInput = row.querySelector('[data-field="name"]');
        const displayId = (idInput?.value || '').trim();
        const displayName = (nameInput?.value || '').trim();
        
        if (!displayId && !displayName) return; 

        let hasValidSchedule = false; 
        row.querySelectorAll('.cell-container').forEach(cell => {
            const status = cell.querySelector('.attendance-cell-bg').textContent.trim();
            if (status !== '' && status !== 'NA' && status !== 'DELETED') { 
                hasValidSchedule = true;
            }
        });
        
        const stableKey = row.dataset.stableKey;
        const isLocked = !!lockedIdRefMap[stableKey];
        
        if (!hasValidSchedule && !isLocked) {
             row.classList.add('print-hidden'); 
             rowsToHide.push(row);
        }
    });
    return rowsToHide;
  }
  
  // --- NEW FUNCTION: Sequential Numbering and Hiding ---

  function applySequentialPrintNumberingAndHiding(dynamicallyHiddenRows) {
    let printNumber = 1;
    const gridRows = document.querySelectorAll('#attendance-table-container tbody tr');

    gridRows.forEach(row => {
        
        // A. Rows marked for Deletion or already blank placeholders
        if (row.classList.contains('line-through') || row.classList.contains('print-empty-row')) {
            row.classList.add('print-hidden');
            return;
        }

        const idInput = row.querySelector('[data-field="id"]');
        const displayId = (idInput?.value || '').trim();

        if (!displayId) { 
             row.classList.add('print-hidden');
             return;
        }
        
        // B. Exclude rows that are already Locked 
        const stableKey = row.dataset.stableKey;
        const isLocked = !!lockedIdRefMap[stableKey];
        
        if (isLocked) {
            row.classList.add('print-hidden');
            dynamicallyHiddenRows.push(row);
            return;
        }
        
        // C. Check for NA/Blank Exclusion 
        let hasActualSchedule = false;

        row.querySelectorAll('.cell-container').forEach(cell => {
            const status = cell.querySelector('.attendance-cell-bg').textContent.trim();
            
            if (status !== '' && status !== 'NA' && status !== 'DELETED') { 
                hasActualSchedule = true;
            }
        });

        if (!hasActualSchedule) { 
            row.classList.add('print-hidden');
            dynamicallyHiddenRows.push(row); 
            return;
        }

        // --- 2. Apply sequential numbering to rows NOT excluded ---
        const noCellSpan = row.querySelector('.sticky-col:first-child > span:first-child');
        
        if (noCellSpan && !row.classList.contains('print-hidden')) {
            noCellSpan.textContent = printNumber;
            printNumber++;
        }
    });
    
    return dynamicallyHiddenRows; 
  }
  
  // --- NEW FUNCTION: Signatory Input Handler (Validation/CAPS) ---
  function handleSignatoryInputChange(event, fieldType, index = null) {
      const input = event.target;
      let newValue = input.value.toUpperCase(); 

      let cleanedValue = newValue.replace(SAFE_NAME_REGEX, '');
      input.value = cleanedValue; 

      if (fieldType === 'checkedBy' && index !== null) {
          selectedSignatories.checkedBy[index] = cleanedValue;
      } else {
          selectedSignatories[fieldType] = cleanedValue;
      }

      if (newValue !== cleanedValue) {
          showNotification(`Only letters, spaces, commas, periods, and dashes are allowed in names. Invalid characters removed.`, false);
      }
  }
  // --- END NEW FUNCTION ---
  
  // --- NEW FUNCTION: Validation check for all signatories ---
  function validateAllSignatories() {
      
      const approvedBy = selectedSignatories.approvedBy.trim();
      if (!approvedBy || !approvedBy.match(SIGNATORY_REGEX)) {
          return "Approved By name is required and must contain only letters, spaces, commas, periods, or dashes.";
      }
      
      const checkedByList = selectedSignatories.checkedBy.filter(name => name.trim() !== '');
      if (checkedByList.length === 0) {
          return "At least one name for 'Checked By' is required.";
      }
      
      for (const name of checkedByList) {
          if (!name.match(SIGNATORY_REGEX)) {
              return `Checked By name "${name}" has invalid characters. Only letters, spaces, commas, periods, or dashes are allowed.`;
          }
      }

      return null; 
  }


  // --- NEW PRINT LOGIC (UPDATED FLOW) ---
  
function openPrintSetupModal() {
    const empChangesCount = Object.keys(pendingEmployeeInfoChanges).length;
    const attChangesCount = Object.keys(pendingAttendanceChanges).length;
    
    if (empChangesCount > 0 || attChangesCount > 0) {
        showNotification(`Saving required: ${empChangesCount} employee changes and ${attChangesCount} schedule changes are pending. Click "Save All Changes to Sheets" first.`, false);
        return;
    }
    
    // NEW VALIDATION: Check for Group Number again (Read from input)
    const groupInput = document.getElementById('group-number-input');
    const groupNumber = groupInput ? groupInput.value.trim().toUpperCase() : '';
    
    if (!groupNumber || groupNumber === 'LOADING...') {
        showNotification('Group Number (GROUP) is required before printing.', false);
        groupInput?.classList.add('border-red-500');
        return;
    }
    groupInput?.classList.remove('border-red-500'); // Remove error visual

    document.getElementById('signatory-prepared-by').value = selectedSignatories.preparedBy;
    document.getElementById('signatory-approved-by').value = selectedSignatories.approvedBy;
    
    for(let i = 0; i < 5; i++) {
        const input = document.getElementById(`signatory-checked-by-${i}`);
        if(input) input.value = selectedSignatories.checkedBy[i];
    }
    
    document.getElementById('print-setup-modal').classList.remove('hidden'); 
    document.getElementById('sub-property-input').focus();
}

function hidePrintSetupModal() {
    document.getElementById('print-setup-modal').classList.add('hidden');
}


function handlePrintSetupConfirm(event) {
    const subProperty = document.getElementById('sub-property-input').value.trim();
    if (!subProperty) {
        showNotification('Sub Property is required before printing.', false);
        return;
    }
    
    const signatoryError = validateAllSignatories();
    if (signatoryError) {
        showNotification(`Signatory Error: ${signatoryError}`, false);
        return;
    }
    
    hidePrintSetupModal();
    triggerPrintPreparation(subProperty);
}

function handlePrintPlan() {
    if (!currentContract) {
        showNotification('Please select a Contract Group ID first.', false);
        return;
    }
    if (isPlanSheetFullyLocked) {
        showNotification('Cannot print: All employees with a schedule are already locked for this period. Add a new employee with a schedule or request admin unlock.', false);
        return;
    }
    
    openPrintSetupModal();
}

function triggerPrint(refNum, subProperty, signatories, dynamicallyHiddenRows = [], sfcRef, contractInfo, year, month, shift, printedPersonnelIds) {
    showNotification(`Print Reference #${refNum} generated. Printing now...`, true);

    let printRefElement = document.getElementById('print-ref-display');
    if (!printRefElement) {
        printRefElement = document.createElement('div');
        printRefElement.id = 'print-ref-display';
        printRefElement.className = 'print-only-container print-hidden'; 
        document.body.appendChild(printRefElement);
    }
    printRefElement.textContent = refNum; 
    
    const checkedByNames = signatories.checkedBy.map(name => name.trim()).filter(name => name);

    const checkedByHtml = checkedByNames.map(name => {
        return `<p class="text-base font-bold text-black line-break">${name}</p>`;
    }).join('');


    // --- 2a. Sub Property Container ---
    const subPropertyHtml = `
        <div id="print-sub-property-container" class="print-only-container">
            <p class="text-sm font-medium text-black font-bold">Sub Property</p>
            <p id="sub-property-display" class="text-base font-bold text-black">${subProperty}</p>
        </div>
    `;

    // --- 2b. Signatories Container ---
    const signatoriesOnlyHtml = `
        <div id="print-signatories-container" class="print-only-container">
            <div class="grid grid-cols-3 gap-x-4 gap-y-2 text-center print-signatories">
                <div class="prepared-by">
                    <p class="text-sm font-bold text-black mb-1">${signatories.preparedBy.trim()}</p>
                    <p class="text-xs font-bold text-black pt-1">Prepared By</p>
                </div>

                <div class="checked-by col-span-1">
                    ${checkedByHtml}
                    <p class="text-xs font-bold text-black pt-1">Checked By</p>
                </div>

                <div class="approved-by">
                    <p class="text-sm font-bold text-black mb-1">${signatories.approvedBy.trim()}</p>
                    <p class="text-xs font-bold text-black pt-1">Approved By</p>
                </div>
            </div>
        </div>
    `;
    
    // 3. Perform Injection
    const contractDetailsGrid = document.getElementById('contract-details-grid');
    if (contractDetailsGrid) {
        contractDetailsGrid.insertAdjacentHTML('afterend', subPropertyHtml);
    } 

    document.body.insertAdjacentHTML('beforeend', signatoriesOnlyHtml);
    

    // ********** 3. SETUP PRINT CONFIRMATION MODAL **********
    const setupModalAndPrint = () => {
        const modal = document.getElementById('print-confirm-modal');
        const message = document.getElementById('print-confirm-message');
        const okBtn = document.getElementById('confirm-print-ok-btn');
        const cancelBtn = document.getElementById('confirm-print-cancel-btn');
        
        message.innerHTML = `We need to verify if the document was successfully printed. Did you proceed with printing the document (Reference #: <span class="font-bold text-blue-600">${refNum}</span>)?`;
        
        const restoreUI = () => {
            modal.classList.add('hidden');
            
            document.querySelectorAll('.print-hidden').forEach(row => {
                if (dynamicallyHiddenRows.includes(row) || row.classList.contains('print-empty-row')) {
                    row.classList.remove('print-hidden');
                }
            });

            reloadPlanAndCheckExistence(); 
            
            if (printRefElement) {
                 printRefElement.remove();
            }
            const injectedSubProperty = document.getElementById('print-sub-property-container');
            if (injectedSubProperty) {
                 injectedSubProperty.remove();
            }
            const injectedSignatories = document.getElementById('print-signatories-container');
            if (injectedSignatories) {
                 injectedSignatories.remove();
            }

            const inputs = document.querySelectorAll('#attendance-table-container input');
            inputs.forEach(input => {
                input.classList.remove('print-read-only');
            });
            window.onafterprint = null; 
            okBtn.removeEventListener('click', handleOk);
            cancelBtn.removeEventListener('click', handleCancel);
        };

        const handleOk = () => {
            
            google.script.run
                .withSuccessHandler(() => {
                    console.log(`Successfully recorded print log entry #${refNum} and locked IDs.`);
                    showNotification(`Print action (Ref# ${refNum}) successfully logged and locked. Refreshing...`, true);
                    restoreUI();
                })
                .withFailureHandler((error) => {
                    console.error(`Failed to record print log entry #${refNum}:`, error);
                    showNotification(`Warning: Failed to record print log/lock (Ref# ${refNum}). Error: ${error.message}`, false);
                    restoreUI();
                })
                .recordPrintLogEntry(refNum, subProperty, signatories, currentContract.sfcRef, contractInfo, year, month, shift, printedPersonnelIds);
        };

        const handleCancel = () => {
            restoreUI();
            showNotification(`Print log (Ref# ${refNum}) discarded by user.`, false);
        };
        
        okBtn.addEventListener('click', handleOk);
        cancelBtn.addEventListener('click', handleCancel);

        window.onafterprint = function() {
            modal.classList.remove('hidden');
        };
    };
    
    const rowsToRestore = applySequentialPrintNumberingAndHiding(dynamicallyHiddenRows); 

    document.querySelectorAll('.print-empty-row').forEach(row => row.classList.add('print-hidden'));
    
    const inputs = document.querySelectorAll('#attendance-table-container input');
    inputs.forEach(input => {
        input.classList.add('print-read-only');
    });

    setupModalAndPrint();

    window.print();
}

function triggerPrintPreparation(subProperty) {
    if (!currentContract) {
        showNotification('Please select a Contract Group ID first.', false);
        return;
    }
    
    const activeRows = document.querySelectorAll('#attendance-table-container tbody tr');
    const printedPersonnelIds = [];
    let isPlanPrintable = false;

    activeRows.forEach(row => {
        if (row.classList.contains('line-through') || row.classList.contains('print-empty-row')) return;
        
        const idInput = row.querySelector('[data-field="id"]');
        const id = (idInput?.value || '').trim();
        const stableKey = row.dataset.stableKey;
        
        const isLocked = !!lockedIdRefMap[stableKey];
        
        let hasActualSchedule = false;
        row.querySelectorAll('.cell-container').forEach(cell => {
             const status = cell.querySelector('.attendance-cell-bg').textContent.trim();
             if (status !== '' && status !== 'NA' && status !== 'DELETED' && status !== 'LOCKED') {
                 hasActualSchedule = true;
             }
        });

        if (id && PERSONNEL_ID_REGEX.test(id) && hasActualSchedule && !isLocked) {
            printedPersonnelIds.push(id);
            isPlanPrintable = true;
        }
    });
    
    if (printedPersonnelIds.length === 0 && currentContract.employees.length > 0) {
         showNotification('Cannot print: No employee data with an **actual schedule** found that is not already locked. Please add a plan (Work/RD/RH/SH) before printing.', false);
         return;
    } else if (printedPersonnelIds.length === 0 && currentContract.employees.length === 0) {
        showNotification('Cannot print: No employee data available for printing.', false);
        return;
    }


    const dynamicallyHiddenRows = filterEmptyScheduleRows(); 

    const currentYear = currentPlanningDate.getFullYear();
    const currentMonth = currentPlanningDate.getMonth();
    const currentShift = document.getElementById('shift-period-select').value;
    
    const contractInfo = {
        payor: currentContract.payorCompany,
        agency: currentContract.agency,
        serviceType: currentContract.serviceType,
        headCount: currentContract.headCount
    };

    toggleLoading(true);

    google.script.run
        .withSuccessHandler((refNum) => {
            toggleLoading(false);
            triggerPrint(refNum, subProperty, selectedSignatories, dynamicallyHiddenRows, currentContract.sfcRef, contractInfo, currentYear, currentMonth, currentShift, printedPersonnelIds); 
        })
        .withFailureHandler((error) => {
            dynamicallyHiddenRows.forEach(row => row.classList.remove('print-hidden'));
            handleError(error);
        })
        .logPrintAction(subProperty, currentContract.sfcRef, contractInfo, currentYear, currentMonth, currentShift); 
}


// --- NEW HELPER: Get Cell Coordinates (Absolute row index, 0-based column index) ---
function getCellCoordinates(cell) {
    if (!cell || !cell.classList.contains('cell-container')) return null;
    
    const row = cell.parentNode;
    const rowIndex = row.rowIndex; 
    
    // Schedule columns start at index 5 (the 6th child)
    const colIndex = cell.cellIndex; 
    
    return { R: rowIndex, C: colIndex };
}
// --- END NEW HELPER ---

// --- NEW HELPER: Check if a Row is Active (Non-blank) ---
function isRowActive(rowElement) {
    const idInput = rowElement.querySelector('[data-field="id"]');
    const nameInput = rowElement.querySelector('[data-field="name"]');
    
    return (idInput?.value || '').trim() !== '' || (nameInput?.value || '').trim() !== '';
}
// --- END NEW HELPER ---


// --- NEW FUNCTION: CRITICAL DRAG LOGIC (Additive) ---
function visualizeAdditiveRange(startCell, endCell) {
    const startCoords = getCellCoordinates(startCell);
    const endCoords = getCellCoordinates(endCell);

    if (!startCoords || !endCoords) return;

    const table = startCell.closest('table');
    if (!table) return;

    const R_min = Math.min(startCoords.R, endCoords.R);
    const R_max = Math.max(startCoords.R, endCoords.R);
    const C_min_target = Math.min(startCoords.C, endCoords.C);
    const C_max_target = Math.max(startCoords.C, endCoords.C);
    
    // UPDATED: Schedule columns start at index 5
    const DATE_COL_START_INDEX = 5; 
    
    const C_min = Math.max(DATE_COL_START_INDEX, C_min_target);
    const C_max = Math.max(DATE_COL_START_INDEX, C_max_target);

    const allCells = Array.from(table.querySelectorAll('td.cell-container'));

    cellsFromCurrentDrag.forEach(cell => {
        if (!bulkSelectedCells.includes(cell)) {
             cell.classList.remove('cell-selected');
        }
    });
    cellsFromCurrentDrag = []; 

    allCells.forEach(cell => {
        const coords = getCellCoordinates(cell);
        if (!coords) return; 

        const cellRow = cell.closest('tr');
        if (!isRowActive(cellRow)) {
            return; 
        }

        const isInRange = coords.R >= R_min && coords.R <= R_max && 
                          coords.C >= C_min && coords.C <= C_max;
        
        const isLocked = cellRow.classList.contains('line-through') || cellRow.classList.contains('locked-row');

        if (isInRange && !isLocked) {
             cell.classList.add('cell-selected'); 
             
             cellsFromCurrentDrag.push(cell);
        }
    });
    
    const uniqueSelectedCount = new Set([...bulkSelectedCells, ...cellsFromCurrentDrag]).size;
    document.getElementById('bulk-cell-count').textContent = uniqueSelectedCount;
}


// --- NEW FUNCTION: Handle Drag Start ---
function handleDragStart(event) {
    if (!isBulkSelectionMode || event.button !== 0) return; 

    const targetCell = event.target.closest('.cell-container');
    if (!targetCell) return;
    
    const row = targetCell.closest('tr');
    
    if (!isRowActive(row)) {
        showNotification('Cannot drag: Start row must contain active employee details.', false);
        return; 
    }
    const isCellLocked = row.classList.contains('line-through') || row.classList.contains('locked-row');
    if (isCellLocked) {
        return; 
    }
    
    event.preventDefault(); 

    isDragging = true;
    dragStartCell = targetCell;
    dragEndCell = targetCell;
    
    document.addEventListener('mousemove', handleDragging);
    document.addEventListener('mouseup', handleDragEnd); 
}

// --- NEW FUNCTION: Handle Dragging (Hakbang 2) ---
function handleDragging(event) {
    if (!isDragging) return;
    
    const currentCell = event.target.closest('.cell-container');
    
    if (!currentCell || currentCell.closest('tr').classList.contains('line-through') || currentCell.closest('tr').classList.contains('locked-row')) {
        return;
    }
    
    if (currentCell !== dragEndCell) {
        dragEndCell = currentCell;
        visualizeAdditiveRange(dragStartCell, dragEndCell); 
    }
}

// --- NEW FUNCTION: Handle Drag End (Hakbang 3) ---
function handleDragEnd(event) {
    if (!isDragging) return;
    
    if (dragStartCell === dragEndCell) {
        toggleCellSelection(dragStartCell); 
    } 
    
    if (dragStartCell !== dragEndCell) {
        cellsFromCurrentDrag.forEach(cell => {
             if (!bulkSelectedCells.includes(cell)) {
                 bulkSelectedCells.push(cell);
             }
        });
    }
    
    cellsFromCurrentDrag = []; 
    
    isDragging = false;
    dragStartCell = null;
    dragEndCell = null;
    
    document.removeEventListener('mousemove', handleDragging);
    document.removeEventListener('mouseup', handleDragEnd);
}

// Function to start the bulk selection process
function startBulkSelectionMode() {
    if (isBulkSelectionMode) return; 

    isBulkSelectionMode = true;
    bulkSelectedCells = []; 

    document.querySelectorAll('.cell-container').forEach(cell => {
        cell.removeEventListener('click', handleCellClick);
        
        const row = cell.closest('tr');
        const isCellLocked = row.classList.contains('line-through') || row.classList.contains('locked-row');
        
        if (!isCellLocked) {
           cell.removeEventListener('click', handleCellSelectionClick); 
           cell.classList.add('cursor-crosshair'); 
        }
        cell.classList.remove('cell-selected'); 
    });
    
    const gridContainer = document.getElementById('attendance-grid');
    if (gridContainer) {
        gridContainer.addEventListener('mousedown', handleDragStart, false); 
    }
    
    const bulkBtn = document.getElementById('start-bulk-select-btn');
    bulkBtn.textContent = 'Apply Selection';
    bulkBtn.classList.remove('bg-yellow-600', 'hover:bg-yellow-700');
    bulkBtn.classList.add('bg-blue-600', 'hover:bg-blue-700');
    bulkBtn.removeEventListener('click', startBulkSelectionMode); 
    bulkBtn.addEventListener('click', openBulkScheduleModal); 

    showNotification('Bulk Selection Mode: Click cells to toggle selection, or Drag to select a range.', true);
}


// Function to return to normal mode (called after save or cancel)
function exitBulkSelectionMode() {
    isBulkSelectionMode = false;
    
    document.querySelectorAll('.cell-container').forEach(cell => {
        cell.removeEventListener('click', handleCellSelectionClick);
        
        const row = cell.closest('tr');
        const isCellLocked = row.classList.contains('line-through') || row.classList.contains('locked-row');
        if (!isCellLocked) {
           cell.addEventListener('click', handleCellClick); 
        }
        cell.classList.remove('cell-selected', 'cursor-crosshair');
    });
    
    bulkSelectedCells = [];
    cellsFromCurrentDrag = []; 
    document.getElementById('bulk-cell-count').textContent = '0';
    
    const gridContainer = document.getElementById('attendance-grid');
    if (gridContainer) {
        gridContainer.removeEventListener('mousedown', handleDragStart, false); 
    }
    document.removeEventListener('mousemove', handleDragging);
    document.removeEventListener('mouseup', handleDragEnd); 
    
    const bulkBtn = document.getElementById('start-bulk-select-btn');
    bulkBtn.textContent = 'Start Bulk Select';
    bulkBtn.classList.remove('bg-blue-600', 'hover:bg-blue-700');
    bulkBtn.classList.add('bg-yellow-600', 'hover:bg-yellow-700');
    bulkBtn.removeEventListener('click', openBulkScheduleModal); 
    bulkBtn.addEventListener('click', startBulkSelectionMode); 

    document.getElementById('floating-bulk-modal').classList.add('hidden');

    showNotification('Bulk Selection Mode ended.', false);
}


function toggleCellSelection(cell) {
    const index = bulkSelectedCells.indexOf(cell);
    if (index > -1) {
        bulkSelectedCells.splice(index, 1);
        cell.classList.remove('cell-selected');
    } else {
        bulkSelectedCells.push(cell);
        cell.classList.add('cell-selected');
    }
    document.getElementById('bulk-cell-count').textContent = bulkSelectedCells.length;
}


function handleCellSelectionClick(event) {
    const targetCell = event.currentTarget || event; 
    const row = targetCell.closest('tr');
    
    if (!isRowActive(row)) {
        showNotification('Cannot select: This row does not contain active employee details.', false);
        return;
    }
    const isCellLocked = row.classList.contains('line-through') || row.classList.contains('locked-row');
    if (isCellLocked) {
        const originalId = targetCell.dataset.originalId || '';
        showNotification('Cannot select: Row is marked for deletion or is locked (Ref #'+ lockedIdRefMap[originalId] +').', false);
        return;
    }
    
    const idInput = row.querySelector('[data-field="id"]');
    const personnelId = (idInput?.value || '').trim();
    
    if (!personnelId || !PERSONNEL_ID_REGEX.test(personnelId)) { 
        showNotification('Cannot select: Personnel ID is empty or invalid (must be numbers only). Please correct the ID field first.', false);
        return;
    }
    
    toggleCellSelection(targetCell);
}

// Function to open the Bulk Modal
function openBulkScheduleModal() {
    if (bulkSelectedCells.length === 0) {
        showNotification('Please select at least one cell first.', false);
        return;
    }
    
    const modal = document.getElementById('floating-bulk-modal');
    const inputStartTime = document.getElementById('bulk-start-time');
    const inputEndTime = document.getElementById('bulk-end-time');
    const fixedOptionsContainer = document.getElementById('bulk-fixed-status-options-container');

    fixedOptionsContainer.innerHTML = '';
    fixedStatusOptions.forEach(option => {
        const button = document.createElement('button');
        button.type = 'button';
        button.textContent = option.label;
        button.value = option.value;
        button.className = `w-full px-4 py-2 text-sm rounded-lg border hover:shadow-md transition duration-150 ${option.color} bg-opacity-50 border-gray-300`;
        button.addEventListener('click', (e) => saveBulkSchedule(e, option.value)); 
        fixedOptionsContainer.appendChild(button);
    });
    
    inputStartTime.innerHTML = '<option value="">-- Start Time --</option>';
    inputEndTime.innerHTML = '<option value="">-- End Time --</option>';

    TIME_OPTIONS.forEach(time => {
        let optionStart = document.createElement('option');
        optionStart.value = time;
        optionStart.textContent = time;
        inputStartTime.appendChild(optionStart);
        
        let optionEnd = document.createElement('option');
        optionEnd.value = time;
        optionEnd.textContent = time;
        inputEndTime.appendChild(optionEnd);
    });
    
    inputStartTime.value = '';
    inputEndTime.value = '';

    document.getElementById('bulk-cell-count').textContent = bulkSelectedCells.length;
    modal.classList.remove('hidden');
    document.getElementById('bulk-save-btn').disabled = bulkSelectedCells.length === 0;
}

// Function to save the schedule to all selected cells
function saveBulkSchedule(event, fixedStatusValue) {
    document.getElementById('floating-bulk-modal').classList.add('hidden');
    
    let finalStatus = '';
    
    if (event.type === 'click' && fixedStatusValue !== null) {
        finalStatus = fixedStatusValue;
    } else {
        const inputStartTime = document.getElementById('bulk-start-time').value.trim();
        const inputEndTime = document.getElementById('bulk-end-time').value.trim();

        if (inputStartTime && inputEndTime) {
            finalStatus = `${inputStartTime}-${inputEndTime}`;
        } else if (inputStartTime || inputEndTime) {
             showNotification('Please select both start and end times, or use the fixed status buttons.', false); 
             setTimeout(openBulkScheduleModal, 100); 
             return;
        } else {
            finalStatus = '';
        }
    }
    
    if (!fixedStatusCodes.includes(finalStatus) && finalStatus.length > 0) {
        if (finalStatus.length !== 11 || finalStatus.charAt(5) !== '-') {
             showNotification('Invalid schedule format detected.', false);
             setTimeout(openBulkScheduleModal, 100); 
             return;
        }
        
        const [startTime, endTime] = finalStatus.split('-');
        const startTimeValue = parseInt(startTime.replace(':', ''), 10);
        const endTimeValue = parseInt(endTime.replace(':', ''), 10);
        
        if (endTimeValue < startTimeValue) {
             showNotification('FATAL ERROR: End Time cannot be earlier than Start Time. Please correct the schedule.', false);
             setTimeout(openBulkScheduleModal, 100); 
             return;
        }
    }
    
    let changesAppliedCount = 0;

    bulkSelectedCells.forEach(cellElement => {
        const row = cellElement.closest('tr');
        const idInput = row.querySelector('[data-field="id"]');
        const personnelId = (idInput?.value || '').trim();
        
        const originalId = cellElement.dataset.originalId; 
        const dayKey = cellElement.dataset.dayKey;
        const shiftKey = cellElement.dataset.shiftKey;
        
        if (lockedIdRefMap[originalId]) return;
        
        if (!personnelId || !PERSONNEL_ID_REGEX.test(personnelId)) return; 

        const currentPlanKey = `${personnelId}_${dayKey}_${shiftKey}`;
        const originalPlanKey = `${originalId}_${dayKey}_${shiftKey}`;

        const originalStatus = currentContract.planMap[originalPlanKey] || '';
        
        if (originalStatus !== finalStatus) {
            pendingAttendanceChanges[currentPlanKey] = finalStatus; 
        } else {
            delete pendingAttendanceChanges[currentPlanKey];
        }
        
        updateCellVisuals(cellElement, finalStatus, dayKey);
        changesAppliedCount++;
    });
    
    exitBulkSelectionMode();
    showNotification(`Bulk schedule applied to ${changesAppliedCount} cells. Click "Save All Changes" to save to Sheets.`, true);
    
    checkPlanSheetLockState(); 
}

// --- NEW HELPER: Get Row Schedule Status ---
function getRowScheduleStatus(row, currentShift) {
    let hasActualSchedule = false;
    
    // UPDATED LOGIC: Loop through column index (1-16)
    const startColIndex = 1;
    const endColIndex = 16;
    const year = currentPlanningDate.getFullYear();
    const month = currentPlanningDate.getMonth();
    const startDayOfMonth = currentShift === '1stHalf' ? 1 : 16;
    const daysInMonth = getDaysInMonth(year, month);
    

    const idInput = row.querySelector('[data-field="id"]');
    const personnelId = (idInput?.value || '').trim();
    const originalId = row.dataset.stableKey.startsWith('TEMP_') ? '' : row.dataset.stableKey;

    if (!personnelId) return { id: null, isPrintable: false };

    // Find the cell elements in the row
    const cellElements = row.querySelectorAll('.cell-container');
    
    for(let colIndex = startColIndex; colIndex <= endColIndex; colIndex++) {
        const d = startDayOfMonth + colIndex - 1; 
        if (d > daysInMonth) continue; 
        
        // **NEW FIX: Stop 1st Half at 15**
        if (currentShift === '1stHalf' && d > 15) continue; // <--- ADDED LINE

        const dayKey = `${year}-${month + 1}-${d}`;
        const originalKey = `${originalId}_${dayKey}_${currentShift}`;
        
        // Find the cell that corresponds to this column index (index 0 maps to colIndex 1)
        const cell = cellElements[colIndex - 1]; 
        if (!cell) continue;

        let status = pendingAttendanceChanges[`${personnelId}_${dayKey}_${currentShift}`];
        
        if (status === undefined) {
             status = currentContract.planMap[originalKey] || '';
        }
        
        status = status.toString().trim();

        if (status && status !== 'NA' && status !== 'DELETED' && status !== 'LOCKED') {
            hasActualSchedule = true;
            break;
        }
    }

    return { id: personnelId, isPrintable: hasActualSchedule };
}

// --- NEW FUNCTION: Check Plan Sheet Global Lock State (Disables Print Button) ---
function checkPlanSheetLockState() {
    if (!currentContract) {
        isPlanSheetFullyLocked = false;
        updatePrintButtonState();
        return;
    }
    
    if (currentContract.employees.length === 0 && Object.keys(pendingEmployeeInfoChanges).length === 0) {
        isPlanSheetFullyLocked = false;
        updatePrintButtonState();
        return;
    }

    const gridRows = document.querySelectorAll('#attendance-table-container tbody tr');
    const currentShift = document.getElementById('shift-period-select').value;
    
    let totalPrintableAndUnlocked = 0;

    gridRows.forEach(row => {
        if (row.classList.contains('line-through') || row.classList.contains('print-empty-row')) return;
        
        const { id: personnelId, isPrintable } = getRowScheduleStatus(row, currentShift);
        
        if (isPrintable) {
            if (!lockedIdRefMap[personnelId]) {
                totalPrintableAndUnlocked++;
            }
        }
    });

    isPlanSheetFullyLocked = (totalPrintableAndUnlocked === 0);
    updatePrintButtonState();
}

// --- NEW FUNCTION: Update Print Button Visuals ---
function updatePrintButtonState() {
    const printBtn = document.getElementById('print-plan-btn');

    if (isPlanSheetFullyLocked) {
        printBtn.disabled = true;
        printBtn.classList.add('opacity-50', 'cursor-not-allowed');
        printBtn.title = 'Cannot print: All active schedules are already logged and locked for this period.';
    } else {
        printBtn.disabled = false;
        printBtn.classList.remove('opacity-50', 'cursor-not-allowed');
        printBtn.title = 'Print Plan';
    }
}


  // --- INITIALIZATION ---

  window.onload = function() {
    toggleLoading(true);
    google.script.run
      .withSuccessHandler(handleContractList)
      .withFailureHandler(handleError)
      .getContracts();
      
    document.getElementById('print-setup-confirm-btn').addEventListener('click', handlePrintSetupConfirm);
    document.getElementById('print-setup-cancel-btn').addEventListener('click', hidePrintSetupModal);

    document.getElementById('signatory-prepared-by').addEventListener('input', (e) => handleSignatoryInputChange(e, 'preparedBy'));
    document.getElementById('signatory-prepared-by').addEventListener('change', (e) => handleSignatoryInputChange(e, 'preparedBy')); 

    document.getElementById('signatory-approved-by').addEventListener('input', (e) => handleSignatoryInputChange(e, 'approvedBy'));
    document.getElementById('signatory-approved-by').addEventListener('change', (e) => handleSignatoryInputChange(e, 'approvedBy')); 

    for(let i = 0; i < 5; i++) {
        const input = document.getElementById(`signatory-checked-by-${i}`);
        if(input) {
            input.addEventListener('input', (e) => handleSignatoryInputChange(e, 'checkedBy', i));
            input.addEventListener('change', (e) => handleSignatoryInputChange(e, 'checkedBy', i)); 
        }
    }
  }
</script>
