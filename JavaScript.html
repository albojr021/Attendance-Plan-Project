<script>
  // Include jQuery first (Select2 dependency)
  document.write('<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"><\/script>');
  document.write('<script src="https://cdnjs.cloudflare.com/ajax/libs/select2/4.0.13/js/select2.min.js"><\/script>');
  
  // Include jQuery UI (for Datepicker)
  document.write('<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.css">');
  document.write('<script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js"><\/script>');
  
  // Custom style
  document.write('<style>');
  document.write('.ui-month-year-only .ui-datepicker-calendar { display: none !important; }');
  document.write('.ui-month-year-only .ui-datepicker-buttonpane { text-align: center; }');
  document.write('@media print { select { -webkit-appearance: none !important; -moz-appearance: none !important; appearance: none !important; border: none !important; background: transparent !important; padding: 0 !important; margin: 0 !important; text-align: center !important; } select::-ms-expand { display: none; } }');
  document.write('</style>');
  
  // Global state variables
  let contractList = [];
  let currentContract = null;
  const CONTRACT_ID_CACHE_KEY = 'current_contract_id'; 
  let employeeMasterList = []; // Global state for Employee Master Data
  let signatoryMasterList = []; // Global state for Signatory Master Data
  let all201PersonnelList = [];  // Full list of employees from 201 (blacklisted or not)
  let blacklistedEmployeeList = []; // Only blacklisted employees for quick lookup
  let savedRelieverList = [];
  let currentGroup = 'S1'; // Global state for Save Group Number, Default is S1

  // DATE NAVIGATION VARIABLE
  let currentPlanningDate = new Date(); 
  const fixedStatusCodes = ['RD', 'RH', 'SH', '', 'NA']; 
  const shiftPeriods = [
    { key: '1stHalf', label: '1st Half (1st to 15th)' },
    { key: '2ndHalf', label: '2nd Half (16th to End)' }
  ];
  const maxDays = 31; 
  const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];

  let selectedCellData = {}; // FIXED STATUS OPTIONS PARA SA FLOATING DROPDOWN 

  // Global state for Bulk Selection
  let isBulkSelectionMode = false;
  let bulkSelectedCells = []; 
  //  NEW DRAG STATE VARIABLES
  let isDragging = false;
  let dragStartCell = null;
  let dragEndCell = null;
  let cellsFromCurrentDrag = []; 
  
  // NEW: Global state for tracking of changes
  let pendingAttendanceChanges = {}; 
  let pendingEmployeeInfoChanges = {}; 
  let pendingRelieverChanges = {};
  
  let lockedIdRefMap = {}; // Global state for locked ID map {ID: Ref#}
  let isPlanSheetFullyLocked = false; // GLOBAL STATE FOR PRINT LOCKING
  let bulkPrintSelected = []; // Global state for Bulk Print Selection
  let bulkUnlockSelected = []; // GLOBAL STATE FOR BULK UNLOCK SELECTION 
  let bulkDeleteSelected = []; // GLOBAL STATE FOR BULK DELETE SELECTION

  // GLOBAL STATE FOR SIGNATORIES
  let selectedSignatories = {
      preparedBy: { name: '', designation: '' },
      checkedBy: [ 
        { name: '', designation: '' }, 
        { name: '', designation: '' }, 
        { name: '', designation: '' }, 
        { name: '', designation: '' }, 
        { name: '', designation: '' }
      ], 
      approvedBy: { name: '', designation: '' }
  };
  
  // GLOBAL STATE FOR PRINT FIELDS
  let printFieldMasterData = { sections: [], departments: [], remarks: [] }; 
  const DEFAULT_SECURITY_REFERENCES = "a. Section 4, Rule VII of them 2013 Revised Implementing Rules and Regulations of RA 11917, as amended and,\nb. RA 10591, Comprehensive Firearms and Ammunition and Regulation Act";
  let selectedPrintFields = {
      subProperty: '',
      section: '',
      department: '',
      remarks: '',
      serialNo: '', 
      to: '',
      references: ''   
  };

  const fixedStatusOptions = [
    { value: 'RD', label: 'Rest Day (RD)', color: 'status-rd text-red-700' },
    { value: 'RH', label: 'Regular Holiday (RH)', color: 'status-rh text-blue-700' },
    { value: 'SH', label: 'Special Holiday (SH)', color: 'status-sh text-yellow-700' },
    { value: '', label: 'Clear/Blank (Work Schedule)', color: 'bg-gray-200 text-gray-700' },
    { value: 'NA', label: 'Not Applicable (NA) / Excluded', color: 'status-na text-gray-500' },
  ];
  
  const TIME_FORMAT_REGEX = /^[0-9]{1,2}(:[0-9]{2})?(AM|PM)-[0-9]{1,2}(:[0-9]{2})?(AM|PM)$/;
  const PERSONNEL_ID_REGEX = /^[0-9]+$/; // Only numbers, Regex for Personnel Info validation
  const SAFE_TEXT_REGEX = /^[A-Z0-9\s.,-]+$/; 
  
  // NEW REGEX FOR SIGNATORY NAMES (Letters, Space, Dash, Comma, Period only)
  const SIGNATORY_REGEX = /^[A-Z\s.,-]+$/; 
  const SAFE_NAME_REGEX = /[^A-Z\s.,-]/g; 
  
  function formatTime12H(h, m) {
      const ampm = h >= 12 ? 'PM' : 'AM';
      const h12 = h % 12 || 12;
      const mStr = m === 0 ? '' : ':' + m.toString().padStart(2, '0');
      return `${h12}${mStr}${ampm}`;
  }

  // Time Option Generator for Dropdowns 
  function generateTimeOptions() {
      const times = [];
      for (let h = 0; h < 24; h++) {
          for (let m = 0; m < 60; m += 30) {
              times.push(formatTime12H(h, m)); 
          }
      }
      return times;
  }
  const TIME_OPTIONS = generateTimeOptions();

  // Normalize Name for Comparison (Removes all non-alphanumeric)
  function normalizeNameForComparison(name) {
      if (!name) return '';
      
      const upperName = name.toUpperCase();
      let cleanedName = upperName.replace(/[^A-Z\s]/g, ''); 
      
      const sortedWords = cleanedName.split(/\s+/) 
                                   .filter(word => word.length > 0) 
                                   .sort()
                                   .join(''); 
      
      return sortedWords;
  }
  
  // Fetch and Populate Master Employee Data
  function fetchEmployeeMasterData(sfcRef) {
    google.script.run
         .withSuccessHandler(populateDataLists)
         .withFailureHandler(handleError)
         .getEmployeeMasterDataForUI(sfcRef);
}

  // Client-side Blacklist Check (UPDATED FOR NAME NORMALIZATION)
function checkIsBlacklisted(id, name) {
    const cleanId = (id || '').trim();
    const cleanName = (name || '').trim().toUpperCase(); 

    const normalizedName = normalizeNameForComparison(cleanName);
    
    // Check by ID
    const isBlacklistedById = blacklistedEmployeeList.some(e => e.id === cleanId);
    if (isBlacklistedById) {
        const blacklistEntry = blacklistedEmployeeList.find(e => e.id === cleanId);
        return { isBlacklisted: true, reason: `Personnel ID ${cleanId} is BLACKLISTED.`, originalName: blacklistEntry.name };
    }
    
    // Check by Name 
    const isBlacklistedByName = blacklistedEmployeeList.some(e => {
        const storedNameNormalized = normalizeNameForComparison(e.name);
        return storedNameNormalized === normalizedName;
    });
    
    if (isBlacklistedByName && normalizedName.length > 0) {
        const blacklistEntry = blacklistedEmployeeList.find(e => normalizeNameForComparison(e.name) === normalizedName);
        return { isBlacklisted: true, reason: `Personnel Name "${cleanName}" is BLACKLISTED (Linked ID: ${blacklistEntry.id}).`, originalId: blacklistEntry.id };
    }
    
    return { isBlacklisted: false, reason: '' };
}
  
  // Logic for Name/ID Datalist Population
  function populateDataLists(data) {
    employeeMasterList = data.datalist;             // Non-blacklisted for datalist suggestions
    blacklistedEmployeeList = data.blacklisted;     // Blacklist for real-time validation
    all201PersonnelList = data.all201Personnel;     // All 201 for allowing manual input check
    
    const positionList = document.getElementById('employee-position-list');
    const areaList = document.getElementById('employee-area-list');

    // Clear existing options
    if (positionList) positionList.innerHTML = '';
    if (areaList) areaList.innerHTML = '';

    const uniquePositions = new Set();
    const uniqueAreas = new Set();
      
    employeeMasterList.forEach(emp => {
        const displayPosition = emp.position.toUpperCase();
        
        // Collect unique position/area
        if (emp.position) uniquePositions.add(displayPosition.trim());
        if (emp.area) uniqueAreas.add(emp.area.trim());
    });
      
    // Populate Position Datalist
    if (positionList) {
        uniquePositions.forEach(pos => {
            const posOption = document.createElement('option');
            posOption.value = pos;
            positionList.appendChild(posOption);
        });
    }

    // Populate Area Datalist
    if (areaList) {
        uniqueAreas.forEach(area => {
            const areaOption = document.createElement('option');
            areaOption.value = area;
            areaList.appendChild(areaOption);
        });
    }
      
    console.log(`Datalists populated with ${employeeMasterList.length} employees. (${uniquePositions.size} positions, ${uniqueAreas.size} areas)`);
}
  
  // PRINT FIELD MASTER DATA FUNCTIONS 
  function fetchPrintFieldMasterData() {
       google.script.run
            .withSuccessHandler(populatePrintFieldDatalists)
            .withFailureHandler(handleError)
            .getPrintFieldMasterData(); 
  }

  function populatePrintFieldDatalists(data) {
    printFieldMasterData = data;
    
    const populateList = (listId, items) => {
        const list = document.getElementById(listId);
        if (!list) return;
        list.innerHTML = '';
        items.forEach(item => {
            const option = document.createElement('option');
            option.value = item;
            list.appendChild(option);
        });
    };
    
    populateList('section-master-list', data.sections);
    populateList('department-master-list', data.departments);
    populateList('remarks-master-list', data.remarks);

    console.log(`Print Field datalists populated with ${data.sections.length} sections, ${data.departments.length} departments, and ${data.remarks.length} remarks.`);
  }
  
  // Fetch and Populate Signatory Master Data
  function fetchSignatoryMasterData() {
       google.script.run
            .withSuccessHandler(populateSignatoryDataLists)
            .withFailureHandler(handleError)
            .getSignatoryMasterData(); 
  }

  // Now expects a list of {name, designation} objects
  function populateSignatoryDataLists(masterList) {
      signatoryMasterList = masterList;
      const signatoryList = document.getElementById('signatory-master-list');

      signatoryList.innerHTML = '';
      
      signatoryMasterList.forEach(item => {
          const option = document.createElement('option');
          option.value = item.name;
          option.textContent = `${item.name} (${item.designation})`;
          signatoryList.appendChild(option);
      });

      console.log(`Signatory datalist populated with ${masterList.length} names/designations for Checked/Approved By.`);
  }

function isDuplicateId(newId, originalStableKey, currentNo) {
    const trimmedNewId = newId.trim();
    if (!trimmedNewId) return false;

    let duplicateFound = false;
    
    // 1. Check REGULAR Grid (#attendance-table-container)
    document.querySelectorAll('#attendance-table-container input[data-field="id"]').forEach(input => {
        const row = input.closest('tr');
        const rowKey = row.dataset.stableKey;
        const currentIdInInput = (input.value || '').trim();
        
        // Skip the row currently being validated/edited (Regular Row)
        if (rowKey === originalStableKey || rowKey === `TEMP_${currentNo}`) {
            return;
        }
        
        // Skip rows marked for deletion
        if (row.classList.contains('line-through')) {
            return;
        }
        
        if (currentIdInInput === trimmedNewId) {
            duplicateFound = true;
        }
    });
    if (duplicateFound) return true;
    
    // 2. Check RELIEVER Grid (#reliever-table-container)
    document.querySelectorAll('#reliever-table-container input[data-field="id"]').forEach(input => {
        const row = input.closest('tr');
        const rowKey = row.dataset.stableKey; // e.g., RELIVER_TEMP_1
        const currentIdInInput = (input.value || '').trim();

        // Skip the row currently being validated/edited (Reliever Row)
        if (rowKey === originalStableKey) { 
            return;
        }
        
        if (currentIdInInput === trimmedNewId) {
            duplicateFound = true;
        }
    });
    
    return duplicateFound;
}

function isDuplicateName(newName, originalStableKey, currentNo) {
    const normalizedNewName = normalizeNameForComparison(newName); 
    if (!normalizedNewName) return false;
    
    let duplicateFound = false;
    
    // 1. Check REGULAR Grid (#attendance-table-container)
    document.querySelectorAll('#attendance-table-container input[data-field="name"]').forEach(input => {
        const row = input.closest('tr');
        const rowKey = row.dataset.stableKey;
        const currentNameInInput = (input.value || '').trim();
        const normalizedCurrentName = normalizeNameForComparison(currentNameInInput);
        
        // Skip the row currently being edited/validated (Regular Row)
        if (rowKey === originalStableKey || rowKey === `TEMP_${currentNo}`) {
            return;
        }
        
        // Skip rows marked for deletion
        if (row.classList.contains('line-through')) {
            return;
        }
        
        // Check for conflict (using normalized names)
        if (normalizedCurrentName === normalizedNewName) {
            duplicateFound = true;
        }
    });
    if (duplicateFound) return true;
    
    // 2. Check RELIEVER Grid (#reliever-table-container)
    document.querySelectorAll('#reliever-table-container input[data-field="name"]').forEach(input => {
        const row = input.closest('tr');
        const rowKey = row.dataset.stableKey;
        const currentNameInInput = (input.value || '').trim();
        const normalizedCurrentName = normalizeNameForComparison(currentNameInInput);

        // Skip the row currently being edited/validated (Reliever Row)
        if (rowKey === originalStableKey) { 
            return;
        }
        
        // Check for conflict (using normalized names)
        if (normalizedCurrentName === normalizedNewName) {
            duplicateFound = true;
        }
    });
    
    return duplicateFound;
}
  
  function getActiveEmployeesInGrid() {
    const activeEmployees = [];
    
    const renderedEmployees = currentContract?.employees || [];
    
    renderedEmployees.forEach((employee, index) => {
        const stableKey = employee.id || `TEMP_${index + 1}`; 
        const pendingInfo = pendingEmployeeInfoChanges[stableKey];
        
        if (pendingInfo && pendingInfo.isDeleted) return; 

        const displayId = (pendingInfo && pendingInfo.id) ? pendingInfo.id : employee.id;
        const displayName = (pendingInfo && pendingInfo.name) ? pendingInfo.name : employee.name;
        
        if (!displayId.trim()) return; 
        
        activeEmployees.push({
            id: displayId.trim(),
            name: displayName.trim(),
            stableKey: stableKey, // New field for stable key
            planCells: [] 
        });
    });
    
    const gridRows = document.querySelectorAll('#attendance-table-container tbody tr');
    gridRows.forEach(row => {
        const stableKey = row.dataset.stableKey;
        if (!stableKey.startsWith('TEMP_')) return; 

        const pendingInfo = pendingEmployeeInfoChanges[stableKey];
        if (pendingInfo && pendingInfo.isDeleted) return; 
        if (!pendingInfo) return; 

        const displayId = pendingInfo.id;
        const displayName = pendingInfo.name;
        
        if (displayId && displayName) {
             activeEmployees.push({
                 id: displayId.trim(),
                 name: displayName.trim(),
                 stableKey: stableKey, // New field for stable key
                 planCells: [] 
             });
        }
    });

    return activeEmployees;
  }

// Get Employee Details from Master List
function getEmployeeDetails(id) {
    return employeeMasterList.find(e => e.id === id);
}

function filterDatalistOptions(event) {
    const input = event.target;
    const listId = input.getAttribute('list'); // 'employee-id-list' or 'employee-name-list'
    const datalist = document.getElementById(listId);
    
    // Check if the input value has at least 1 character before filtering
    const filterValue = input.value.toUpperCase().trim();
    const isIdList = (listId === 'employee-id-list');
    const isMasterList = (listId === 'employee-name-list' || isIdList);
    const maxResults = 20; // Limitahan sa 20 resulta para sa performance

    // 1. Clear current datalist options immediately
    if (datalist) {
        datalist.innerHTML = '';
    } else {
        return;
    }
    
    if (filterValue.length === 0) {
        return; // Walang gagawin kung walang input
    }
    
    // Check if filtering the main employee master list
    if (isMasterList) {
        
        // 2. Filter the global employeeMasterList
        const filteredEmployees = employeeMasterList.filter(emp => {
            if (isIdList) {
                // Filter by Personnel ID
                return emp.id.toUpperCase().includes(filterValue);
            } else {
                // Filter by Personnel Name
                return emp.name.toUpperCase().includes(filterValue);
            }
        }).slice(0, maxResults); // Kunin lang ang top 20

        // 3. Populate the datalist with filtered results
        filteredEmployees.forEach(emp => {
            const option = document.createElement('option');
            const displayName = emp.name.toUpperCase(); 
            const displayPosition = emp.position.toUpperCase();
            
            if (isIdList) {
                // ID Datalist: Value is ID, Text shows Name/Position
                option.value = emp.id;
                option.textContent = `${displayName} (${displayPosition})`;
            } else {
                // Name Datalist: Value is Name, Text shows ID/Position
                option.value = displayName;
                option.textContent = `${emp.id} (${displayPosition})`;
            }
            
            datalist.appendChild(option);
        });
    } else if (listId === 'remarks-master-list') {
        // Filter Remarks (optional field, uses printFieldMasterData.remarks)
        printFieldMasterData.remarks.filter(remark => {
            return remark.toUpperCase().includes(filterValue);
        }).slice(0, maxResults).forEach(remark => {
             const option = document.createElement('option');
             option.value = remark;
             datalist.appendChild(option);
        });
    }
}

// TRIGGERS ASYNCHRONOUS BLACKLIST CHECK FOR A ROW
function triggerBlacklistCheck(rowElement, personnelId, personnelName) {
    const currentId = (personnelId || '').trim();
    const currentName = (personnelName || '').trim();

    // Skip check if both ID and Name are empty
    if (!currentId && !currentName) {
        showPersonnelWarning(rowElement, null); // Clear existing warning
        return;
    }

    // Call server for validation
    google.script.run
        .withSuccessHandler((result) => {
            const latestId = rowElement.querySelector('[data-field="id"]').value.trim();
            const latestName = rowElement.querySelector('[data-field="name"]').value.trim();

            // Only apply result if the ID/Name combination hasn't changed since the request was sent
            if (latestId === currentId && latestName === currentName) {
                if (result.isBlacklisted) {
                    showPersonnelWarning(rowElement, `BLACKLISTED! (${result.reason.split('(')[0].trim()})`);
                    showNotification(`BLACKLIST ALERT: ${result.reason} Plan not allowed.`, false);
                } else {
                    showPersonnelWarning(rowElement, null); // Clear
                }
            } else {
                // If inputs changed while waiting for response, ignore this outdated result
                // and trust the warning from the LATEST request.
                console.warn('Blacklist check result is outdated, ignoring.');
            }
        })
        .withFailureHandler((error) => {
            handleError(error);
            showPersonnelWarning(rowElement, null);
        })
        .checkBlacklistByIdOrName(currentId, currentName); 
}

function getLockedRefNumsList() {
    const lockedRefMap = lockedIdRefMap; // {ID: Ref#}
    const refMap = {}; // {Ref#: {count: N, isSelected: boolean, employees: []}}

    Object.keys(lockedRefMap).forEach(id => {
        const ref = lockedRefMap[id];
        const empDetails = getEmployeeDetails(id); // Use helper to get details
        
        if (ref) {
            if (!refMap[ref]) {
                const isSelected = bulkUnlockSelected.includes(ref);
                refMap[ref] = { 
                    ref: ref, 
                    count: 0, 
                    isSelected: isSelected,
                    employees: [] // New array to hold employee objects
                };
            }
            refMap[ref].count++;
            if (empDetails) {
                 refMap[ref].employees.push({
                     id: id,
                     name: empDetails.name || `ID: ${id}`
                 });
            } else {
                 refMap[ref].employees.push({
                     id: id,
                     name: `ID: ${id}` // Fallback name if missing in master list
                 });
            }
        }
    });
    
    // Sort employees alphabetically within each group
    Object.values(refMap).forEach(item => {
        item.employees.sort((a, b) => a.name.localeCompare(b.name));
    });

    // Convert map to sorted array
    const refList = Object.values(refMap).sort((a, b) => a.ref.localeCompare(b.ref));

    return refList;
}


// Open Unlock Selection Modal
function openUnlockSelectionModal() {
    const lockedRefNums = getLockedRefNumsList();
    const listContainer = document.getElementById('locked-ref-list-container'); 
    const modal = document.getElementById('unlock-selection-modal');
    const selectAllCheckbox = document.getElementById('select-all-unlock');
    const sendButton = document.getElementById('unlock-modal-send-btn');


    if (lockedRefNums.length === 0) {
        showNotification('No schedules are currently locked for this period.', false);
        return;
    }
    
    listContainer.innerHTML = '';
    
    lockedRefNums.forEach(item => {
        // Create the main list item container (flex column to hold header and nested list)
        const listItem = document.createElement('li');
        const itemBgClass = item.isSelected ? 'bg-yellow-100 border-yellow-400' : 'bg-gray-50 border-gray-200';
        
        listItem.className = `flex flex-col p-2 rounded-lg border hover:bg-yellow-50 transition duration-150 cursor-pointer ${itemBgClass}`;
        
        // Construct the inner HTML for the header (checkbox + ref# + count + toggle button)
        listItem.innerHTML = `
            <div class="flex items-center space-x-3 w-full ref-header-row" data-ref="${item.ref}">
                <input type="checkbox" id="unlock-check-${item.ref}" 
                       data-ref="${item.ref}" 
                       class="unlock-checkbox h-4 w-4 text-red-600 border-gray-300 rounded focus:ring-red-500" 
                       ${item.isSelected ? 'checked' : ''}>
                <label for="unlock-check-${item.ref}" class="flex-grow text-sm font-medium text-gray-800 cursor-pointer">
                    <span class="font-bold">${item.ref}</span> 
                </label>
                <span class="text-xs font-semibold text-purple-700 bg-purple-100 px-2 py-0.5 rounded-full whitespace-nowrap">(${item.count} employees)</span>
                <button type="button" class="toggle-employee-list p-1 text-gray-500 hover:text-gray-700 transition duration-150" data-target="#employees-${item.ref.replace(/[^a-zA-Z0-9]/g, '-')}" title="Show Employees">
                    <svg class="h-4 w-4 transform ${item.isSelected ? 'rotate-180' : 'rotate-0'} transition duration-300" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7" />
                    </svg>
                </button>
            </div>
            <ul id="employees-${item.ref.replace(/[^a-zA-Z0-9]/g, '-')}" class="space-y-1 mt-2 ${item.isSelected ? '' : 'hidden'} ml-6 text-xs text-gray-600 list-disc list-inside">
                ${item.employees.map(emp => `<li>${emp.name} (ID: ${emp.id})</li>`).join('')}
            </ul>
        `;
        
        const checkbox = listItem.querySelector('.unlock-checkbox');
        const employeeList = listItem.querySelector(`ul#employees-${item.ref.replace(/[^a-zA-Z0-9]/g, '-')}`);
        const toggleButton = listItem.querySelector('.toggle-employee-list');
        const toggleSvg = toggleButton ? toggleButton.querySelector('svg') : null;
        
        // 1. Checkbox change listener (updates global state, visual style, AND AUTO-EXPANDS LIST)
        checkbox.addEventListener('change', (e) => {
            const isChecked = e.target.checked;
            updateBulkUnlockSelection(e);
            listItem.classList.toggle('bg-yellow-100', isChecked);
            listItem.classList.toggle('border-yellow-400', isChecked);
            listItem.classList.toggle('bg-gray-50', !isChecked);
            listItem.classList.toggle('border-gray-200', !isChecked);
            
            // Awtomatikong i-expand/i-collapse
            if (employeeList && toggleSvg) {
                if (isChecked) {
                    employeeList.classList.remove('hidden');
                    toggleSvg.classList.add('rotate-180');
                } else {
                    // Auto-collapse if unchecked
                    employeeList.classList.add('hidden');
                    toggleSvg.classList.remove('rotate-180');
                }
            }
        });

        // 2. List item click listener (toggles checkbox unless a button/checkbox was clicked)
        listItem.querySelector('label').addEventListener('click', (e) => {
            e.preventDefault(); // Prevent default action on label, let checkbox logic handle it
            checkbox.checked = !checkbox.checked;
            checkbox.dispatchEvent(new Event('change'));
        });

        // 3. Toggle button listener (shows/hides employee list - still allows manual toggle)
        listItem.querySelector('.toggle-employee-list').addEventListener('click', (e) => {
             const targetId = e.currentTarget.dataset.target;
             const list = listItem.querySelector(targetId);
             const svg = e.currentTarget.querySelector('svg');
             
             list.classList.toggle('hidden');
             svg.classList.toggle('rotate-180');
        });
        
        listContainer.appendChild(listItem);
    });
    
    updateUnlockModalState();

    if (selectAllCheckbox) {
        selectAllCheckbox.removeEventListener('change', toggleSelectAll);
        selectAllCheckbox.addEventListener('change', toggleSelectAll);
        selectAllCheckbox.checked = (lockedRefNums.length > 0 && bulkUnlockSelected.length === lockedRefNums.length);
    }
    

    document.getElementById('unlock-modal-cancel-btn').onclick = () => modal.classList.add('hidden');
    document.getElementById('unlock-modal-send-btn').onclick = handleBulkUnlockRequest;
    
    // Initial button state update
    sendButton.textContent = `Send Unlock Request (${bulkUnlockSelected.length})`;

    modal.classList.remove('hidden');
}

// Select All Logic (UPDATED FOR REF#)
function toggleSelectAll(event) {
    const isChecked = event.target.checked;
    const checkboxes = document.querySelectorAll('#locked-ref-list-container .unlock-checkbox');
    
    bulkUnlockSelected = []; 

    checkboxes.forEach(checkbox => {
        checkbox.checked = isChecked;
        
        const ref = checkbox.dataset.ref;
        const listItem = checkbox.closest('li');
        const employeeList = listItem.querySelector(`ul#employees-${ref.replace(/[^a-zA-Z0-9]/g, '-')}`);
        const toggleSvg = listItem.querySelector('.toggle-employee-list svg');

        if (isChecked) {
            bulkUnlockSelected.push(ref);
            listItem.classList.add('bg-yellow-100', 'border-yellow-400');
            listItem.classList.remove('bg-gray-50', 'border-gray-200');
            
            // Awtomatikong i-expand
            if (employeeList && toggleSvg) {
                employeeList.classList.remove('hidden');
                toggleSvg.classList.add('rotate-180');
            }
        } else {
            bulkUnlockSelected = bulkUnlockSelected.filter(r => r !== ref); // Ensure removal
            listItem.classList.remove('bg-yellow-100', 'border-yellow-400');
            listItem.classList.add('bg-gray-50', 'border-gray-200');

            // Awtomatikong i-collapse
            if (employeeList && toggleSvg) {
                employeeList.classList.add('hidden');
                toggleSvg.classList.remove('rotate-180');
            }
        }
    });
    
    updateUnlockModalState();
}


// Helper to update global array and modal state on checkbox change (UPDATED FOR REF#)
function updateBulkUnlockSelection(event) {
    const checkbox = event.target;
    const ref = checkbox.dataset.ref;
    const isChecked = checkbox.checked;

    const existingIndex = bulkUnlockSelected.indexOf(ref);

    if (isChecked && existingIndex === -1) {
        bulkUnlockSelected.push(ref);
    } else if (!isChecked && existingIndex > -1) {
        bulkUnlockSelected.splice(existingIndex, 1);
    }
    
    const selectAllCheckbox = document.getElementById('select-all-unlock');
    const totalLocked = getLockedRefNumsList().length;

    if (selectAllCheckbox) {
        selectAllCheckbox.checked = (bulkUnlockSelected.length === totalLocked);
    }
    
    updateUnlockModalState();
}

// Helper to update count display and button enablement (UPDATED FOR REF#)
function updateUnlockModalState() {
    const count = bulkUnlockSelected.length;
    document.getElementById('unlock-selection-count').textContent = count;
    document.getElementById('unlock-modal-send-btn').disabled = count === 0;
    document.getElementById('unlock-modal-send-btn').textContent = `Send Unlock Request (${count})`;
}

// Function to call server for bulk request (UPDATED FOR REF#)
function handleBulkUnlockRequest() {
    document.getElementById('unlock-selection-modal').classList.add('hidden');

    if (bulkUnlockSelected.length === 0) {
        showNotification('No Reference Numbers were selected for unlock.', false);
        return;
    }
    
    const currentYear = currentPlanningDate.getFullYear();
    const currentMonth = currentPlanningDate.getMonth();
    const currentShift = document.getElementById('shift-period-select').value;
    const sfcRef = currentContract?.sfcRef;

    // We pass the array of selected Reference Number strings
    const selectedRefNums = bulkUnlockSelected; 

    if (!sfcRef || selectedRefNums.length === 0) {
        showNotification('CRITICAL ERROR: Missing contract or selected Reference Numbers.', false);
        return;
    }

    toggleLoading(true);
    showNotification(`Sending Unlock Request Email for ${selectedRefNums.length} Reference Number(s)...`, true);
    
    bulkUnlockSelected = []; // Clear selection after sending

    google.script.run
        .withSuccessHandler((response) => {
            showNotification(response.message, response.success);
            toggleLoading(false);
        })
        .withFailureHandler((error) => {
            handleError(error); 
        })
        .requestUnlockEmailNotification(sfcRef, currentYear, currentMonth, currentShift, selectedRefNums);
}


  // --- UI HANDLERS ---
  // Function to control the full-screen overlay and button blocking
  function toggleUiLock(isLocked, message = 'Processing...') {
    const overlay = document.getElementById('full-screen-overlay');
    const overlayMessage = document.getElementById('overlay-message');
    const loadingAlert = document.getElementById('loading-alert');
    
    if (isLocked) {
        overlayMessage.textContent = message;
        overlay.classList.remove('hidden');
        if (!message.toLowerCase().includes('loading')) {
             loadingAlert.classList.add('hidden');
        }
    } else {
        overlay.classList.add('hidden');
        loadingAlert.classList.add('hidden');
    }
  }

  // Renaming and refactoring the old toggleLoading to use the new UiLock for synchronous tasks.
  function toggleLoading(isLoading, message = 'Loading initial data from Google Sheet...') {
    const loadingAlert = document.getElementById('loading-alert');
    
    if (isLoading) {
        // Only show the prominent alert/lock for critical/synchronous tasks
        loadingAlert.querySelector('p:first-child').textContent = message;
        loadingAlert.classList.remove('hidden');
        toggleUiLock(true, message); // Use the new lock for blocking
    } else {
        loadingAlert.classList.add('hidden');
        toggleUiLock(false); 
    }
  }


  function showNotification(message, isSuccess = true) {
    const notification = document.getElementById('notification-area');
    notification.textContent = message;
    notification.classList.remove('opacity-0', 'bg-red-100', 'text-red-800', 'bg-green-100', 'text-green-800');
    
    if (isSuccess) {
      notification.classList.add('bg-green-100', 'text-green-800');
    } else {
      notification.classList.add('bg-red-100', 'text-red-800');
    }

    notification.classList.add('opacity-100');
    
    setTimeout(() => {
      notification.classList.remove('opacity-100');
      notification.classList.add('opacity-0');
    }, 3000);
  }

  function handleError(error) {
    console.error("APPS SCRIPT ERROR:", error);
    showNotification(`Error: ${error.message || 'An unknown error occurred in the script.'}`, false);
    toggleLoading(false); // Make sure to unlock the UI
  }
  
  // RELOAD PLAN HELPER 
  function reloadPlanAndCheckExistence() {
      if (currentContract && currentContract.sfcRef) {
          document.getElementById('planning-area').classList.add('hidden'); 
          checkIfPlanExists(currentContract.sfcRef);
      } else {
          renderAttendancePlan(); 
      }
  }

  // Fetch the next sequential Group Number and update UI 
  // NOTE: This function is now only used by the Save flow to get the batch number.
  function fetchNextGroupNumberAndSetUI() {
    const sfcRef = currentContract?.sfcRef;
    const currentYear = currentPlanningDate.getFullYear();
    const currentMonth = currentPlanningDate.getMonth();
    const currentShift = document.getElementById('shift-period-select').value;
    
    google.script.run
        .withSuccessHandler((nextGroup) => {
            currentGroup = nextGroup; // Update internal variable for debugging/state (e.g. S1, S2)
            continueSaveProcess(nextGroup);
        })
        .withFailureHandler(handleSaveAllError) // Use the save handler for errors here
        .getNextGroupNumber(sfcRef, currentYear, currentMonth, currentShift);
  }

  function getPreviousPeriodDetails(year, month, shift) {
    const prevDate = new Date(year, month, 1);
    let prevShift = '';
    let prevYear = year;
    let prevMonth = month; // 0-indexed month

    if (shift === '2ndHalf') {
        // Source: 1st Half of the same month/year
        prevShift = '1stHalf';
        // prevYear and prevMonth remain the same
    } else if (shift === '1stHalf') {
        // Source: 2nd Half of the previous month/year
        prevShift = '2ndHalf';
        // Move back one month
        prevDate.setMonth(month - 1);
        prevYear = prevDate.getFullYear();
        prevMonth = prevDate.getMonth();
    } else {
        return null;
    }

    return {
        year: prevYear,
        month: prevMonth, // Return as 0-indexed month (0=Jan)
        shift: prevShift
    };
}

// Main Handler for Copy Previous Plan 
function copyPreviousPlan() {
    if (!currentContract) {
        showNotification('Please select a Contract Group ID first.', false);
        return;
    }
    
    // 1. Check for UNSAVED Changes (Roster Info or Schedule) - Panatilihin lang ang check sa pending edits.
  if (Object.keys(pendingAttendanceChanges).length > 0 || Object.keys(pendingEmployeeInfoChanges).length > 0) {
    showNotification('Cannot copy: The current period has unsaved changes (roster or schedule). Please click "Save All Changes to Sheets" or refresh the page to clear pending edits.', false);
    return;
}

    // 1. Determine Source Period
    const sourcePeriod = getPreviousPeriodDetails(
        currentPlanningDate.getFullYear(), 
        currentPlanningDate.getMonth(), 
        document.getElementById('shift-period-select').value
    );
    
    if (!sourcePeriod || sourcePeriod.year > currentPlanningDate.getFullYear() || (sourcePeriod.year === currentPlanningDate.getFullYear() && sourcePeriod.month > currentPlanningDate.getMonth())) {
        showNotification('Cannot copy plan: Unable to determine a valid previous period to copy from.', false);
        return;
    }

    toggleLoading(true, 'Copying previous plan roster. Fetching data...');
    
    // 2. Call backend function to fetch data for sourcePeriod
    google.script.run
        .withSuccessHandler(handlePreviousPlanData)
        .withFailureHandler(handleError)
        .getPlanDataForPeriod( 
            currentContract.sfcRef, 
            sourcePeriod.year, 
            sourcePeriod.month, 
            sourcePeriod.shift
        );
}

// Handle Data from Previous Period (Applies changes to current period)
function handlePreviousPlanData(data) {
    if (data.employees.length === 0) {
        showNotification('No saved plan found for the previous period to copy.', false);
        toggleLoading(false);
        return;
    }
    
    // 1. Clear existing pending changes
    pendingAttendanceChanges = {}; 
    pendingEmployeeInfoChanges = {}; 
    
    // 2. Target Period Details (Current Plan being edited)
    const currentYear = currentPlanningDate.getFullYear();
    const currentMonth = currentPlanningDate.getMonth();
    const currentShift = document.getElementById('shift-period-select').value;

    // Create a set of existing employee IDs in the current saved roster
    const existingEmployeeIds = new Set(currentContract.employees.map(emp => emp.id));
    let newEmployeesAdded = 0;
    let employeesSkipped = 0;

    // --- SECURITY DETAILS HANDLING ---
    if (!currentContract.securityDetails) {
        currentContract.securityDetails = {};
    }

    // Merge previous security details into current contract's details
    if (data.securityDetails) {
        Object.keys(data.securityDetails).forEach(empId => {
            currentContract.securityDetails[empId] = data.securityDetails[empId];
        });
    }

    // 3. Process Employee Roster (Apply only NON-EXISTING employees as pending changes)
    data.employees.forEach(emp => {
        const personnelId = emp.id;

        // **SKIP if employee ID already exists in the current saved roster**
        if (existingEmployeeIds.has(personnelId)) {
            employeesSkipped++;
            return; 
        }

        // If not existing, add to pendingEmployeeInfoChanges as a NEW entry
        const stableKey = personnelId; 
        
        let pendingChange = {
            id: personnelId, 
            name: emp.name, 
            position: emp.position, 
            area: emp.area,
            isNew: true, 
            originalEmployeeId: '', 
            isDeleted: false 
        };
        
        pendingEmployeeInfoChanges[stableKey] = pendingChange;
        newEmployeesAdded++; 
    });

    // 6. Re-render the grid (Security or Standard)
    renderAttendancePlan();
    checkPlanSheetLockState(); 
    
    const msg = currentContract.serviceType === 'SECURITY SERVICES' 
        ? `Copied ${newEmployeesAdded} guards (with firearms data) from previous plan.`
        : `Successfully copied ${newEmployeesAdded} new employees into the roster.`;

    showNotification(`${msg} (Skipped ${employeesSkipped} existing). Click "Save All Changes" to save.`, true);
    toggleLoading(false);
}

  // --- CONTRACT SELECTION & DATA FETCHING ---
  function handleContractList(contracts) {
    contractList = contracts;
    const select = document.getElementById('contract-select');
    select.innerHTML = '<option value="">-- Choose Contract Group ID --</option>';

    contracts.forEach(contract => {
      const option = document.createElement('option');
      option.value = contract.sfcRef;
      // Gamumat ng Contract ID at SFC Ref# para sa mas madaling hanapin
      option.textContent = `${contract.id} - ${contract.status} (Ref#: ${contract.sfcRef})`;
      select.appendChild(option);
    });

    setTimeout(() => {
        $('#contract-select').select2({
            placeholder: "-- Choose Contract Group ID --",
            allowClear: true,
            width: '100%',
        }).on('select2:select', handleSelect2Change) 
          .on('select2:unselect', handleSelect2Change) 
          .on('change', handleSelect2Change); 

        toggleLoading(false); // Unload the initial loading screen
        
        const picker = $('#month-year-picker');
        
        picker.datepicker({
            changeMonth: true,
            changeYear: true,
            showButtonPanel: true,
            dateFormat: 'MM yy', 
            onClose: function(dateText, inst) {
                const month = $("#ui-datepicker-div .ui-datepicker-month :selected").val();
                const year = $("#ui-datepicker-div .ui-datepicker-year :selected").val();
                
                if (month !== undefined && year !== undefined) {
                    const newDate = new Date(year, month, 1);
                    
                    const currentYear = currentPlanningDate.getFullYear();
                    const currentMonth = currentPlanningDate.getMonth();

                    if (newDate.getFullYear() !== currentYear || newDate.getMonth() !== currentMonth) {
                        currentPlanningDate = newDate;
                        
                        $(this).datepicker('setDate', newDate);
                        reloadPlanAndCheckExistence(); 
                    }
                }
                inst.dpDiv.removeClass('ui-month-year-only');
            },
            beforeShow: function(input, inst) {
                inst.dpDiv.addClass('ui-month-year-only');
                setTimeout(function(){
                    inst.dpDiv.find('.ui-datepicker-calendar').hide();
                    inst.dpDiv.find('.ui-datepicker-close').text('Select Period'); 
                }, 1);
            }
        });
        // Set the initial value
        updateDatePickerDisplay(currentPlanningDate.getFullYear(), currentPlanningDate.getMonth());
    }, 100); 

    // Populate Shift Periods
    const shiftSelect = document.getElementById('shift-period-select');
    shiftPeriods.forEach(period => {
      const option = document.createElement('option');
      option.value = period.key;
      option.textContent = period.label;
      shiftSelect.appendChild(option);
    });

    // Set default shift to 1st Half
    shiftSelect.value = '1stHalf';

    document.getElementById('shift-period-select').addEventListener('change', reloadPlanAndCheckExistence);
    document.getElementById('save-all-changes-btn').addEventListener('click', handleSaveAllChanges); // Listener for Save All Button
    document.getElementById('print-plan-btn').addEventListener('click', handlePrintPlan); // Listener for Print Button (Calls new modal function)
    document.getElementById('request-unlock-modal-btn').addEventListener('click', openUnlockSelectionModal); // Listener for Request Unlock Button (Modal Opener)
    document.getElementById('open-bulk-delete-btn').addEventListener('click', openBulkDeleteModal); // Listener for Bulk Delete Button (Modal Opener)

    // *** Attach Bulk Listeners ***
    document.getElementById('start-bulk-select-btn').addEventListener('click', startBulkSelectionMode);
    document.getElementById('bulk-cancel-btn').addEventListener('click', exitBulkSelectionMode);
    document.getElementById('bulk-save-btn').addEventListener('click', (event) => saveBulkSchedule(event, null));
    
    currentGroup = 'S1'; 
  }

  // I-create ang handler para sa Select2 change
  function handleSelect2Change(event) {
      const selectedSfcRef = $('#contract-select').val(); 
      
      if (!selectedSfcRef || selectedSfcRef === "") {
          document.getElementById('contract-details-area').classList.add('hidden');
          document.getElementById('planning-area').classList.add('hidden');
          document.getElementById('plan-action-area').classList.add('hidden');
          document.getElementById('initial-placeholder').classList.remove('hidden');
          currentContract = null;
          lockedIdRefMap = {}; 
          employeeMasterList = []; 
          sessionStorage.removeItem(CONTRACT_ID_CACHE_KEY); 
          
          isPlanSheetFullyLocked = false;
          updatePrintButtonState();
          
          // Reset Save Group to S1 default
          currentGroup = 'S1';
          return;
      }
      
      currentContract = contractList.find(c => c.sfcRef === selectedSfcRef);
      sessionStorage.setItem(CONTRACT_ID_CACHE_KEY, currentContract.id); 
      
      if (currentContract) {
          displayContractDetails(currentContract);
          fetchEmployeeMasterData(currentContract.sfcRef); 
          fetchSignatoryMasterData(); 
          checkIfPlanExists(currentContract.sfcRef); 
      }
  }


function displayContractDetails(contract) {
    document.getElementById('sfc-ref').textContent = contract.sfcRef;
    document.getElementById('payor-company').textContent = contract.payorCompany;
    document.getElementById('agency').textContent = contract.agency;
    document.getElementById('service-type').textContent = contract.serviceType;
    document.getElementById('head-count').textContent = contract.headCount;
    document.getElementById('prop-grp-code').textContent = contract.propOrGrpCode;
    document.getElementById('sector').textContent = contract.sector;
    
    document.getElementById('contract-details-area').classList.remove('hidden');
    document.getElementById('initial-placeholder').classList.add('hidden');
    
    document.getElementById('plan-action-area').classList.add('hidden'); 
}

// Function to check if the plan sheets already exist
function checkIfPlanExists(sfcRef) {
    toggleLoading(true, 'Checking plan sheet existence...');
    
    const currentYear = currentPlanningDate.getFullYear();
    const currentMonth = currentPlanningDate.getMonth();
    const currentShift = document.getElementById('shift-period-select').value;
    
    google.script.run
        .withSuccessHandler(handlePlanExistence)
        .withFailureHandler(handleError)
        .checkContractSheets(sfcRef, currentYear, currentMonth, currentShift); 
}

// --- Update the Plan Period display based on current date/shift ---
  function updatePlanPeriodDisplay(year, month, shift) {
    const date = new Date(year, month, 1);
    const monthName = date.toLocaleString('en-US', { month: 'long' });
    const yearNum = date.getFullYear();
    const daysInMonth = getDaysInMonth(year, month);
    
    let dateRange = '';
    if (shift === '1stHalf') {
        dateRange = `${monthName} 1-15, ${yearNum} (${shift})`;
    } else {
        dateRange = `${monthName} 16-${daysInMonth}, ${yearNum} (${shift})`;
    }

    document.getElementById('plan-period-display').textContent = dateRange;
  }
  
  // *** Update the Datepicker Input Field ***
  function updateDatePickerDisplay(year, month) {
    const date = new Date(year, month, 1);
    const monthYearText = date.toLocaleString('en-US', { month: 'long', year: 'numeric' });
    document.getElementById('month-year-picker').value = monthYearText;
    
    const picker = $('#month-year-picker');
    picker.datepicker('setDate', date);
  }

// Handles the response from checkContractSheets
function handlePlanExistence(exists) {
    const sfcRef = currentContract ? currentContract.sfcRef : null;

    const currentYear = currentPlanningDate.getFullYear();
    const currentMonth = currentPlanningDate.getMonth();
    const currentShift = document.getElementById('shift-period-select').value;
    updatePlanPeriodDisplay(currentYear, currentMonth, currentShift); 
    updateDatePickerDisplay(currentYear, currentMonth); 

    document.getElementById('plan-action-area').classList.add('hidden'); 

    // Since the sheet is consolidated, it always 'exists' if it's been initialized once.
    document.getElementById('plan-status-text').textContent = 'Attendance Plan Status: Loading Consolidated Plan Data...';
    fetchAttendanceData(sfcRef); 
    
    currentGroup = 'S1'; 
}

// Show blank Plan (No server call) - Now triggered after failed fetchAttendanceData
function showBlankPlan() {
    if (!currentContract) {
        showNotification('Please select a Contract Group ID first.', false);
        return;
    }

    const currentYear = currentPlanningDate.getFullYear();
    const currentMonth = currentPlanningDate.getMonth();
    const currentShift = document.getElementById('shift-period-select').value;
    updatePlanPeriodDisplay(currentYear, currentMonth, currentShift); 
    
    currentContract.employees = []; 
    currentContract.planMap = {}; 
    lockedIdRefMap = {}; 
    
    pendingAttendanceChanges = {}; 
    pendingEmployeeInfoChanges = {}; 
    
    document.getElementById('planning-area').classList.remove('hidden'); 
    showNotification('Ready to plan. No existing data found for this period. Changes will be saved as S1-1.0.', true);

    renderAttendancePlan(); 
    toggleLoading(false);
    
    isPlanSheetFullyLocked = false;
    updatePrintButtonState(); 
}


function fetchAttendanceData(sfcRef) {
    toggleLoading(true, 'Fetching existing plan data...');
    pendingAttendanceChanges = {}; 
    pendingEmployeeInfoChanges = {}; 
    
    const currentYear = currentPlanningDate.getFullYear();
    const currentMonth = currentPlanningDate.getMonth(); 
    const currentShift = document.getElementById('shift-period-select').value;

    updatePlanPeriodDisplay(currentYear, currentMonth, currentShift); 

    google.script.run
      .withSuccessHandler(handleAttendanceData)
      .withFailureHandler(handleError)
      .getAttendancePlan(sfcRef, currentYear, currentMonth, currentShift); 
}


function handleAttendanceData(data) {
    currentContract.employees = data.employees; 
    currentContract.planMap = data.planMap;
    currentContract.securityDetails = data.securityDetails || {}; 
    savedRelieverList = data.relieverPersonnelList || []; 
    
    lockedIdRefMap = data.lockedIdRefMap || {}; 
    const lockedIds = Object.keys(lockedIdRefMap);
    
    document.getElementById('planning-area').classList.remove('hidden'); 
    
    if (data.employees.length === 0) {
        showBlankPlan();
        return;
    }

    showNotification(`Attendance Plan loaded successfully! (Locked Schedules: ${lockedIds.length})`, true);

    renderAttendancePlan();
    toggleLoading(false);
    
    checkPlanSheetLockState(); 
}

  // --- DATE NAVIGATION ---
  function navigateMonth(direction) {
    currentPlanningDate.setMonth(currentPlanningDate.getMonth() + direction);
    currentPlanningDate.setDate(1); 
  }

  function getDaysInMonth(year, month) {
    return new Date(year, month + 1, 0).getDate();
  }

  function renderAttendancePlan() {
    if (!currentContract) return;

    const bulkSelectBtn = document.getElementById('start-bulk-select-btn');
    if (bulkSelectBtn) {
        bulkSelectBtn.classList.remove('hidden');
    }

    if (currentContract.serviceType === 'SECURITY SERVICES') {
        renderSecurityPlan();
    } else {
        renderStandardPlan();
    }
  }

  function renderStandardPlan() {
    const year = currentPlanningDate.getFullYear();
    const month = currentPlanningDate.getMonth();
    const daysInMonth = getDaysInMonth(year, month);
    const selectedShift = document.getElementById('shift-period-select').value;
    
    const monthName = currentPlanningDate.toLocaleString('en-US', { month: 'short' }); 

    updateDatePickerDisplay(year, month); 

    const startColIndex = 1;
    const endColIndex = 16;
    const startDayOfMonth = selectedShift === '1stHalf' ? 1 : 16;
    
    const lockedIds = Object.keys(lockedIdRefMap);

    const tableContainer = document.getElementById('attendance-table-container');
    tableContainer.innerHTML = '';

    const table = document.createElement('table');
    table.className = 'w-full text-sm text-left text-gray-700 border-collapse';
    
    // --- TABLE HEAD ---
    const thead = table.createTHead();
    const headerRow1 = thead.insertRow();
    const headerRow2 = thead.insertRow();
    
    // FIXED HEADERS (5 fixed employee info columns)
    const empInfoHeader = ['No.', 'Personnel ID', 'Personnel Name', 'POSITION', 'AREA POSTING']; 
    
    // --- 1. Header Row 1 (Main Fixed Labels & Date/Month) ---
    empInfoHeader.forEach((headerText, index) => {
        const th = document.createElement('th');
        th.scope = 'col';
        th.textContent = headerText;
        th.className = 'sticky-col-header text-xs font-semibold uppercase tracking-wider p-3 bg-gray-100 border-r border-b border-gray-300 z-20'; 
        
        // Freeze first few columns
        if (index <= 1) th.classList.add('freeze-1', 'z-30'); // No. and ID
        if (index === 2) th.classList.add('freeze-2', 'z-30'); // Name
        headerRow1.appendChild(th);
    });
    
    // --- 2. Header Row 2 (Empty Fixed Cells & Day Name) ---
    empInfoHeader.forEach((headerText, index) => {
        const th = document.createElement('th');
        th.scope = 'col';
        th.textContent = ''; // Empty content for alignment
        th.className = 'sticky-col-header text-xs font-semibold uppercase tracking-wider p-3 bg-gray-50 border-r border-gray-300 z-20'; 

        // Freeze first few columns
        if (index <= 1) th.classList.add('freeze-1', 'z-30'); // No. and ID
        if (index === 2) th.classList.add('freeze-2', 'z-30'); // Name
        headerRow2.appendChild(th);
    });

    // Loop through column index (1-16) and calculate the actual day (d)
    for (let colIndex = startColIndex; colIndex <= endColIndex; colIndex++) {
        const d = startDayOfMonth + colIndex - 1; // Actual Day of the Month

        if (d > daysInMonth) continue; // Skip if actual day exceeds max days in month (e.g., Nov 31)
        
        // ** Stop 1st Half at 15 **
        if (selectedShift === '1stHalf' && d > 15) continue; 
        
        const dayOfMonth = new Date(year, month, d);
        const dayName = dayNames[dayOfMonth.getDay()];
        const dateColWidth = '70px';
        
        // --- HEADER ROW 1 (Date/Month) ---
        const th = document.createElement('th');
        th.scope = 'col';
        th.style.width = dateColWidth;
        th.style.minWidth = dateColWidth;
        th.className = 'text-xs font-semibold uppercase tracking-wider p-1 text-center border-r border-b bg-gray-100'; 
        // Display the actual day (d)
        th.innerHTML = `<span>${d}</span><span class="block font-medium text-[10px] uppercase text-gray-500">${monthName}</span>`; 
        headerRow1.appendChild(th);
        
        // --- HEADER ROW 2 (Day Name) ---
        const thDay = document.createElement('th');
        thDay.scope = 'col';
        thDay.textContent = dayName;
        thDay.style.width = dateColWidth;
        thDay.style.minWidth = dateColWidth;
        thDay.className = 'text-xs font-medium uppercase tracking-wider p-3 text-center border-r bg-gray-50'; 
        headerRow2.appendChild(thDay);
    }
    
    // --- TABLE BODY ---
    const tbody = table.createTBody();

    let rowsToRender = currentContract.employees.slice() || [];
    
    Object.keys(pendingEmployeeInfoChanges).forEach(stableKey => {
         const change = pendingEmployeeInfoChanges[stableKey];
         const isUnsavedNewRow = change.originalEmployeeId === '';
         
         if (isUnsavedNewRow) {
             if (!rowsToRender.some(e => e.id === change.id || e.id === stableKey)) {
                 rowsToRender.push({
                     no: 0, 
                     id: change.id, 
                     name: change.name, 
                     position: change.position, 
                     area: change.area,
                     isNew: true,
                 });
             }
         }
    });

    // Sort rowsToRender alphabetically by name
    rowsToRender.sort((a, b) => {
        const nameA = (a.name || '').toUpperCase();
        const nameB = (b.name || '').toUpperCase();
        if (nameA < nameB) return -1;
        if (nameA > nameB) return 1;
        return 0;
    });

    const maxRenderedRows = Math.max(currentContract?.headCount || 0, rowsToRender.length);
    
    rowsToRender = rowsToRender.map((emp, index) => ({
        ...emp,
        no: index + 1 
    }));


    for (let i = 0; i < maxRenderedRows; i++) {
        const employee = rowsToRender[i] || { 
            no: i + 1, 
            id: '', 
            name: '', 
            position: '', 
            area: '' 
        };
        
        const stableLookupKey = employee.id || `TEMP_${employee.no}`; 
        
        const pendingInfo = pendingEmployeeInfoChanges[stableLookupKey]; 
        const isNewUnsaved = pendingInfo && pendingInfo.isNew;

        const displayId = (pendingInfo && pendingInfo.id) ? pendingInfo.id : employee.id;
        const displayName = (pendingInfo && pendingInfo.name) ? pendingInfo.name : employee.name;
        const displayPosition = (pendingInfo && pendingInfo.position) ? pendingInfo.position : employee.position;
        const displayArea = (pendingInfo && pendingInfo.area) ? pendingInfo.area : employee.area;
        
        const isSavedRow = (employee.id || (pendingInfo && pendingInfo.originalEmployeeId)) && !isNewUnsaved; 
        const isMarkedForDeletion = pendingInfo && pendingInfo.isDeleted; 
        
        const lockedRefNum = lockedIdRefMap[employee.id]; 
        const isPrintLocked = !!lockedRefNum && !isMarkedForDeletion; 
        
        const isRowBlank = !displayId.trim() && !displayName.trim() && !Object.keys(pendingInfo || {}).length;

        const tr = tbody.insertRow();
        tr.dataset.stableKey = stableLookupKey; 
        
        if (isRowBlank || isMarkedForDeletion) {
             tr.classList.add('print-empty-row'); 
        }
        
        if (isMarkedForDeletion) {
            tr.classList.add('bg-red-200', 'opacity-50', 'line-through');
        } else if (isPrintLocked) {
             tr.classList.add('bg-gray-300', 'opacity-80', 'locked-row'); 
        }

        
        // 1. Employee Info Cells (Fixed Columns)
        // No. 
        let td = tr.insertCell();
        td.className = 'sticky-col text-center p-0 bg-gray-50 font-bold border-r border-b z-10 freeze-1 relative'; 
        
        let innerHTML = `<span class="block py-2">${employee.no}</span>`;
        
        td.innerHTML = innerHTML;
        
        if (!isRowBlank && !isSavedRow) {
             const newLabel = document.createElement('span');
             newLabel.textContent = 'NEW';
             newLabel.className = 'new-label-no-col absolute top-1/2 right-0 transform -translate-y-1/2 mr-1 text-[8px] font-bold text-green-700 bg-green-200 px-1 py-0.5 rounded print-hidden';
             td.appendChild(newLabel);
        }

        // Personnel ID (Input) - Index 1
        td = tr.insertCell();
        input = document.createElement('input');
        input.type = 'text';
        input.setAttribute('list', 'employee-id-list'); 
        input.value = displayId;
        input.placeholder = 'ID';
        input.maxLength = 20; 
        input.readOnly = isSavedRow || isMarkedForDeletion || isPrintLocked; 
        input.dataset.oldPersonnelId = stableLookupKey; 
        input.dataset.field = 'id';
        input.dataset.rowNo = employee.no; 
        input.className = 'personnel-info-input text-center p-1 border-none focus:ring-blue-400 w-full bg-transparent ' + (input.readOnly ? 'read-only' : ''); 
        td.appendChild(input);
        td.className = 'sticky-col p-0 bg-white border-r border-b z-10 freeze-1 relative'; 
        
        // --- UNLOCK BUTTON IN PERSONNEL ID COLUMN (for locked rows) ---
        if (isPrintLocked) {
            
            const refParts = lockedRefNum.split('-');
            let randomPart = 'N/A';
            let groupPart = 'N/A';

            if (refParts.length === 6) {
                randomPart = refParts[4]; // 0001
                groupPart = refParts[5];  // P1
            } else if (refParts.length === 5) {
                randomPart = refParts[3];
                groupPart = refParts[4];
            }
            
            // Keep the Lock Tag (REF XXXX)
            const lockTag = document.createElement('span');
            lockTag.className = 'text-[9px] font-extrabold text-blue-800 bg-blue-200 px-1.5 py-0.5 rounded-full whitespace-nowrap absolute top-1 left-1 print-hidden';
            lockTag.title = `Locked by Print Ref. #${lockedRefNum}`;
            lockTag.textContent = `REF ${randomPart} (${groupPart})`;
            td.appendChild(lockTag);
        }
        
        // Personnel Name (Input) - Index 2
        td = tr.insertCell();
        input = document.createElement('input');
        input.type = 'text';
        input.setAttribute('list', 'employee-name-list'); 
        input.value = displayName; 
        input.placeholder = 'Full Name';
        input.readOnly = isSavedRow || isMarkedForDeletion || isPrintLocked; 
        input.dataset.oldPersonnelId = stableLookupKey; 
        input.dataset.field = 'name';
        input.className = 'personnel-info-input p-1 border-none focus:ring-blue-400 w-full bg-transparent ' + (input.readOnly ? 'read-only' : ''); 
        td.appendChild(input);
        td.className = 'sticky-col p-0 bg-white border-r border-b z-10 freeze-2';
        
        // Position (Input) - Index 3
        td = tr.insertCell();
        input = document.createElement('input');
        input.type = 'text';
        input.setAttribute('list', 'employee-position-list'); 
        input.value = displayPosition; 
        input.placeholder = 'Position';
        input.readOnly = isSavedRow || isMarkedForDeletion || isPrintLocked; 
        input.dataset.oldPersonnelId = stableLookupKey; 
        input.dataset.field = 'position';
        input.className = 'personnel-info-input p-1 border-none focus:ring-blue-400 w-full bg-transparent ' + (input.readOnly ? 'read-only' : ''); 
        td.appendChild(input);
        td.className = 'p-0 bg-white border-r border-b';
        
        // Area Posting (Input) - Index 4
        td = tr.insertCell();
        input = document.createElement('input');
        input.type = 'text';
        input.setAttribute('list', 'employee-area-list'); 
        input.value = displayArea; 
        input.placeholder = 'Area';
        input.readOnly = isSavedRow || isMarkedForDeletion || isPrintLocked; 
        input.dataset.oldPersonnelId = stableLookupKey; 
        input.dataset.field = 'area';
        input.className = 'personnel-info-input p-1 border-none focus:ring-blue-400 w-full bg-transparent ' + (input.readOnly ? 'read-only' : ''); 
        td.appendChild(input);
        td.className = 'p-0 bg-white border-r border-b';

        // Add event listeners for Personnel Info updates
        if (!isSavedRow && !isPrintLocked && !isMarkedForDeletion) {
            tr.querySelectorAll('.personnel-info-input').forEach(infoInput => {
                infoInput.addEventListener('input', (e) => handlePersonnelInfoChange(e, employee));
                infoInput.addEventListener('change', (e) => handlePersonnelInfoChange(e, employee));
            });

            const idInput = tr.querySelector('[data-field="id"]');
            const nameInput = tr.querySelector('[data-field="name"]');

              if(idInput) {
                  idInput.addEventListener('input', filterDatalistOptions);
              }
              if(nameInput) {
                  nameInput.addEventListener('input', filterDatalistOptions);
              }
        }

        // 2. Attendance Plan Cells (Dynamic Dates) - Starts at index 5
        const currentPersonnelId = displayId; 
        let hasScheduleForShift = false; 
        
        // Loop through column index (1-16) and calculate the actual day (d)
        for (let colIndex = startColIndex; colIndex <= endColIndex; colIndex++) {
            const d = startDayOfMonth + colIndex - 1; // Actual Day of the Month

            if (d > daysInMonth) continue; // Skip if actual day exceeds max days in month
            
            // Stop 1st Half at 15
            if (selectedShift === '1stHalf' && d > 15) continue; 
            
            const dayKeyUnpadded = `${year}-${month + 1}-${d}`;
            
            const trimmedCurrentId = currentPersonnelId.toString().trim();
            const trimmedEmployeeId = employee.id.toString().trim();
            const trimmedShift = selectedShift.toString().trim();
            const trimmedDayKey = dayKeyUnpadded.toString().trim(); 

            const planKey = `${trimmedCurrentId}_${trimmedDayKey}_${trimmedShift}`;
            const pendingStatus = pendingAttendanceChanges[planKey];

            const savedDataKeyUnpadded = `${trimmedEmployeeId}_${trimmedDayKey}_${trimmedShift}`;
            const savedStatusUnpadded = currentContract.planMap[savedDataKeyUnpadded] || '';


            let status = pendingStatus !== undefined ? pendingStatus : '';

            if (status === '') {
                 if (savedStatusUnpadded !== '') {
                    status = savedStatusUnpadded;
                 }
            }

            if (status !== '') {
                hasScheduleForShift = true; 
            }
            
            td = tr.insertCell();
            const isSelected = bulkSelectedCells.includes(td);
            const isCellLocked = isPrintLocked || isMarkedForDeletion;
            const cursorClass = isCellLocked ? 'cursor-not-allowed' : (isBulkSelectionMode ? 'cursor-crosshair' : 'cursor-pointer');
            
            td.className = `cell-container text-center border-r border-b transition duration-100 ease-in-out ${cursorClass} ${isSelected ? 'cell-selected' : ''}`;
            
            const dateColWidth = '70px';
            td.style.width = dateColWidth;
            td.style.minWidth = dateColWidth;
            
            updateCellVisuals(td, status, dayKeyUnpadded); 

            td.dataset.dayKey = dayKeyUnpadded; 
            td.dataset.shiftKey = trimmedShift;
            td.dataset.originalId = employee.id; 
            
            if (!isCellLocked) {
                td.addEventListener('click', handleCellClick);
                
                if (isBulkSelectionMode) {
                    td.removeEventListener('click', handleCellClick);
                }
            }
        }
    }
    
    tableContainer.appendChild(table);
    renderRelieverTable();
  }

  function getShiftValue(shiftStr) {
    if (!shiftStr || shiftStr === 'ZZZZ') return 99999; // Empty shifts go to bottom
    
    const startTimeMatch = shiftStr.match(/^(\d{1,2})(?::(\d{2}))?(AM|PM)/i);
    
    if (!startTimeMatch) return 99999; // Fallback

    let hours = parseInt(startTimeMatch[1], 10);
    const minutes = startTimeMatch[2] ? parseInt(startTimeMatch[2], 10) : 0;
    const period = startTimeMatch[3].toUpperCase();

    if (hours === 12) {
        hours = (period === 'AM') ? 0 : 12;
    } else {
        if (period === 'PM') hours += 12;
    }

    return (hours * 60) + minutes;
}

  // SECURITY SERVICES GRID
  function renderSecurityPlan() {
    const year = currentPlanningDate.getFullYear();
    const month = currentPlanningDate.getMonth();
    const selectedShift = document.getElementById('shift-period-select').value;
    const daysInMonth = getDaysInMonth(year, month);
    
    // Update Date Picker Display
    updateDatePickerDisplay(year, month);

    const monthName = currentPlanningDate.toLocaleString('en-US', { month: 'short' });
    let dateRangeStr = "";
    if (selectedShift === '1stHalf') {
        dateRangeStr = `${monthName} 1-15, ${year}`;
    } else {
        dateRangeStr = `${monthName} 16-${daysInMonth}, ${year}`;
    }

    const tableContainer = document.getElementById('attendance-table-container');
    tableContainer.innerHTML = '';

    const table = document.createElement('table');
    table.className = 'w-full text-sm text-left text-gray-700 border-collapse border border-gray-400 security-print-table';
    
    // --- TABLE HEAD ---
    const thead = table.createTHead();
    
    // ROW 1
    const trHead1 = thead.insertRow();
    const headers1 = [
        { text: 'NO.', rowSpan: 2, width: '40px' },
        { text: 'Personnel ID', rowSpan: 2, width: '70px' },
        { text: 'Name of Guards', rowSpan: 2, width: '200px' }, 
        { text: 'Designation', rowSpan: 2, width: '100px' },
        { text: 'Place of Duty (Location)', rowSpan: 2, width: '180px' },
        { text: 'Time of Shift', rowSpan: 1, colSpan: 1, width: '140px' },
        { text: 'Firearm Nomenclature', rowSpan: 1, colSpan: 4, width: 'auto' }, 
        { text: 'Validity of License', rowSpan: 2, width: '120px' }
    ];

    headers1.forEach(h => {
        const th = document.createElement('th');
        th.textContent = h.text;
        if (h.rowSpan) th.rowSpan = h.rowSpan;
        if (h.colSpan) th.colSpan = h.colSpan;
        if (h.width) th.style.width = h.width;
        th.className = 'text-xs font-bold uppercase tracking-wider p-2 bg-gray-200 border border-gray-500 text-center align-middle';
        trHead1.appendChild(th);
    });

    // ROW 2 (Sub-headers)
    const trHead2 = thead.insertRow();
    const headers2 = [
        { text: dateRangeStr, className: 'text-blue-800 font-extrabold' }, 
        { text: 'Type' },
        { text: 'Make' },
        { text: 'Caliber' },
        { text: 'Serial No.' }
    ];

    headers2.forEach(h => {
        const th = document.createElement('th');
        th.textContent = h.text;
        th.className = `text-xs font-bold uppercase p-2 bg-gray-100 border border-gray-500 text-center ${h.className || ''}`;
        trHead2.appendChild(th);
    });

    // --- TABLE BODY ---
    const tbody = table.createTBody();

    // 1. Get existing saved employees
    let rowsToRender = currentContract.employees.slice() || [];

    // 2. Merge pending NEW employees
    Object.keys(pendingEmployeeInfoChanges).forEach(stableKey => {
         const change = pendingEmployeeInfoChanges[stableKey];
         const isUnsavedNewRow = change.originalEmployeeId === '';
         
         if (isUnsavedNewRow) {
             if (!rowsToRender.some(e => e.id === change.id || e.id === stableKey)) {
                 rowsToRender.push({
                     no: 0, 
                     id: change.id, 
                     name: change.name, 
                     position: change.position, 
                     area: change.area,         
                     isNew: true,
                 });
             }
         }
    });

    // --- SORTING LOGIC (Shift Priority -> Alphabetical) ---
    rowsToRender.sort((a, b) => {
        const idA = (pendingEmployeeInfoChanges[a.id]?.id || a.id || '').toString().trim();
        const idB = (pendingEmployeeInfoChanges[b.id]?.id || b.id || '').toString().trim();

        const secDetailsA = (currentContract.securityDetails && idA) ? currentContract.securityDetails[idA] : null;
        const secDetailsB = (currentContract.securityDetails && idB) ? currentContract.securityDetails[idB] : null;

        const shiftA = (secDetailsA && secDetailsA.timeOfShift) ? secDetailsA.timeOfShift.trim() : 'ZZZZ';
        const shiftB = (secDetailsB && secDetailsB.timeOfShift) ? secDetailsB.timeOfShift.trim() : 'ZZZZ';

        const valA = getShiftValue(shiftA);
        const valB = getShiftValue(shiftB);

        if (valA !== valB) return valA - valB;

        const nameA = (a.name || '').toUpperCase();
        const nameB = (b.name || '').toUpperCase();
        return nameA.localeCompare(nameB);
    });

    // --- COLOR PALETTE FOR SHIFT ---
    const shiftColors = [
        '#e0f2fe', // Light Blue
        '#dcfce7', // Light Green
        '#fff7ed', // Light Orange
        '#f3e8ff', // Light Purple
        '#fae8ff', // Light Pink
        '#f1f5f9'  // Light Gray
    ];
    let colorMap = {}; 
    let colorIndex = 0;

    const maxRenderedRows = Math.max(currentContract?.headCount || 0, rowsToRender.length);

    for (let i = 0; i < maxRenderedRows; i++) {
        const employee = rowsToRender[i] || { no: i + 1, id: '', name: '', position: '', area: '' };
        const stableLookupKey = employee.id || `TEMP_${i + 1}`;
        const pendingInfo = pendingEmployeeInfoChanges[stableLookupKey];
        const isMarkedForDeletion = pendingInfo && pendingInfo.isDeleted;
        
        const displayId = (pendingInfo && pendingInfo.id) ? pendingInfo.id : employee.id;
        const displayName = (pendingInfo && pendingInfo.name) ? pendingInfo.name : employee.name;
        const displayPos = (pendingInfo && pendingInfo.position) ? pendingInfo.position : employee.position;
        const displayArea = (pendingInfo && pendingInfo.area) ? pendingInfo.area : employee.area;

        const isSavedRow = (employee.id && employee.id !== '' && !employee.isNew);
        const lockedRefNum = lockedIdRefMap[employee.id]; 
        const isPrintLocked = !!lockedRefNum && !isMarkedForDeletion; 

        // Get Security Details & Determine Color
        const secDetails = (currentContract.securityDetails && displayId) 
            ? currentContract.securityDetails[displayId.toString().trim()] 
            : null;

        let cellBackgroundColor = 'transparent';
        const currentShiftTime = (secDetails && secDetails.timeOfShift) ? secDetails.timeOfShift.trim() : '';

        if (currentShiftTime && currentShiftTime !== '') {
            if (!colorMap.hasOwnProperty(currentShiftTime)) {
                colorMap[currentShiftTime] = shiftColors[colorIndex % shiftColors.length];
                colorIndex++;
            }
            cellBackgroundColor = colorMap[currentShiftTime];
        }

        const tr = tbody.insertRow();
        tr.dataset.stableKey = stableLookupKey;
        
        // Removed row-wide background color application
        if (isMarkedForDeletion) {
            tr.classList.add('bg-red-200', 'line-through');
        } else if (isPrintLocked) { 
            tr.classList.add('bg-gray-300', 'opacity-80', 'locked-row'); 
        }

        // Logic for fields
        const isNamePresent = displayName && displayName.trim() !== '';
        const isBasicFieldDisabled = isSavedRow || isPrintLocked; 
        const basicDisabledClass = isBasicFieldDisabled ? 'cursor-not-allowed text-gray-500' : '';
        const isStrictFieldDisabled = !isNamePresent || isPrintLocked;
        const strictDisabledClass = isStrictFieldDisabled ? 'cursor-not-allowed text-gray-400' : '';

        // 1. NO.
        let td = tr.insertCell();
        td.className = 'text-center p-2 border border-gray-400 font-semibold';
        td.textContent = i + 1;

        // 2. Personnel ID 
        td = tr.insertCell();
        td.className = 'p-1 border border-gray-400 relative';

        const inputId = document.createElement('input'); 
        inputId.type = 'text'; 
        inputId.value = displayId; 
        inputId.placeholder = 'ID';
        inputId.dataset.field = 'id'; 
        inputId.dataset.oldPersonnelId = stableLookupKey; 
        inputId.setAttribute('list', 'employee-id-list'); // Enable datalist suggestion

        if (isSavedRow) {
            inputId.readOnly = true;
            inputId.className = 'w-full p-1 bg-transparent text-gray-800 cursor-not-allowed outline-none personnel-info-input text-center font-bold';
        } else {
            inputId.className = 'w-full p-1 bg-transparent focus:bg-white focus:ring-2 focus:ring-blue-500 outline-none personnel-info-input text-center font-bold text-gray-800';
            inputId.addEventListener('input', (e) => handlePersonnelInfoChange(e, employee));
            inputId.addEventListener('change', (e) => handlePersonnelInfoChange(e, employee));
            inputId.addEventListener('input', filterDatalistOptions);
        }
        td.appendChild(inputId);

        if (isPrintLocked) {
            const refParts = lockedRefNum.split('-');
            let randomPart = 'N/A';
            let groupPart = 'N/A';
            if (refParts.length === 6) {
                randomPart = refParts[4]; 
                groupPart = refParts[5];
            } else if (refParts.length === 5) {
                randomPart = refParts[3];
                groupPart = refParts[4];
            }
            const lockTag = document.createElement('span');
            lockTag.className = 'text-[9px] font-extrabold text-blue-800 bg-blue-200 px-1.5 py-0.5 rounded-full whitespace-nowrap absolute top-1 left-1 print-hidden';
            lockTag.title = `Locked by Print Ref. #${lockedRefNum}`;
            lockTag.textContent = `REF ${randomPart}`;
            td.appendChild(lockTag);
        }

        // 3. Name (MODIFIED: Removed hidden ID input)
        td = tr.insertCell();
        td.className = 'p-1 border border-gray-400 relative';

        const inputName = document.createElement('input');
        inputName.type = 'text'; 
        inputName.setAttribute('list', 'employee-name-list'); 
        inputName.value = displayName; 
        inputName.placeholder = 'Select Guard';
        inputName.dataset.field = 'name'; 
        inputName.dataset.oldPersonnelId = stableLookupKey;
        
        if (isSavedRow) {
            inputName.readOnly = true;
            inputName.className = 'w-full p-1 bg-transparent text-gray-800 cursor-not-allowed outline-none personnel-info-input uppercase font-bold';
        } else {
            inputName.className = 'w-full p-1 bg-transparent focus:bg-white focus:ring-2 focus:ring-blue-500 outline-none personnel-info-input uppercase font-bold text-gray-800';
            inputName.addEventListener('input', (e) => handlePersonnelInfoChange(e, employee));
            inputName.addEventListener('change', (e) => handlePersonnelInfoChange(e, employee));
            inputName.addEventListener('input', filterDatalistOptions);
        }
        td.appendChild(inputName);

        // 3. Designation
        td = tr.insertCell();
        td.className = 'p-1 border border-gray-400';
        const inputPos = document.createElement('input');
        inputPos.type = 'text'; 
        inputPos.value = displayPos; 
        inputPos.dataset.field = 'position'; 
        inputPos.dataset.oldPersonnelId = stableLookupKey;
        inputPos.setAttribute('list', 'security-designation-list');
        inputPos.disabled = isBasicFieldDisabled; 
        inputPos.className = `w-full p-1 outline-none personnel-info-input text-center uppercase bg-transparent ${basicDisabledClass} ${!isBasicFieldDisabled ? 'focus:bg-white focus:ring-2 focus:ring-blue-500' : ''}`;
        if (!isSavedRow) inputPos.addEventListener('change', (e) => handlePersonnelInfoChange(e, employee));
        td.appendChild(inputPos);

        // 4. Place of Duty
        td = tr.insertCell();
        td.className = 'p-1 border border-gray-400';
        const inputArea = document.createElement('input');
        inputArea.type = 'text'; 
        inputArea.value = displayArea; 
        inputArea.dataset.field = 'area'; 
        inputArea.dataset.oldPersonnelId = stableLookupKey;
        inputArea.setAttribute('list', 'security-place-list'); 
        inputArea.disabled = isBasicFieldDisabled; 
        inputArea.className = `w-full p-1 outline-none personnel-info-input text-center uppercase bg-transparent ${basicDisabledClass} ${!isBasicFieldDisabled ? 'focus:bg-white focus:ring-2 focus:ring-blue-500' : ''}`;
        if (!isSavedRow) inputArea.addEventListener('change', (e) => handlePersonnelInfoChange(e, employee));
        td.appendChild(inputArea);

        // 5. Time of Shift (ONLY THIS CELL IS COLORED)
        td = tr.insertCell();
        td.className = 'p-1 border border-gray-400 relative security-bulk-cell';
        
        if (currentShiftTime) {
            td.style.setProperty('background-color', cellBackgroundColor, 'important');
            td.classList.add('shift-colored-cell');
        }

        const selectShift = document.createElement('select');
        selectShift.disabled = isStrictFieldDisabled; 
        selectShift.className = `w-full text-xs p-1 border border-gray-300 rounded focus:ring-blue-500 text-center font-semibold h-8 bg-transparent ${isStrictFieldDisabled ? 'cursor-not-allowed opacity-50' : ''}`;
        selectShift.style.backgroundColor = 'transparent';
        selectShift.dataset.securityField = 'timeOfShift';

        const defOpt = document.createElement('option');
        defOpt.value = '';
        defOpt.text = '- Select -';
        selectShift.appendChild(defOpt);

        for (let h = 0; h < 24; h++) {
            for (let m = 0; m < 60; m += 30) {
                const startStr = formatTime12H(h, m);
                const endH_raw = (h + 12) % 24;
                const endStr = formatTime12H(endH_raw, m);
                const shiftStr = `${startStr}-${endStr}`;
                
                const opt = document.createElement('option');
                opt.value = shiftStr;
                opt.text = shiftStr;
                if (secDetails && secDetails.timeOfShift && secDetails.timeOfShift.trim() === shiftStr) {
                    opt.selected = true;
                }
                selectShift.appendChild(opt);
            }
        }
        selectShift.addEventListener('change', (e) => handleSecurityInputDirty(e, employee));
        td.appendChild(selectShift);

        // Helper for other inputs
        const createSecInput = (placeholder, field, val, listId) => {
             const inp = document.createElement('input'); 
             inp.type = 'text'; 
             inp.placeholder = placeholder; 
             inp.dataset.securityField = field; 
             inp.disabled = isStrictFieldDisabled; 
             inp.className = `w-full p-1 text-center text-xs uppercase outline-none bg-transparent ${strictDisabledClass} ${!isStrictFieldDisabled ? 'focus:bg-white focus:ring-1 focus:ring-blue-400' : ''}`; 
             if (val) inp.value = val;
             if (listId) inp.setAttribute('list', listId); 
             inp.addEventListener('change', (e) => handleSecurityInputDirty(e, employee));
             return inp;
        };

        // 6. FA Type
        td = tr.insertCell(); td.className = 'p-1 border border-gray-400 security-bulk-cell';
        
        const inputFaType = createSecInput('PISTOL', 'faType', secDetails?.faType, 'security-type-list');
        
        inputFaType.addEventListener('input', (e) => {
            if (e.target.value.trim() === '') {
                const row = e.target.closest('tr');
                const dependentFields = ['faMake', 'faCaliber', 'faSerial', 'licenseValidity'];
                dependentFields.forEach(field => {
                    const el = row.querySelector(`[data-security-field="${field}"]`);
                    if (el) {
                        el.value = ''; 
                        el.dispatchEvent(new Event('change', { bubbles: true }));
                    }
                });
            }
            updateFirearmDependentFields(e.target.closest('tr'));
        });
        
        td.appendChild(inputFaType);

        // 7. FA Make
        td = tr.insertCell(); td.className = 'p-1 border border-gray-400 security-bulk-cell';
        td.appendChild(createSecInput('', 'faMake', secDetails?.faMake, 'security-make-list'));

        // 8. FA Caliber
        td = tr.insertCell(); td.className = 'p-1 border border-gray-400 security-bulk-cell';
        td.appendChild(createSecInput('', 'faCaliber', secDetails?.faCaliber, 'security-caliber-list'));

        // 9. FA Serial
        td = tr.insertCell(); td.className = 'p-1 border border-gray-400'; 
        td.appendChild(createSecInput('', 'faSerial', secDetails?.faSerial, 'security-serial-list'));

        // 10. Validity
        td = tr.insertCell();
        td.className = 'p-1 border border-gray-400';
        const inputValid = document.createElement('input');
        inputValid.type = 'text'; 
        inputValid.placeholder = 'MM/DD/YYYY';
        inputValid.dataset.securityField = 'licenseValidity';
        inputValid.className = 'w-full p-1 bg-transparent text-center text-xs outline-none security-date-input cursor-pointer'; 
        inputValid.readOnly = true; 
        if (isStrictFieldDisabled) {
             inputValid.disabled = true;
             inputValid.classList.add('cursor-not-allowed', 'opacity-50');
        }
        if (secDetails?.licenseValidity) inputValid.value = secDetails.licenseValidity;
        inputValid.addEventListener('change', (e) => handleSecurityInputDirty(e, employee));
        td.appendChild(inputValid);

        updateFirearmDependentFields(tr);
    }

    tableContainer.appendChild(table);

    // Re-initialize Datepicker
    $('.security-date-input').datepicker({
        dateFormat: 'mm/dd/yy',
        changeMonth: true,
        changeYear: true
    });

    renderRelieverTable();
}

function handleSecurityInputDirty(event, employee) {
    const stableKey = event.target.closest('tr').dataset.stableKey;

    if (!pendingEmployeeInfoChanges[stableKey]) {
         pendingEmployeeInfoChanges[stableKey] = {
             id: employee.id,
             name: employee.name,
             position: employee.position,
             area: employee.area,
             isNew: false,
             originalEmployeeId: employee.id,
             isSecurityUpdate: true 
         };
    }
}

function fetchSecuritySuggestions() {
    google.script.run
        .withSuccessHandler(populateSecurityDatalists)
        .withFailureHandler(handleError)
        .getSecurityFieldSuggestions();
}

function populateSecurityDatalists(data) {
    const populate = (id, items) => {
        const list = document.getElementById(id);
        if(!list) return;
        list.innerHTML = '';
        items.forEach(item => {
            const opt = document.createElement('option');
            opt.value = item;
            list.appendChild(opt);
        });
    };

    populate('security-designation-list', data.designations);
    populate('security-place-list', data.places);
    populate('security-type-list', data.types);
    populate('security-make-list', data.makes);
    populate('security-caliber-list', data.calibers);
    populate('security-serial-list', data.serials);
    
    console.log("Security datalists populated.");
}

  
  // Visually manage warning state for a personnel row
function showPersonnelWarning(rowElement, message) {
    const warningClass = 'border-red-500 ring-4 ring-red-200';
    
    if (message) {
        rowElement.classList.add(warningClass);
        let warningDiv = rowElement.querySelector('.blacklist-warning');
        if (!warningDiv) {
            warningDiv = document.createElement('div');
            warningDiv.className = 'blacklist-warning absolute bottom-0 left-0 right-0 p-1 text-xs font-semibold text-white bg-red-600 z-50';
            
            const nameCell = rowElement.querySelector('td.freeze-2'); 
            if (nameCell) nameCell.style.position = 'relative'; 
            if (nameCell) nameCell.appendChild(warningDiv);
        }
        warningDiv.textContent = message;
        warningDiv.style.display = 'block';
        
    } else {
        rowElement.classList.remove(warningClass);
        const warningDiv = rowElement.querySelector('.blacklist-warning');
        if (warningDiv) warningDiv.style.display = 'none';
    }
}

  function updateSecurityRowState(row, nameValue) {
    // Check if Security Service
    if (!currentContract || currentContract.serviceType !== 'SECURITY SERVICES') return;

    const isEmpty = nameValue.trim() === '';

    // Group A: Strict Fields (Shift, Firearms, Validity) -> Base Enable/Disable logic (Name-based)
    const strictInputs = row.querySelectorAll('[data-security-field]');
    strictInputs.forEach(inp => {
        if (isEmpty) {
            inp.value = '';
            inp.disabled = true;
            inp.classList.add('bg-gray-100', 'cursor-not-allowed', 'text-gray-400');
            inp.classList.remove('bg-transparent', 'focus:ring-2', 'focus:ring-blue-500', 'focus:ring-1', 'focus:ring-blue-400');
        } else {
            inp.disabled = false;
            inp.classList.remove('bg-gray-100', 'cursor-not-allowed', 'text-gray-400');
            inp.classList.add('bg-transparent', inp.tagName === 'SELECT' ? 'focus:ring-blue-500' : 'focus:ring-1', inp.tagName === 'SELECT' ? 'focus:ring-blue-500' : 'focus:ring-blue-400');
        }
    });

    // (Group B: Basic Fields logic - Designation
    const basicInputs = row.querySelectorAll('[data-field="position"], [data-field="area"]');
    basicInputs.forEach(inp => {
         if (isEmpty) {
             inp.value = ''; 
             inp.disabled = false; 
             inp.classList.remove('bg-gray-100', 'cursor-not-allowed', 'text-gray-400');
             inp.classList.add('bg-transparent', 'focus:ring-2', 'focus:ring-blue-500');
         } else {
             inp.disabled = false;
             inp.classList.remove('bg-gray-100', 'cursor-not-allowed', 'text-gray-400');
             inp.classList.add('bg-transparent', 'focus:ring-2', 'focus:ring-blue-500');
         }
    });
    
    // Datepicker specific handling
    const dateInput = row.querySelector('.security-date-input');
    if (dateInput) {
         if (isEmpty) {
             dateInput.disabled = true;
             dateInput.classList.add('bg-gray-100', 'cursor-not-allowed');
         } else {
             dateInput.disabled = false;
             dateInput.classList.remove('bg-gray-100', 'cursor-not-allowed');
             // Re-bind datepicker logic if needed
             $(dateInput).datepicker({ dateFormat: 'mm/dd/yy', changeMonth: true, changeYear: true });
         }
    }

    if (!isEmpty) {
        updateFirearmDependentFields(row);
    }
}

function updateFirearmDependentFields(row) {
    const typeInput = row.querySelector('[data-security-field="faType"]');
    if (!typeInput) return;

    const hasType = typeInput.value.trim() !== '';
    const isRowActive = !typeInput.disabled;
    const dependentFields = ['faMake', 'faCaliber', 'faSerial', 'licenseValidity'];

    dependentFields.forEach(field => {
        const input = row.querySelector(`[data-security-field="${field}"]`);
        if (input) {
            if (isRowActive && hasType) {
                input.disabled = false;
                input.classList.remove('bg-gray-100', 'cursor-not-allowed', 'text-gray-400');
                input.classList.add('bg-transparent', 'focus:ring-1', 'focus:ring-blue-400');
            } else {
                input.disabled = true;
                input.classList.add('bg-gray-100', 'cursor-not-allowed', 'text-gray-400');
                input.classList.remove('bg-transparent', 'focus:ring-1', 'focus:ring-blue-400');
            }
        }
    });
}

  // --- EMPLOYEE INFO HANDLERS (Manual Save) ---
  function handlePersonnelInfoChange(event, employee) {
    const input = event.target;
    const field = input.dataset.field;
    const oldPersonnelKey = input.dataset.oldPersonnelId; 
    let newValue = input.value;
    const row = input.closest('tr');
    
    // --- SECURITY SERVICES AUTO-CLEAR/DISABLE LOGIC (UPDATED) ---
    if (currentContract && currentContract.serviceType === 'SECURITY SERVICES' && field === 'name') {
        updateSecurityRowState(row, newValue);
    }

    let pendingChange = pendingEmployeeInfoChanges[oldPersonnelKey] || {
        id: employee.id, 
        name: employee.name, 
        position: employee.position, 
        area: employee.area,
        isNew: !employee.id,
        originalEmployeeId: employee.id,
        isDeleted: false 
    };
    
    const previousIdValue = pendingChange.id; 
    
    if (input.readOnly) {
         if (lockedIdRefMap[employee.id]) {
             showNotification('Cannot edit: Saved row is locked by a printed reference number.', false);
         } else if (pendingChange.isDeleted) {
             showNotification('Cannot edit: Row is marked for deletion. Please remove the deletion mark if you wish to edit.', false);
         } else {
             showNotification('Cannot edit: Saved row is locked.', false);
         }
         input.value = employee[field];
         return;
    }

    let masterRecordFound = null; 
    let masterRecord = null;
    
    const upperNewValue = newValue.trim().toUpperCase(); 
    
    // --- SIMULA: REAL-TIME VALIDATION (Change Event Only) ---
    if (event.type === 'change') {
        const idInput = row.querySelector('[data-field="id"]');
        const nameInput = row.querySelector('[data-field="name"]');
        const currentId = idInput?.value.trim() || '';
        const currentName = nameInput?.value.trim() || '';
        const upperCurrentName = currentName.toUpperCase();
        
        // 1. BLACKLIST CHECK
        const blacklistCheckResult = checkIsBlacklisted(currentId, currentName);
        if (blacklistCheckResult.isBlacklisted) {
            showNotification(`FATAL: Cannot use Personnel ID/Name. Employee is BLACKLISTED! ${blacklistCheckResult.reason}`, false);
            const oldState = currentContract.employees.find(e => e.id === employee.id) || employee;
            input.value = oldState[field] || ''; 
            if (field === 'name') updateSecurityRowState(row, input.value);
            pendingChange[field] = input.value;
            showPersonnelWarning(row, null); 
            return; 
        }

        // 2. UPDATED 201 CHECK
        const isNewUnsaved = pendingChange.isNew; 
        if (upperNewValue.length > 0 && isNewUnsaved && (field === 'id' || field === 'name')) { 
            const is201Employee = all201PersonnelList.some(e => {
                if (field === 'id') return e.id === currentId;
                else {
                    const normalizedInputName = normalizeNameForComparison(upperCurrentName);
                    return normalizeNameForComparison(e.name) === normalizedInputName;
                }
            });

            if (!is201Employee) { 
                showNotification(`FATAL: Personnel ${field.toUpperCase()} "${newValue}" not found in the 201 Master File.`, false);
                input.value = employee[field] || ''; 
                if (field === 'name') updateSecurityRowState(row, input.value);
                pendingChange[field] = employee[field] || ''; 
                const allPendingBlank = !pendingChange.id.trim() && !pendingChange.name.trim() && !pendingChange.position.trim() && !pendingChange.area.trim();
                if (allPendingBlank) delete pendingEmployeeInfoChanges[oldPersonnelKey];
                return; 
            }
        }
        
        // 3. NEW: CROSS-CONTRACT CONFLICT CHECK (Trigger only if Name is present)
        if (currentName.length > 0) {
             triggerCrossContractCheck(row, currentName, 'regular');
        }

        if (field === 'id' || field === 'name') showPersonnelWarning(row, null); 

    } // End of if (event.type === 'change') block

    let isSaved = currentContract.employees.some(e => e.id === employee.id);

    if (field === 'id') {
         masterRecord = employeeMasterList.find(e => e.id === upperNewValue);
    } else if (field === 'name') {
         const normalizedInputName = normalizeNameForComparison(upperNewValue);
         masterRecord = employeeMasterList.find(e => normalizeNameForComparison(e.name) === normalizedInputName);
    }

    const isNewUnsaved = pendingChange.isNew; 
    
    if (masterRecord) {
        masterRecordFound = masterRecord; 
        row.querySelector('[data-field="id"]').value = masterRecord.id;
        row.querySelector('[data-field="name"]').value = masterRecord.name;
        
        // Always auto-fill Position/Area from Master List if available
        const posVal = masterRecord.position || '';
        const areaVal = masterRecord.area || '';

        row.querySelector('[data-field="position"]').value = posVal;
        row.querySelector('[data-field="area"]').value = areaVal;
        
        pendingChange.id = masterRecord.id;
        pendingChange.name = masterRecord.name;
        pendingChange.position = posVal;
        pendingChange.area = areaVal;
        
        // For Security: Ensure fields are visually enabled
        if (currentContract.serviceType === 'SECURITY SERVICES') {
             const strictInputs = row.querySelectorAll('[data-security-field], [data-field="position"], [data-field="area"]');
             strictInputs.forEach(inp => {
                inp.disabled = false;
                inp.classList.remove('bg-gray-100', 'cursor-not-allowed', 'text-gray-400');
                inp.classList.add('bg-transparent', inp.tagName === 'SELECT' ? 'focus:ring-blue-500' : 'focus:ring-1');
             });
        }
        
        if (!isSaved) {
             showNotification(`Employee details auto-filled for ${masterRecord.name}. Click 'Save All Changes' to save this new entry.`, true);
             // Re-trigger conflict check specifically for the autofilled name
             triggerCrossContractCheck(row, masterRecord.name, 'regular');
        }
    } else {
       if (field === 'name' || field === 'position' || field === 'area') {
           newValue = newValue.toUpperCase(); 
           input.value = newValue; 
           pendingChange[field] = newValue;
       } else {
           pendingChange[field] = newValue;
       }
    }

    // ID Regex and Duplicate Check
    if (field === 'id') {
        const cleanId = pendingChange.id; 
        if (cleanId && !PERSONNEL_ID_REGEX.test(cleanId)) {
             showNotification('Personnel ID must contain numbers only.', false);
             input.value = employee.id; 
             return; 
        }
        if (cleanId && isDuplicateId(cleanId, employee.id, employee.no)) { 
            showNotification(`Personnel ID "${cleanId}" is already used in another row (saved or pending).`, false);
            input.value = employee.id; 
            if (row.querySelector('[data-field="name"]')) row.querySelector('[data-field="name"]').value = employee.name; 
            if (row.querySelector('[data-field="position"]')) row.querySelector('[data-field="position"]').value = employee.position; 
            if (row.querySelector('[data-field="area"]')) row.querySelector('[data-field="area"]').value = employee.area;
            
            pendingChange.id = employee.id;
            pendingChange.name = employee.name; 
            pendingChange.position = employee.position; 
            pendingChange.area = employee.area;
            if (employee.id === input.value) delete pendingEmployeeInfoChanges[oldPersonnelKey];
            return; 
        }
    } else if (field === 'name' || field === 'position' || field === 'area') {
        if (!masterRecord) { 
            let cleanedValue = pendingChange[field].toUpperCase(); 
            let regexToUse = (field === 'name') ? /[^A-Z\s.,-]/g : /[^A-Z0-9\s.,-]/g; 
            cleanedValue = cleanedValue.replace(regexToUse, ''); 
            if (cleanedValue !== pendingChange[field].toUpperCase()) showNotification(`Special characters and/or numbers removed from ${field}.`, false);
            input.value = cleanedValue;
            pendingChange[field] = cleanedValue;
        }

        if (field === 'name' && pendingChange.name === '') {
             const idInput = row.querySelector('[data-field="id"]');
             const positionInput = row.querySelector('[data-field="position"]');
             const areaInput = row.querySelector('[data-field="area"]');
             
             const originalEmployeeId = employee.id.trim(); 
             if (originalEmployeeId !== '') {
                 pendingEmployeeInfoChanges[originalEmployeeId] = {
                    id: originalEmployeeId, name: employee.name, position: employee.position, area: employee.area,
                    isNew: false, originalEmployeeId: originalEmployeeId, isDeleted: true 
                 };
                 showNotification(`Employee ${employee.name} (ID: ${originalEmployeeId}) marked for DELETION.`, true);
                 employee.id = ''; 
                 row.dataset.stableKey = `TEMP_${employee.no}`;
                 delete pendingEmployeeInfoChanges[oldPersonnelKey];
             }

             if (idInput) idInput.value = '';
             if (positionInput) positionInput.value = '';
             if (areaInput) areaInput.value = '';

             pendingChange.id = ''; pendingChange.name = ''; pendingChange.position = ''; pendingChange.area = '';
             pendingChange.isDeleted = false; pendingChange.isNew = true; pendingChange.originalEmployeeId = '';

             const idToClear = originalEmployeeId; 
             if (idToClear) {
                 Object.keys(pendingAttendanceChanges).forEach(key => {
                     if (key.startsWith(idToClear + '_')) delete pendingAttendanceChanges[key];
                 });
             }
             row.querySelectorAll('.cell-container').forEach(cell => {
                  const dayKey = cell.dataset.dayKey;
                  updateCellVisuals(cell, currentContract.planMap[`${originalEmployeeId}_${dayKey}_${cell.dataset.shiftKey}`] || '', dayKey); 
             });
             showNotification('Personnel Name cleared. Slot is now empty.', false);
        }
        
        if (field === 'name' && pendingChange.name) {
            if (isDuplicateName(pendingChange.name, employee.id, employee.no)) {
                showNotification(`FATAL ERROR: Personnel Name "${pendingChange.name}" is already used by another employee.`, false);
                input.value = employee.name; 
                if (row.querySelector('[data-field="id"]')) row.querySelector('[data-field="id"]').value = employee.id; 
                pendingChange.id = employee.id; pendingChange.name = employee.name; 
                if (employee.id === input.value) delete pendingEmployeeInfoChanges[oldPersonnelKey];
                return; 
            }
        }
    }

    // Clearing ID or Name logic
    if (((field === 'id' && pendingChange.id === '') || (field === 'name' && pendingChange.name === '')) && previousIdValue !== '') {
            const idToClear = previousIdValue; 
            if (idToClear) {
                const originalEmployeeId = employee.id.trim();
                if (originalEmployeeId !== '') {
                     pendingEmployeeInfoChanges[originalEmployeeId] = {
                        id: originalEmployeeId, name: employee.name, position: employee.position, area: employee.area,
                        isNew: false, originalEmployeeId: originalEmployeeId, isDeleted: true 
                     };
                     employee.id = ''; row.dataset.stableKey = `TEMP_${employee.no}`;
                     delete pendingEmployeeInfoChanges[oldPersonnelKey];
                }
                
                // Clear ALL inputs visually (ID, Name, Position, Area)
                if (row.querySelector('[data-field="id"]')) row.querySelector('[data-field="id"]').value = ''; // Added explicit ID clear
                if (row.querySelector('[data-field="name"]')) row.querySelector('[data-field="name"]').value = '';
                if (row.querySelector('[data-field="position"]')) row.querySelector('[data-field="position"]').value = '';
                if (row.querySelector('[data-field="area"]')) row.querySelector('[data-field="area"]').value = '';
                
                // Logic for Security Services Row Clearing
                if (currentContract && currentContract.serviceType === 'SECURITY SERVICES') {
                    updateSecurityRowState(row, ''); // Force clear/disable security fields
                    const timeShiftCell = row.querySelector('.shift-colored-cell');
                    if (timeShiftCell) {
                        timeShiftCell.style.removeProperty('background-color');
                        timeShiftCell.classList.remove('shift-colored-cell');
                    }
                }

                pendingChange.id = ''; // Ensure ID is cleared in pending object even if triggered by Name
                pendingChange.name = ''; pendingChange.position = ''; pendingChange.area = '';
                pendingChange.isNew = true; pendingChange.originalEmployeeId = '';

                Object.keys(pendingAttendanceChanges).forEach(key => {
                    if (key.startsWith(idToClear + '_')) delete pendingAttendanceChanges[key];
                });
                row.querySelectorAll('.cell-container').forEach(cell => {
                     const dayKey = cell.dataset.dayKey;
                     updateCellVisuals(cell, currentContract.planMap[`${idToClear}_${dayKey}_${cell.dataset.shiftKey}`] || '', dayKey); 
                });
                showNotification('Personnel info cleared.', false);
                checkPlanSheetLockState(); 
            }
    }
    
    // Signatory Autofill
    const preparedByNameInput = document.getElementById('signatory-prepared-by');
    const preparedByDesignationInput = document.getElementById('signatory-prepared-by-designation');
    if (preparedByNameInput && preparedByNameInput.value.toUpperCase() === newValue.toUpperCase()) {
        const emp = employeeMasterList.find(e => e.name.toUpperCase() === newValue.toUpperCase());
        const currentDesignationUI = preparedByDesignationInput ? preparedByDesignationInput.value.trim() : '';
        if (emp) {
            selectedSignatories.preparedBy.name = emp.name;
            if (currentDesignationUI === '' || emp.position !== '') {
                selectedSignatories.preparedBy.designation = emp.position;
                if (preparedByDesignationInput) preparedByDesignationInput.value = emp.position;
            }
        } else {
            selectedSignatories.preparedBy.name = newValue;
            if (newValue === '') {
                selectedSignatories.preparedBy.designation = '';
                if (preparedByDesignationInput) preparedByDesignationInput.value = '';
            }
        }
    }
    
    const isChanged = (pendingChange.id.trim() !== employee.id || pendingChange.name.trim() !== employee.name || 
                       pendingChange.position.trim() !== employee.position || pendingChange.area.trim() !== employee.area ||
                       (pendingChange.originalEmployeeId === '' && pendingChange.id.trim() !== '')); 

    if (isChanged) {
        pendingEmployeeInfoChanges[oldPersonnelKey] = pendingChange;
    } else {
        delete pendingEmployeeInfoChanges[oldPersonnelKey];
        if ((field === 'id' || field === 'name') && employee.id !== '') {
            Object.keys(pendingAttendanceChanges).forEach(key => {
                if (key.startsWith(employee.id + '_')) delete pendingAttendanceChanges[key];
            });
            row.querySelectorAll('.cell-container').forEach(cell => {
                 const dayKey = cell.dataset.dayKey;
                 updateCellVisuals(cell, currentContract.planMap[`${employee.id}_${dayKey}_${cell.dataset.shiftKey}`] || '', dayKey); 
            });
        }
    }
}

  // --- ATTENDANCE PLAN HANDLERS (Manual Save) ---
  function updateCellVisuals(cell, status, dayKey) {
    const dayOfMonth = new Date(dayKey);
    const dayOfWeek = dayOfMonth.getDay(); 

    const isDeletedRow = cell.closest('tr').classList.contains('line-through');
    const isLockedRow = cell.closest('tr').classList.contains('locked-row');
    
    const isSelected = bulkSelectedCells.includes(cell);
    const isCellLocked = isLockedRow || isDeletedRow;
    const cursorClass = isCellLocked ? 'cursor-not-allowed' : (isBulkSelectionMode ? 'cursor-crosshair' : 'cursor-pointer');
    
    cell.className = `cell-container text-center border-r border-b transition duration-100 ease-in-out ${cursorClass} ${isSelected ? 'cell-selected' : ''}`;
    
    cell.innerHTML = `<div class="p-2 h-full w-full flex items-center justify-center text-sm font-medium attendance-cell-bg">${status}</div>`;
    const innerDiv = cell.querySelector('.attendance-cell-bg');

    let bgColor = 'bg-white';
    let textColor = 'text-gray-900';
    let isWork = false;

    if (status.length > 0) {
      if (status === 'RD') {
        bgColor = 'status-rd';
        textColor = 'text-red-700 font-bold';
      } else if (status === 'RH') {
        bgColor = 'status-rh';
        textColor = 'text-blue-700 font-bold';
      } else if (status === 'SH') {
        bgColor = 'status-sh';
        textColor = 'text-yellow-700 font-bold';
        isWork = true;
      } else if (status === 'NA') { 
        bgColor = 'status-na'; 
        textColor = 'text-gray-500 font-bold';
      } else {
        bgColor = 'status-work';
        textColor = 'text-green-700 font-bold';
        isWork = true;
      }
    } else {
      bgColor = 'bg-gray-100';
      textColor = 'text-gray-500';
    }
    
    if (!isWork && !status && (dayOfWeek === 0 || dayOfWeek === 6)) {
        bgColor = 'bg-gray-200'; 
    }
    
    if (isDeletedRow) {
        bgColor = 'bg-red-300';
        textColor = 'text-red-500';
        innerDiv.textContent = 'DELETED';
    } else if (isLockedRow) { 
        bgColor = 'bg-gray-400';
        textColor = 'text-gray-700';
        innerDiv.textContent = status || 'LOCKED';
    }
    
     innerDiv.className = `p-2 h-full w-full flex items-center justify-center text-sm font-medium attendance-cell-bg ${bgColor} ${textColor}`;
  }


  function handleCellClick(event) {
    if (isBulkSelectionMode) return; 
    
    const targetCell = event.currentTarget;
    const row = targetCell.closest('tr'); 
    
    const isCellLocked = row.classList.contains('line-through') || row.classList.contains('locked-row');
    if (isCellLocked) {
        const originalId = targetCell.dataset.originalId || '';
        showNotification('Cannot edit: This employee\'s schedule has been printed and locked (Ref #'+ lockedIdRefMap[originalId] +').', false);
        return;
    }
    
    const idInput = row.querySelector('[data-field="id"]');
    const personnelId = (idInput?.value || '').trim(); 
    
    const originalId = (targetCell.dataset.originalId || '').trim(); 
    const dayKey = targetCell.dataset.dayKey;
    const shiftKey = targetCell.dataset.shiftKey;
    
    if (!personnelId || !PERSONNEL_ID_REGEX.test(personnelId)) { 
        showNotification('Cannot edit: Personnel ID is either empty or invalid (must be numbers only). Please correct the ID field first.', false);
        return;
    }

    const planKey = `${personnelId}_${dayKey}_${shiftKey}`;
    
    const currentStatus = pendingAttendanceChanges[planKey] !== undefined 
                          ? pendingAttendanceChanges[planKey] 
                          : currentContract.planMap[`${originalId}_${dayKey}_${shiftKey}`] || '';

    selectedCellData = {
      personnelId, 
      originalId,  
      dayKey,
      shiftKey,
      cellElement: targetCell
    };

    const modal = document.getElementById('floating-status-modal');
    const inputStartTime = document.getElementById('schedule-start-time');
    const inputEndTime = document.getElementById('schedule-end-time');
    
    const fixedOptionsContainer = document.getElementById('fixed-status-options-container');

    fixedOptionsContainer.innerHTML = '';
    
    fixedStatusOptions.forEach(option => {
        const button = document.createElement('button');
        button.type = 'button';
        button.textContent = option.label;
        button.value = option.value;
        button.className = `w-full px-4 py-2 text-sm rounded-lg border hover:shadow-md transition duration-150 ${option.color} ${option.value === currentStatus ? 'bg-opacity-70 border-2 border-blue-500' : 'bg-opacity-50 border-gray-300'}`;
        button.addEventListener('click', (e) => saveSchedule(e, option.value));
        fixedOptionsContainer.appendChild(button);
    });
    
    // 1. Clear and Populate Dropdowns
    inputStartTime.innerHTML = '<option value="">-- Start Time --</option>';
    inputEndTime.innerHTML = '<option value="">-- End Time --</option>';

    TIME_OPTIONS.forEach(time => {
        let optionStart = document.createElement('option');
        optionStart.value = time;
        optionStart.textContent = time;
        inputStartTime.appendChild(optionStart);
        
        let optionEnd = document.createElement('option');
        optionEnd.value = time;
        optionEnd.textContent = time;
        inputEndTime.appendChild(optionEnd);
    });


    // 2. Set Selected Values
    if (currentStatus && !fixedStatusCodes.includes(currentStatus)) {
        const parts = currentStatus.split('-');
        inputStartTime.value = parts[0] || '';
        inputEndTime.value = parts[1] || '';
    } else {
        inputStartTime.value = '';
        inputEndTime.value = '';
    }

    modal.classList.remove('hidden');
    inputStartTime.focus(); 
  }
  
  document.getElementById('cancel-status-btn').addEventListener('click', () => {
      document.getElementById('floating-status-modal').classList.add('hidden');
  });
  
  document.getElementById('save-schedule-btn').addEventListener('click', (event) => {
      saveSchedule(event, null); 
  });


  function saveSchedule(event, fixedStatusValue) {
    document.getElementById('floating-status-modal').classList.add('hidden');
    
    if (!selectedCellData.personnelId && !selectedCellData.originalId) return; 

    const { personnelId, originalId, dayKey, shiftKey, cellElement } = selectedCellData;
    
    if (lockedIdRefMap[originalId]) {
        showNotification('Cannot save: This employee\'s schedule has been printed and locked (Ref #'+ lockedIdRefMap[originalId] +').', false);
        return;
    }

    let finalStatus;
    
    if (event.type === 'click' && fixedStatusValue !== null) {
        finalStatus = fixedStatusValue;
    } else {
        const inputStartTime = document.getElementById('schedule-start-time').value.trim();
        const inputEndTime = document.getElementById('schedule-end-time').value.trim();

        if (inputStartTime && inputEndTime) {
            finalStatus = `${inputStartTime}-${inputEndTime}`;
        } else if (inputStartTime || inputEndTime) {
            showNotification('Please select both start and end times, or use the fixed status buttons.', false); 
            setTimeout(() => handleCellClick({ currentTarget: selectedCellData.cellElement }), 100); 
            return;
        } else {
            finalStatus = '';
        }
    }
    
    if (!personnelId) {
        showNotification('Cannot save plan: Personnel ID is missing for this row.', false);
        return;
    }

    if (!fixedStatusCodes.includes(finalStatus) && finalStatus.length > 0) {
        if (!TIME_FORMAT_REGEX.test(finalStatus)) {
             showNotification('Invalid schedule format detected. Use format like "8AM-5PM" or "8:30AM-5:30PM".', false);
             setTimeout(() => handleCellClick({ currentTarget: selectedCellData.cellElement }), 100); 
             return;
        }
    }

    const currentPlanKey = `${personnelId}_${dayKey}_${shiftKey}`;
    const originalPlanKey = `${originalId}_${dayKey}_${shiftKey}`;

    const originalStatus = currentContract.planMap[originalPlanKey] || '';

    if (originalStatus !== finalStatus) {
        pendingAttendanceChanges[currentPlanKey] = finalStatus; 
    } else {
        delete pendingAttendanceChanges[currentPlanKey];
    }
    
    updateCellVisuals(cellElement, finalStatus, dayKey);
    
    showNotification('Change saved locally. Click "Save All Changes" to save to Sheets.', true);
    
    checkPlanSheetLockState(); 
  }
  
  // *** NEW FUNCTION: Handles the first part of the saving process (getting the batch number) ***
function handleSaveAllChanges() {
    const sfcRefToSave = currentContract ? currentContract.sfcRef : null;
    const currentYear = currentPlanningDate.getFullYear();
    const currentMonth = currentPlanningDate.getMonth();
    const currentShift = document.getElementById('shift-period-select').value;
    
    const empChangesCount = Object.keys(pendingEmployeeInfoChanges).length;
    const attChangesCount = Object.keys(pendingAttendanceChanges).length;
    const relieverChangesCount = Object.keys(pendingRelieverChanges).length; // NEW

    if (empChangesCount === 0 && attChangesCount === 0 && relieverChangesCount === 0) {
        showNotification('No changes detected to save.', false);
        return;
    }
    
    toggleLoading(true, 'Preparing save batch. Checking for next available Save Group ID...'); 

    // 1. Get the next available Save Group Number from the server (e.g., S1, S2)
    google.script.run
        .withSuccessHandler(function(groupNumber) {
             // 2. Directly call continueSaveProcess.
             continueSaveProcess(groupNumber); 
        })
        .withFailureHandler(handleSaveAllError)
        .getNextGroupNumber(sfcRefToSave, currentYear, currentMonth, currentShift);
  }

// *** NEW FUNCTION: Continues the saving process after the batch number is determined (UPDATED FOR RELIEVERS) ***
function continueSaveProcess(groupNumber) {
    const sfcRefToSave = currentContract ? currentContract.sfcRef : null;
    const currentYear = currentPlanningDate.getFullYear();
    const currentMonth = currentPlanningDate.getMonth();
    const currentShift = document.getElementById('shift-period-select').value;
    
    // --- START: Validation and Data Assembly for REGULAR EMPLOYEES ---
    
    const finalEmpChanges = [];
    const empChanges = Object.keys(pendingEmployeeInfoChanges)
    .filter(stableKey => { 
        const change = pendingEmployeeInfoChanges[stableKey];
        const isUnsavedNewRow = change.originalEmployeeId === '';
        
        // Skip entirely empty new rows that were never filled
        const isNewAndEmpty = isUnsavedNewRow && 
                              !change.isDeleted && 
                              !change.id.trim() && !change.name.trim() && 
                              !change.position.trim() && !change.area.trim();
                              
        return !isNewAndEmpty;
    }) 
    .map(stableKey => {
        const change = pendingEmployeeInfoChanges[stableKey];
        const isMasterEmployee = employeeMasterList.some(masterEmp => masterEmp.id === change.id.trim());
        const isExistingEmployeeAdded = change.originalEmployeeId === '' && isMasterEmployee; 
        
        return {
            oldPersonnelId: change.originalEmployeeId, 
            id: change.id.trim(), 
            name: change.name.trim(), 
            position: change.position.trim(), 
            area: change.area.trim(), 
            isNew: change.originalEmployeeId === '', 
            isDeleted: change.isDeleted || false, 
            isExistingEmployeeAdded: isExistingEmployeeAdded 
        };
    });
    
    empChanges.forEach(e => {
        // Only push if it's a valid change (Deletion, New, or Existing added)
        if (e.isDeleted) {
            finalEmpChanges.push(e); 
        } else if (e.isExistingEmployeeAdded || e.isNew) {
             if (e.id !== '' && e.name !== '' && e.position !== '' && e.area !== '') {
                 finalEmpChanges.push(e);
             }
        }
    });

    // --- START: Validation and Data Assembly for RELIEVER EMPLOYEES ---
    const finalRelieverChanges = [];
    const relieverStableKeys = Object.keys(pendingRelieverChanges);
    
    for (const stableKey of relieverStableKeys) {
         const change = pendingRelieverChanges[stableKey];
         
         // 1. Handle Deletion
         if (change.isDeleted) {
             finalRelieverChanges.push({
                 id: change.id.trim(), 
                 name: change.name.trim(), 
                 position: 'RELIEVER',
                 area: 'RELIEVER',
                 isNew: false, 
                 isDeleted: true,
                 oldPersonnelId: change.id.trim()
             });
         }
         // 2. Handle New Entry
         else if (change.id.trim() !== '' && change.name.trim() !== '') {
             
             if (change.position.trim() !== 'RELIEVER' || change.area.trim() !== 'RELIEVER') {
                  showNotification(`FATAL ERROR: Cannot save reliever (ID: ${change.id}). Position and Area were not set to 'RELIEVER'.`, false);
                  toggleLoading(false);
                  return; 
             }
             
             finalRelieverChanges.push({
                 id: change.id.trim(), 
                 name: change.name.trim(), 
                 position: 'RELIEVER', 
                 area: 'RELIEVER',     
                 isNew: true,
                 isDeleted: false,
                 oldPersonnelId: ''
             });
         }
    }

    // --- START: SECURITY DATA GATHERING ---
    const securityDetails = [];
    if (currentContract.serviceType === 'SECURITY SERVICES') {
        const rows = document.querySelectorAll('#attendance-table-container tbody tr');
        rows.forEach(row => {
            if (row.classList.contains('line-through')) return;

            const idInput = row.querySelector('[data-field="id"]');
            const nameInput = row.querySelector('[data-field="name"]');
            const personnelId = (idInput?.value || '').trim();
            const personnelName = (nameInput?.value || '').toUpperCase().trim(); 

            if (personnelId || personnelName) { // Capture if either ID or Name exists
                const timeShift = row.querySelector('[data-security-field="timeOfShift"]')?.value || '';
                
                const faType = (row.querySelector('[data-security-field="faType"]')?.value || '').toUpperCase().trim();
                const faMake = (row.querySelector('[data-security-field="faMake"]')?.value || '').toUpperCase().trim();
                const faCal = (row.querySelector('[data-security-field="faCaliber"]')?.value || '').toUpperCase().trim();
                const faSerial = (row.querySelector('[data-security-field="faSerial"]')?.value || '').toUpperCase().trim();
                
                const valid = row.querySelector('[data-security-field="licenseValidity"]')?.value || '';

                securityDetails.push({
                    id: personnelId,
                    name: personnelName,
                    timeOfShift: timeShift,
                    faType: faType,
                    faMake: faMake,
                    faCaliber: faCal,
                    faSerial: faSerial,
                    licenseValidity: valid
                });
            }
        });
    }

    // === NEW: STRICT SECURITY VALIDATION (Name, Designation, Location, Time, AND FIREARMS) ===
    if (currentContract.serviceType === 'SECURITY SERVICES') {
        const securityRows = document.querySelectorAll('#attendance-table-container tbody tr');
        
        for (const row of securityRows) {
            // Skip rows marked for deletion
            if (row.classList.contains('line-through')) continue;

            const nameInput = row.querySelector('[data-field="name"]');
            const name = (nameInput?.value || '').trim();

            // Only validate active rows (those with a name)
            if (name) {
                // 1. Basic Security Fields Validation
                const designationInput = row.querySelector('[data-field="position"]');
                const locationInput = row.querySelector('[data-field="area"]');
                const shiftInput = row.querySelector('[data-security-field="timeOfShift"]');

                const designation = (designationInput?.value || '').trim();
                const location = (locationInput?.value || '').trim();
                const timeOfShift = (shiftInput?.value || '').trim();
                
                let missingFields = [];
                if (!designation) missingFields.push("Designation");
                if (!location) missingFields.push("Place of Duty (Location)");
                if (!timeOfShift) missingFields.push("Time of Shift");

                if (missingFields.length > 0) {
                     const rowNo = row.querySelector('td:first-child')?.textContent.trim();
                     showNotification(`FATAL ERROR: Cannot save. Security Guard "${name}" (Row ${rowNo}) is missing required fields: ${missingFields.join(', ')}.`, false);
                     toggleLoading(false);
                     return; // STOP SAVE
                }

                // 2. NEW: Firearm Details Validation 
                const typeInput = row.querySelector('[data-security-field="faType"]');
                const faType = (typeInput?.value || '').trim();

                if (faType) {
                    const makeInput = row.querySelector('[data-security-field="faMake"]');
                    const caliberInput = row.querySelector('[data-security-field="faCaliber"]');
                    const serialInput = row.querySelector('[data-security-field="faSerial"]');
                    const validityInput = row.querySelector('[data-security-field="licenseValidity"]');

                    const faMake = (makeInput?.value || '').trim();
                    const faCaliber = (caliberInput?.value || '').trim();
                    const faSerial = (serialInput?.value || '').trim();
                    const validity = (validityInput?.value || '').trim();

                    let missingFirearmFields = [];
                    if (!faMake) missingFirearmFields.push("Make");
                    if (!faCaliber) missingFirearmFields.push("Caliber");
                    if (!faSerial) missingFirearmFields.push("Serial No.");
                    if (!validity) missingFirearmFields.push("License Validity");

                    if (missingFirearmFields.length > 0) {
                        const rowNo = row.querySelector('td:first-child')?.textContent.trim();
                        showNotification(`FATAL ERROR: Cannot save. Guard "${name}" (Row ${rowNo}) has a Firearm Type (${faType}) but is missing: ${missingFirearmFields.join(', ')}.`, false);
                        toggleLoading(false);
                        return; // STOP SAVE
                    }
                }
            }
        }
    }

    // === CRITICAL 3: FINAL CHECK FOR EMPTY ID/NAME ON ACTIVE ROWS (REGULAR TABLE ONLY) ===
    if (currentContract.serviceType !== 'SECURITY SERVICES') {
        const allRows = document.querySelectorAll('#attendance-table-container tbody tr');
        
        const incompleteRow = Array.from(allRows).find(row => {
            const stableKey = row.dataset.stableKey;
            if (lockedIdRefMap[stableKey] && !pendingEmployeeInfoChanges[stableKey]?.isDeleted) return false;

            const idInput = row.querySelector('[data-field="id"]');
            const nameInput = row.querySelector('[data-field="name"]');
            const positionInput = row.querySelector('[data-field="position"]'); 
            const areaInput = row.querySelector('[data-field="area"]');         

            const displayId = (idInput?.value || '').trim();
            const displayName = (nameInput?.value || '').trim();
            const displayPosition = (positionInput?.value || '').trim();       
            const displayArea = (areaInput?.value || '').trim();               
            
            if (row.classList.contains('line-through')) return false; 
            
            // If row has partial data, ensure it is complete
            if (displayId || displayName || displayPosition || displayArea) {
                 return displayId === '' || 
                        displayName === '' || 
                        displayPosition === '' || 
                        displayArea === '';        
            }
            
            return false; 
        });

        if (incompleteRow) {
            const rowElement = incompleteRow;
            const rowNo = rowElement.querySelector('.sticky-col:first-child > span').textContent.trim();
            
            let missingField = '';
            let idInput = incompleteRow.querySelector('[data-field="id"]');
            let nameInput = incompleteRow.querySelector('[data-field="name"]');

            const displayId = (idInput?.value || '').trim();
            const displayName = (nameInput?.value || '').trim();
            
            if (displayId === '') missingField = 'Personnel ID';
            else if (displayName === '') missingField = 'Personnel Name';
            else if (incompleteRow.querySelector('[data-field="position"]').value.trim() === '') missingField = 'Position';
            else if (incompleteRow.querySelector('[data-field="area"]').value.trim() === '') missingField = 'Area Posting';
            
            const identifier = displayId || displayName ? 
                               `${displayId || displayName}` : 
                               `Row ${rowNo}`;
                               
            showNotification(`FATAL ERROR: Cannot save. ${identifier} is missing a required ${missingField} (Regular Employee). All active employee rows must have all four info fields.`, false);
            toggleLoading(false);
            return; 
        }
    }
   
    // === CRITICAL 2: CHECK FOR BLANK ATTENDANCE COLUMNS (STRICT ALL-OR-NOTHING CHECK) ===
    const rowsToValidate = [];
    
    document.querySelectorAll('#attendance-table-container tbody tr').forEach(row => {
        const stableKey = row.dataset.stableKey;
        
        if (lockedIdRefMap[stableKey] || row.classList.contains('line-through')) return;
        
        const employeeId = row.querySelector('[data-field="id"]')?.value; 
        const displayName = row.querySelector('[data-field="name"]')?.value.trim();
        
        if (!employeeId && !displayName) return; // Skip completely empty rows

        let isCurrentPlanIncomplete = false;
        
        row.querySelectorAll('.cell-container').forEach(cell => {
            const status = cell.querySelector('.attendance-cell-bg').textContent.trim();
            if (status === '') { 
                 isCurrentPlanIncomplete = true;
            }
        });
        
        if (isCurrentPlanIncomplete) {
             rowsToValidate.push({ id: employeeId, name: displayName, stableKey });
        }
    });

    if (rowsToValidate.length > 0) {
        showNotification(`FATAL ERROR: Cannot save. Attendance Plan incomplete for employee: ${rowsToValidate[0].name || 'Unknown'}. All days in the current shift/period must have a status.`, false);
        toggleLoading(false);
        return; 
    }
    // === END CRITICAL 2 CHECK ===

    const attChanges = Object.keys(pendingAttendanceChanges).map(key => {
        const [personnelId, dayKey, shift] = key.split('_');
        return { personnelId, dayKey, shift, status: pendingAttendanceChanges[key] };
    });

    const finalEmpChangesAfterValidation = finalEmpChanges; 

    if (!sfcRefToSave) {
        showNotification('CRITICAL ERROR: Contract data is not loaded. Please select a Contract Group ID and retry.', false);
        toggleLoading(false);
        return;
    }
    
    // 2. Prepare Contract Info 
    const contractInfo = {
        payor: currentContract.payorCompany,
        agency: currentContract.agency,
        serviceType: currentContract.serviceType,
        headCount: currentContract.headCount,
        propOrGrpCode: currentContract.propOrGrpCode, 
        sector: currentContract.sector
    };
    
    // 3. Final Save Call
    toggleUiLock(true, 'Saving all changes to Google Sheets. Please wait...');
    google.script.run
        .withSuccessHandler(handleSaveAllSuccess)
        .withFailureHandler(handleSaveAllError)
        .saveAllData(sfcRefToSave, contractInfo, finalEmpChangesAfterValidation, finalRelieverChanges, attChanges, securityDetails, currentYear, currentMonth, currentShift, groupNumber);
}

  function handleSaveAllSuccess(response) {
      showNotification('All changes saved successfully! Refreshing data...', true);
      pendingAttendanceChanges = {}; 
      pendingEmployeeInfoChanges = {}; 
      pendingRelieverChanges = {}; // NEW: Clear reliever changes
      
      if (currentContract && currentContract.sfcRef) {
          fetchEmployeeMasterData(currentContract.sfcRef);
      }
      
      reloadPlanAndCheckExistence(); 
      toggleUiLock(false); 
  }

  function handleSaveAllError(error) {
       console.error("SAVE ALL ERROR:", error);
       showNotification(`FATAL SAVE ERROR: ${error.message || 'An unknown error occurred in the script.'}`, false);
       toggleLoading(false); 
  }
  
  // --- NEW FUNCTION: DYNAMIC ROW FILTERING ---
  function filterEmptyScheduleRows() {
    const rowsToHide = [];
    const gridRows = document.querySelectorAll('#attendance-table-container tbody tr');

    gridRows.forEach(row => {
        const isMarkedForDeletion = row.classList.contains('line-through');
        const isAlreadyBlank = row.classList.contains('print-empty-row');
        
        if (isMarkedForDeletion || isAlreadyBlank) return; 

        const idInput = row.querySelector('[data-field="id"]');
        const nameInput = row.querySelector('[data-field="name"]');
        const displayId = (idInput?.value || '').trim();
        const displayName = (nameInput?.value || '').trim();
        
        if (!displayId && !displayName) return; 

        let hasValidSchedule = false; 
        row.querySelectorAll('.cell-container').forEach(cell => {
            const status = cell.querySelector('.attendance-cell-bg').textContent.trim();
            if (status !== '' && status !== 'NA' && status !== 'DELETED') { 
                hasValidSchedule = true;
            }
        });
        
        const stableKey = row.dataset.stableKey;
        const isLocked = !!lockedIdRefMap[stableKey];
        
        if (!hasValidSchedule && !isLocked) {
             row.classList.add('print-hidden'); 
             rowsToHide.push(row);
        }
    });
    return rowsToHide;
  }
  
  // --- NEW FUNCTION: Sequential Numbering and Hiding ---
  function applySequentialPrintNumberingAndHiding(dynamicallyHiddenRows, selectedPrintIds) {
    let printNumber = 1;
    const gridRows = document.querySelectorAll('#attendance-table-container tbody tr');
    
    // KUNIN ANG SERVICE TYPE
    const isSecurity = currentContract && currentContract.serviceType === 'SECURITY SERVICES';

    gridRows.forEach(row => {
        
        // A. Rows marked for Deletion or already blank placeholders
        if (row.classList.contains('line-through') || row.classList.contains('print-empty-row')) {
            row.classList.add('print-hidden');
            return;
        }

        const idInput = row.querySelector('[data-field="id"]');
        const displayId = (idInput?.value || '').trim();

        if (!displayId) { 
             row.classList.add('print-hidden');
             return;
        }
        
        // --- Logic: Check if ID is in the selectedPrintIds list ---
        if (!selectedPrintIds.includes(displayId)) {
             row.classList.add('print-hidden');
             dynamicallyHiddenRows.push(row); 
             return;
        }

        // B. Exclude rows that are already Locked 
        const stableKey = row.dataset.stableKey;
        const isLocked = !!lockedIdRefMap[stableKey];
        
        if (isLocked) {
            row.classList.add('print-hidden');
            dynamicallyHiddenRows.push(row);
            return;
        }
        
        // C. Check for NA/Blank Exclusion (UPDATED FOR SECURITY)
        let hasActualSchedule = false;

        if (isSecurity) {
            // *** SECURITY FIX: Check Time of Shift instead of Cells ***
            const timeShiftInput = row.querySelector('[data-security-field="timeOfShift"]');
            if (timeShiftInput && timeShiftInput.value.trim() !== '') {
                hasActualSchedule = true;
            }
        } else {
            // *** STANDARD LOGIC: Check Cells ***
            row.querySelectorAll('.cell-container').forEach(cell => {
                const status = cell.querySelector('.attendance-cell-bg').textContent.trim();
                if (status !== '' && status !== 'NA' && status !== 'DELETED') { 
                    hasActualSchedule = true;
                }
            });
        }

        if (!hasActualSchedule) { 
            // Kung walang schedule, itago sa print
            row.classList.add('print-hidden');
            dynamicallyHiddenRows.push(row); 
            return;
        }

        // --- 2. Apply sequential numbering to rows NOT excluded ---
        const noCellSpan = row.querySelector('.sticky-col:first-child > span:first-child'); // Standard has span inside
        // Security usually renders NO. directly in TD, but let's check structure
        const firstTd = row.querySelector('td:first-child');
        
        if (!row.classList.contains('print-hidden')) {
            // Update numbering visuals
            if (noCellSpan) {
                noCellSpan.textContent = printNumber;
            } else if (firstTd) {
                // Fallback specifically for Security Table structure if strictly TD text
                firstTd.textContent = printNumber;
            }
            printNumber++;
        }
    });
    
    return dynamicallyHiddenRows; 
  }
  
  // --- NEW FUNCTION: Signatory Input Handler (Name) ---
  function handleSignatoryInputChange(event, fieldType, index = null) {
      const input = event.target;
      let newValue = input.value.toUpperCase(); 

      let cleanedValue = newValue.replace(SAFE_NAME_REGEX, '');
      input.value = cleanedValue; 

      // 1. Update the state (name field)
      let targetSignatory;
      if (fieldType === 'checkedBy' && index !== null) {
          targetSignatory = selectedSignatories.checkedBy[index];
          targetSignatory.name = cleanedValue;
      } else {
          targetSignatory = selectedSignatories[fieldType];
          targetSignatory.name = cleanedValue;
      }

      if (newValue !== cleanedValue) {
          showNotification(`Only letters, spaces, commas, periods, and dashes are allowed in names. Invalid characters removed.`, false);
      }
      
      // 2. Auto-fill Designation/Position based on NAME input
      let designation = '';
      
      if (fieldType === 'preparedBy') {
          // Prepared By designation comes from Employee Position (master list)
          const emp = employeeMasterList.find(e => e.name.toUpperCase() === cleanedValue);
          designation = emp ? emp.position : '';
      } else {
          // Approved By / Checked By designation comes from Signatory Master List
          const masterEntry = signatoryMasterList.find(item => item.name.toUpperCase() === cleanedValue);
          designation = masterEntry ? masterEntry.designation : '';
      }

      // 3. Update the state (designation field) and UI, but DO NOT OVERWRITE if user already manually typed something.
      const designationInputId = fieldType === 'preparedBy' 
          ? 'signatory-prepared-by-designation' 
          : (fieldType === 'approvedBy' ? 'signatory-approved-by-designation' : `signatory-checked-by-${index}-designation`);
      
      const designationInput = document.getElementById(designationInputId);

      // Check if the current name input is blank (clear both name/designation state/UI)
      if (cleanedValue === '') {
          targetSignatory.designation = '';
          if (designationInput) designationInput.value = '';
          return;
      }
      
      // Check if a master record was found OR if the current designation in the UI is blank
      const designationCurrentUI = designationInput ? designationInput.value.trim() : '';

      if (designation !== '' || designationCurrentUI === '') {
          targetSignatory.designation = designation;
          if (designationInput) designationInput.value = designation;
      } else {
          // Keep the manually typed designation in the state
          targetSignatory.designation = designationCurrentUI;
      }
  }
  
  // --- NEW FUNCTION: Signatory Designation Input Handler (Designation) ---
  function handleSignatoryDesignationChange(event, fieldType, index = null) {
      const input = event.target;
      let newValue = input.value.toUpperCase().trim(); 

      // 1. Update the state (designation field)
      if (fieldType === 'checkedBy' && index !== null) {
          selectedSignatories.checkedBy[index].designation = newValue;
      } else {
          selectedSignatories[fieldType].designation = newValue;
      }
  }
  
  // --- NEW FUNCTION: Validation check for all signatories ---
  function validateAllSignatories() {
      
      const preparedBy = selectedSignatories.preparedBy.name.trim();
      const preparedByDesignation = selectedSignatories.preparedBy.designation.trim();
      
      if (!preparedBy) {
          return "Prepared By name is required.";
      }
      if (!preparedByDesignation) {
           // UPDATED MESSAGE: Now that it's editable, the user just needs to fill it.
           return "Prepared By Position/Designation is required. Please fill in the Designation/Position field.";
      }
      
      const approvedBy = selectedSignatories.approvedBy.name.trim();
      const approvedByDesignation = selectedSignatories.approvedBy.designation.trim();
      
      if (!approvedBy || !approvedBy.match(SIGNATORY_REGEX)) {
          return "Approved By name is required and must contain only letters, spaces, commas, periods, or dashes.";
      }
      if (!approvedByDesignation) {
          return "Approved By Designation is required. Please fill in the Designation field.";
      }
      
      const checkedByList = selectedSignatories.checkedBy.filter(item => item.name.trim() !== '');
      if (checkedByList.length === 0) {
          return "At least one name for 'Checked By' is required.";
      }
      
      for (const item of checkedByList) {
          if (!item.name.match(SIGNATORY_REGEX)) {
              return `Checked By name "${item.name}" has invalid characters. Only letters, spaces, commas, periods, or dashes are allowed.`;
          }
          if (!item.designation) {
              return `Checked By name "${item.name}" is missing a Designation. Please fill in the Designation field.`;
          }
      }

      return null; 
  }

// --- NEW FUNCTION: Get the list of all printable employees (with schedules and unlocked) ---
function getPrintableEmployeesForModal() {
    const printableList = [];
    const gridRows = document.querySelectorAll('#attendance-table-container tbody tr');
    const currentShift = document.getElementById('shift-period-select').value;
    
    gridRows.forEach(row => {
        if (row.classList.contains('line-through') || row.classList.contains('print-empty-row')) return;
        
        const idInput = row.querySelector('[data-field="id"]');
        const nameInput = row.querySelector('[data-field="name"]');
        const personnelId = (idInput?.value || '').trim();
        const personnelName = (nameInput?.value || '').trim();
        
        if (!personnelId || !personnelName) return; 

        const { isPrintable } = getRowScheduleStatus(row, currentShift);
        const isLocked = !!lockedIdRefMap[personnelId];
        const isSelected = bulkPrintSelected.includes(personnelId);

        if (isPrintable && !isLocked) {
            printableList.push({
                id: personnelId,
                name: personnelName,
                isSelected: isSelected
            });
        }
    });

    return printableList;
}

// --- NEW FUNCTION: Open the Print Selection Modal ---
function openPrintSelectionModal() {
    const empChangesCount = Object.keys(pendingEmployeeInfoChanges).length;
    const attChangesCount = Object.keys(pendingAttendanceChanges).length;
    
    if (empChangesCount > 0 || attChangesCount > 0) {
        showNotification(`Saving required: ${empChangesCount} employee changes and ${attChangesCount} schedule changes are pending. Click "Save All Changes to Sheets" first.`, false);
        return;
    }
    
    const printableEmployees = getPrintableEmployeesForModal();
    const listContainer = document.getElementById('printable-employee-list-container');
    const modal = document.getElementById('print-selection-modal');
    const selectAllCheckbox = document.getElementById('select-all-print');
    
    // Check if there are any printable schedules at all
    if (printableEmployees.length === 0) {
        showNotification('Cannot print: No employee data with an **actual schedule** found that is not already locked.', false);
        return;
    }

    listContainer.innerHTML = '';
    
    printableEmployees.forEach(emp => {
        const listItem = document.createElement('li');
        const itemBgClass = emp.isSelected ? 'bg-blue-50 border-blue-400' : 'bg-gray-50 border-gray-200';
        
        listItem.className = `flex items-center space-x-3 p-2 rounded-lg border hover:bg-blue-50 transition duration-150 cursor-pointer ${itemBgClass}`;
        
        listItem.innerHTML = `
            <input type="checkbox" id="print-check-${emp.id}" 
                   data-id="${emp.id}" 
                   data-name="${emp.name}"
                   class="print-checkbox h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500" 
                   ${emp.isSelected ? 'checked' : ''}>
            <label for="print-check-${emp.id}" class="flex-grow text-sm font-medium text-gray-800">
                <span class="font-bold">${emp.name}</span> 
                <span class="text-xs text-gray-500">(ID: ${emp.id})</span>
            </label>
        `;
        
        const checkbox = listItem.querySelector('.print-checkbox');
        checkbox.addEventListener('change', (e) => {
            updateBulkPrintSelection(e);
            listItem.classList.toggle('bg-blue-50', e.target.checked);
            listItem.classList.toggle('border-blue-400', e.target.checked);
            listItem.classList.toggle('bg-gray-50', !e.target.checked);
            listItem.classList.toggle('border-gray-200', !e.target.checked);
        });
        
        // Add listener to the whole list item to toggle the checkbox
        listItem.addEventListener('click', (e) => {
            if (e.target.tagName !== 'INPUT') {
                checkbox.checked = !checkbox.checked;
                checkbox.dispatchEvent(new Event('change'));
            }
        });
        
        listContainer.appendChild(listItem);
    });

    // Initialize/Update the bulkPrintSelected array from rendered checkboxes
    bulkPrintSelected = printableEmployees.filter(emp => emp.isSelected).map(emp => emp.id);
    
    // Update Select All Checkbox state
    const totalPrintable = printableEmployees.length;
    selectAllCheckbox.checked = (totalPrintable > 0 && bulkPrintSelected.length === totalPrintable);
    
    // Attach Select All listener
    selectAllCheckbox.removeEventListener('change', toggleSelectAllPrint);
    selectAllCheckbox.addEventListener('change', toggleSelectAllPrint);

    updatePrintModalState(totalPrintable);

    document.getElementById('print-select-cancel-btn').onclick = () => modal.classList.add('hidden');
    // On confirm, proceed to the Signatory/Sub Property modal
    document.getElementById('print-select-confirm-btn').onclick = () => {
        modal.classList.add('hidden');
        openPrintSetupModal(); // Proceed to the next step
    };

    modal.classList.remove('hidden');
}

// Helper to update count display and button enablement
function updatePrintModalState(totalPrintable) {
    const count = bulkPrintSelected.length;
    
    document.getElementById('print-selection-count').textContent = count;
    document.getElementById('print-select-confirm-btn').disabled = count === 0;
    document.getElementById('print-select-confirm-btn').textContent = `Proceed to Print Setup (${count} Selected)`;
    
    document.getElementById('total-printable-count').textContent = totalPrintable || '0';
}

// Helper to update global array and modal state on checkbox change
function updateBulkPrintSelection(event) {
    const checkbox = event.target;
    const id = checkbox.dataset.id;
    const isChecked = checkbox.checked;

    const existingIndex = bulkPrintSelected.indexOf(id);

    if (isChecked && existingIndex === -1) {
        bulkPrintSelected.push(id);
    } else if (!isChecked && existingIndex > -1) {
        bulkPrintSelected.splice(existingIndex, 1);
    }
    
    const printableCount = getPrintableEmployeesForModal().length;
    const selectAllCheckbox = document.getElementById('select-all-print');

    if (selectAllCheckbox) {
        selectAllCheckbox.checked = (bulkPrintSelected.length === printableCount);
    }
    
    updatePrintModalState(printableCount);
}

// Helper for select all/none in the Print Selection Modal
function toggleSelectAllPrint(event) {
    const isChecked = event.target.checked;
    const checkboxes = document.querySelectorAll('#printable-employee-list-container .print-checkbox');
    
    bulkPrintSelected = []; 

    checkboxes.forEach(checkbox => {
        checkbox.checked = isChecked;
        
        const id = checkbox.dataset.id;
        const listItem = checkbox.closest('li');
        
        if (isChecked) {
            bulkPrintSelected.push(id);
            listItem.classList.add('bg-blue-50', 'border-blue-400');
            listItem.classList.remove('bg-gray-50', 'border-gray-200');
        } else {
            listItem.classList.remove('bg-blue-50', 'border-blue-400');
            listItem.classList.add('bg-gray-50', 'border-gray-200');
        }
    });
    
    updatePrintModalState(getPrintableEmployeesForModal().length);
}

  // --- NEW PRINT LOGIC (UPDATED FLOW) ---
function openPrintSetupModal() {
      const isSecurity = currentContract && currentContract.serviceType === 'SECURITY SERVICES';

      // Toggle Fields Visibility
      const standardFields = document.getElementById('standard-print-fields');
      const securityFields = document.getElementById('security-print-fields');

      if (isSecurity) {
          standardFields.classList.add('hidden');
          securityFields.classList.remove('hidden');
          
          const agencyNameInput = document.getElementById('agency-name-input');
          const agencyAddressInput = document.getElementById('agency-address-input');
          const agencyTelInput = document.getElementById('agency-tel-input');
          const agencyEmailInput = document.getElementById('agency-email-input');

          const currentAgencyName = currentContract.agency || '';
          agencyNameInput.value = selectedPrintFields.agencyName || currentAgencyName;
          
          agencyTelInput.value = selectedPrintFields.agencyTel || '';
          agencyEmailInput.value = selectedPrintFields.agencyEmail || '';

          if (!selectedPrintFields.agencyAddress) {
              agencyAddressInput.value = 'Loading address...';
              agencyAddressInput.disabled = true;

              google.script.run
                .withSuccessHandler((address) => {
                    agencyAddressInput.value = address;
                    agencyAddressInput.disabled = false;
                    // Auto-save to state
                    selectedPrintFields.agencyAddress = address;
                })
                .withFailureHandler(() => {
                    agencyAddressInput.value = '';
                    agencyAddressInput.disabled = false;
                })
                .getSupplierAddress(currentAgencyName);
          } else {
              agencyAddressInput.value = selectedPrintFields.agencyAddress;
          }

      } else {
          standardFields.classList.remove('hidden');
          securityFields.classList.add('hidden');
      }

      // Populate Name and Designation/Position 
      document.getElementById('signatory-prepared-by').value = selectedSignatories.preparedBy.name;
      document.getElementById('signatory-prepared-by-designation').value = selectedSignatories.preparedBy.designation;

      document.getElementById('signatory-approved-by').value = selectedSignatories.approvedBy.name;
      document.getElementById('signatory-approved-by-designation').value = selectedSignatories.approvedBy.designation;
      
      for(let i = 0; i < 5; i++) {
          const inputName = document.getElementById(`signatory-checked-by-${i}`);
          const inputDesignation = document.getElementById(`signatory-checked-by-${i}-designation`);
          
          if(inputName) inputName.value = selectedSignatories.checkedBy[i].name;
          if(inputDesignation) inputDesignation.value = selectedSignatories.checkedBy[i].designation;
      }
      
      // Populate Print Fields
      const subPropertyInput = document.getElementById('sub-property-input');
      const sectionInput = document.getElementById('section-input');
      const departmentInput = document.getElementById('department-input');
      const remarksInput = document.getElementById('remarks-input');
      const serialNoInput = document.getElementById('serial-no-input'); 
      const toInput = document.getElementById('to-input');
      const referencesInput = document.getElementById('security-references-input');              
      
      subPropertyInput.value = selectedPrintFields.subProperty;
      sectionInput.value = selectedPrintFields.section;
      departmentInput.value = selectedPrintFields.department;
      remarksInput.value = selectedPrintFields.remarks;
      serialNoInput.value = selectedPrintFields.serialNo;
      toInput.value = selectedPrintFields.to;

      if (!selectedPrintFields.references) {
          selectedPrintFields.references = DEFAULT_SECURITY_REFERENCES;
      }
      referencesInput.value = selectedPrintFields.references;             

      // Attach listeners (Standard)
      subPropertyInput.oninput = (e) => handlePrintFieldInputChange(e, 'subProperty');
      sectionInput.oninput = (e) => handlePrintFieldInputChange(e, 'section');
      departmentInput.oninput = (e) => handlePrintFieldInputChange(e, 'department');
      remarksInput.oninput = (e) => handlePrintFieldInputChange(e, 'remarks');
      remarksInput.addEventListener('input', filterDatalistOptions);

      // Attach listeners (Security)
      serialNoInput.oninput = (e) => handlePrintFieldInputChange(e, 'serialNo'); 
      toInput.oninput = (e) => handlePrintFieldInputChange(e, 'to');
      referencesInput.oninput = (e) => handlePrintFieldInputChange(e, 'references');             
      
      if (isSecurity) {
          document.getElementById('agency-name-input').oninput = (e) => { selectedPrintFields.agencyName = e.target.value.toUpperCase(); };
          document.getElementById('agency-address-input').oninput = (e) => { selectedPrintFields.agencyAddress = e.target.value; }; // Allow mixed case for address
          document.getElementById('agency-tel-input').oninput = (e) => { selectedPrintFields.agencyTel = e.target.value; };
          document.getElementById('agency-email-input').oninput = (e) => { selectedPrintFields.agencyEmail = e.target.value; };
      }

      document.getElementById('print-setup-modal').classList.remove('hidden'); 
      
      if (isSecurity) {
           sectionInput.focus();
      } else {
           subPropertyInput.focus();
      }
  }

// NEW: Handle Print Field Input Change (Validation and State Update)
function handlePrintFieldInputChange(event, field) {
    if (field === 'references') {
        selectedPrintFields.references = event.target.value;
        return; 
    }

    let newValue = event.target.value.toUpperCase(); 
    event.target.value = newValue; 

    if (field === 'subProperty') selectedPrintFields.subProperty = newValue.trim();
    else if (field === 'section') selectedPrintFields.section = newValue.trim();
    else if (field === 'department') selectedPrintFields.department = newValue.trim();
    else if (field === 'remarks') selectedPrintFields.remarks = newValue.trim();
    else if (field === 'serialNo') selectedPrintFields.serialNo = newValue.trim(); 
    else if (field === 'to') selectedPrintFields.to = newValue.trim();             
  }

function hidePrintSetupModal() {
    document.getElementById('print-setup-modal').classList.add('hidden');
}

function handlePrintSetupConfirm(event) {
      const isSecurity = currentContract && currentContract.serviceType === 'SECURITY SERVICES';

      const section = document.getElementById('section-input').value.trim();
      const department = document.getElementById('department-input').value.trim();
      const subProperty = document.getElementById('sub-property-input').value.trim();

      // Validation Common Fields
      if (!section) { showNotification('Section is required.', false); return; }
      if (!department) { showNotification('Department is required.', false); return; }
      if (!subProperty) { showNotification('Sub Property is required.', false); return; }

      // Service Specific Validation & Data Capture
      let remarks = '';
      let serialNo = '';
      let toField = '';

      if (isSecurity) {
           serialNo = document.getElementById('serial-no-input').value.trim();
           toField = document.getElementById('to-input').value.trim();
           
           // Capture New Agency Fields explicitly to be safe
           selectedPrintFields.agencyName = document.getElementById('agency-name-input').value.trim();
           selectedPrintFields.agencyAddress = document.getElementById('agency-address-input').value.trim();
           selectedPrintFields.agencyTel = document.getElementById('agency-tel-input').value.trim();
           selectedPrintFields.agencyEmail = document.getElementById('agency-email-input').value.trim();

           if (!serialNo) { showNotification('Serial No. is required.', false); return; }
           if (!toField) { showNotification('To (Addressee) is required.', false); return; }
      } else {
           remarks = document.getElementById('remarks-input').value.trim();
      }
      
      // Save State
      selectedPrintFields.subProperty = subProperty;
      selectedPrintFields.section = section;
      selectedPrintFields.department = department;
      selectedPrintFields.remarks = remarks;
      selectedPrintFields.serialNo = serialNo;
      selectedPrintFields.to = toField;
      selectedPrintFields.references = document.getElementById('security-references-input').value;

      const signatoryError = validateAllSignatories();
      if (signatoryError) {
          showNotification(`Signatory Error: ${signatoryError}`, false);
          return;
      }
      
      hidePrintSetupModal();
      triggerPrintPreparation(selectedPrintFields, bulkPrintSelected); 
  }

// MODIFIED: This function now calls the print selection modal first.
function handlePrintPlan() {
    if (!currentContract) {
        showNotification('Please select a Contract Group ID first.', false);
        return;
    }
    
    // Go directly to print selection modal
    openPrintSelectionModal();
}

// MODIFIED: Accepts all new fields (section, department, remarks)
function triggerPrintPreparation(printFields, selectedPrintIds) { 
    if (!currentContract) {
        showNotification('Please select a Contract Group ID first.', false);
        return;
    }
    
    // 1. Validation Logic
    const activeRows = document.querySelectorAll('#attendance-table-container tbody tr');
    const printedPersonnelIds = [];
    
    activeRows.forEach(row => {
        const idInput = row.querySelector('[data-field="id"]');
        const id = (idInput?.value || '').trim();
        const stableKey = row.dataset.stableKey;

        if (selectedPrintIds.includes(id)) {
            const isLocked = !!lockedIdRefMap[stableKey];
            let hasActualSchedule = false;

            // Simple check if Security Row has Time Shift
            if (currentContract.serviceType === 'SECURITY SERVICES') {
                 const timeShift = row.querySelector('[data-security-field="timeOfShift"]')?.value;
                 if (timeShift) hasActualSchedule = true;
            } else {
                row.querySelectorAll('.cell-container').forEach(cell => {
                     const status = cell.querySelector('.attendance-cell-bg').textContent.trim();
                     if (status !== '' && status !== 'NA' && status !== 'DELETED' && status !== 'LOCKED') {
                         hasActualSchedule = true;
                     }
                });
            }

            if (id && PERSONNEL_ID_REGEX.test(id) && hasActualSchedule && !isLocked) {
                printedPersonnelIds.push(id);
            }
        }
    });
    
    if (printedPersonnelIds.length === 0) {
         showNotification('Cannot print: No selected employee data with an **actual schedule** found that is not already locked.', false);
         return;
    }

    const dynamicallyHiddenRows = []; 
    const currentYear = currentPlanningDate.getFullYear();
    const currentMonth = currentPlanningDate.getMonth();
    const currentShift = document.getElementById('shift-period-select').value;
    
    const contractInfo = {
        payor: currentContract.payorCompany,
        agency: currentContract.agency,
        serviceType: currentContract.serviceType,
        headCount: currentContract.headCount,
        propOrGrpCode: currentContract.propOrGrpCode, 
        sector: currentContract.sector,
        kindOfSfc: currentContract.kindOfSfc || ''
    };

    toggleLoading(true, 'Fetching Supporting Documents & Generating Print Ref...');

    const contractGroupId = currentContract.id;

    google.script.run
        .withSuccessHandler((relatedContracts) => {
            
            google.script.run
                .withSuccessHandler((response) => { 
                    toggleLoading(false);
                    const { refNum, printGroup } = response;
                    
                    // Call the main triggerPrint function with all data
                    triggerPrint(refNum, printGroup, printFields, selectedSignatories, dynamicallyHiddenRows, currentContract.sfcRef, contractInfo, currentYear, currentMonth, currentShift, printedPersonnelIds, relatedContracts); 
                })
                .withFailureHandler((error) => {
                    handleError(error);
                })
                .logPrintAction(printFields.subProperty || 'SECURITY', currentContract.sfcRef, contractInfo, currentYear, currentMonth, currentShift); 

        })
        .withFailureHandler((error) => {
            handleError(error);
        })
        .fetchSupportingContracts(contractGroupId);
  }

// MODIFIED: Accepts printFields object instead of separate subProperty string
function triggerPrint(refNum, printGroup, printFields, signatories, dynamicallyHiddenRows = [], sfcRef, contractInfo, year, month, shift, printedPersonnelIds, relatedContracts = []) { 
    showNotification(`Print Reference #${refNum} generated. Printing now...`, true);
    
    const { preparedBy, approvedBy } = signatories;
    
    // --- Date & Period Calculation ---
    const date = new Date(year, month, 1);
    const monthName = date.toLocaleString('en-US', { month: 'long' });
    const yearNum = date.getFullYear();
    const daysInMonth = getDaysInMonth(year, month); 

    let planPeriodDisplay = '';
    if (shift === '1stHalf') {
        planPeriodDisplay = `${monthName} 1-15, ${yearNum} (${shift})`;
    } else {
        planPeriodDisplay = `${monthName} 16-${daysInMonth}, ${yearNum} (${shift})`;
    }

    const now = new Date();
    const formattedTime = now.toLocaleString('en-US', { 
        year: 'numeric', month: '2-digit', day: '2-digit', 
        hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: true 
    });
    
    // --- Timestamp Display ---
    const timestampDisplay = document.getElementById('print-timestamp-display');
    if (timestampDisplay) {
         timestampDisplay.textContent = `Printed: ${formattedTime}`;
         timestampDisplay.classList.remove('print-hidden'); 
    }
    
    // --- Checked By Columns Logic ---
    const checkedByNames = signatories.checkedBy; 
    let checkedByColumnsHtml = '';
    const maxChecked = 5; 

    for (let i = 0; i < maxChecked; i++) {
        const signatory = checkedByNames[i];
        let nameHtml = `<p class="text-sm font-bold text-black line-break border-t pt-1">&nbsp;</p>`;
        let designationHtml = `<p class="text-xs font-normal text-black pb-1">&nbsp;</p>`;
        let isFilled = false;
        
        if (signatory && signatory.name.trim() !== '') {
            nameHtml = `<p class="text-sm font-bold text-black line-break border-t pt-1">${signatory.name.trim()}</p>`;
            designationHtml = `<p class="text-xs font-normal text-black pb-1">${signatory.designation.trim()}</p>`;
            isFilled = true;
        }
        
        checkedByColumnsHtml += `
            <div class="checked-by-col checked-by-col-${i}" data-filled="${isFilled}">
                ${nameHtml}${designationHtml}
                <p class="text-xs font-bold text-black pt-1">Checked By ${i + 1}</p>
            </div>`;
    }

    // --- Print Ref Display ---
    let printRefElement = document.getElementById('print-ref-display');
    if (!printRefElement) {
        printRefElement = document.createElement('div');
        printRefElement.id = 'print-ref-display';
        printRefElement.className = 'print-only-container print-hidden'; 
        document.body.appendChild(printRefElement);
    }
    printRefElement.textContent = refNum; 
    
    let headerHtml = '';

    if (contractInfo.serviceType === 'SECURITY SERVICES') {

        const rawRefs = printFields.references || DEFAULT_SECURITY_REFERENCES;
        const formattedRefs = rawRefs.split('\n').map(line => `<p>${line}</p>`).join('');
        
        // --- PREPARE DATA ---
        const agencyNameStr = printFields.agencyName || contractInfo.agency;
        const agencyAddressStr = printFields.agencyAddress || ''; // Address from Modal
        const agencyTelStr = printFields.agencyTel || '';
        const agencyEmailStr = printFields.agencyEmail || '';

        // --- BUILD OPTIONAL CONTACT LINES (Centered) ---
        let contactDetailsHtml = '';
        if (agencyTelStr) {
            contactDetailsHtml += `<p style="margin: 0; font-size: 10px; text-align: center;">Telephone No: ${agencyTelStr}</p>`;
        }
        if (agencyEmailStr) {
            contactDetailsHtml += `<p style="margin: 0; font-size: 10px; text-align: center;">Email Add: ${agencyEmailStr}</p>`;
        }
        
        headerHtml = `
        <div id="agency-header-standalone" class="print-only-container" style="display: block; width: 100%; text-align: center; margin-bottom: 10px;">
            <h2 style="margin: 0; font-size: 14px; font-weight: bold; text-transform: uppercase; text-align: center;">${agencyNameStr}</h2>
            <p style="margin: 0; font-size: 10px; text-align: center;">${agencyAddressStr}</p>
            ${contactDetailsHtml}
        </div>

        <div id="print-details-unified-container" class="print-only-container">
            <div class="print-details-col left-col">
                <div class="flex"><p class="label" style="min-width: 80px;">Company Name:</p><p class="value font-bold">${contractInfo.payor}</p></div>
                <div class="flex"><p class="label" style="min-width: 80px;">Sub-Property:</p><p class="value">${printFields.subProperty}</p></div>
                <div class="flex"><p class="label" style="min-width: 80px;">Department:</p><p class="value">${printFields.department}</p></div>
                <div class="flex"><p class="label" style="min-width: 80px;">Section:</p><p class="value">${printFields.section}</p></div>
                <div class="flex"><p class="label" style="min-width: 80px;">Plan Period:</p><p class="value">${planPeriodDisplay}</p></div>
                <div class="flex"><p class="label" style="min-width: 80px;">Serial Number:</p><p class="value font-bold">${printFields.serialNo}</p></div>
                <div class="flex"><p class="label" style="min-width: 80px;">Subject:</p><p class="value font-bold">Duty Detail Order</p></div>
                <div class="flex"><p class="label" style="min-width: 80px;">To:</p><p class="value">${printFields.to}</p></div>
            </div>
            <div class="print-details-col right-col">
                <div class="flex"><p class="label">Prop / Grp. Code</p><p class="value">${contractInfo.propOrGrpCode}</p></div>
                <div class="flex"><p class="label">Sector</p><p class="value">${contractInfo.sector}</p></div>
                <div class="flex"><p class="label">Service Type</p><p class="value">${contractInfo.serviceType}</p></div>
            </div>
        </div>

        <div id="security-text-container" class="print-only-container" style="display: block !important; margin-top: 5px; margin-bottom: 10px; margin-left: 10px; font-size: 0.55rem; color: black; line-height: 1.2;">
            <p><strong>1. References:</strong></p>
            <div style="padding-left: 15px;">
                ${formattedRefs} </div>
            <p style="margin-top: 5px;"><strong>2. Purpose:</strong> Post Security Services Duties</p>
            <p style="margin-top: 5px;"><strong>3. Inclusive Dates:</strong> ${planPeriodDisplay}</p>
            <p style="margin-top: 5px;"><strong>4.</strong> The Following named Security Guards (SGs) are detailed to render security service duties on place/s indicated in the table below:</p>
        </div>
        `;

    } else {
        // --- STANDARD HEADER  ---
        headerHtml = `
        <div id="print-details-unified-container" class="print-only-container">
            <div class="print-details-col left-col">
                <div class="flex"><p class="label">Company Name</p><p class="value">${contractInfo.payor}</p></div>
                <div class="flex"><p class="label">Sub-Property</p><p class="value">${printFields.subProperty}</p></div>
                <div class="flex"><p class="label">Schedule Period</p><p class="value">${planPeriodDisplay}</p></div>
                <div class="flex"><p class="label">Agency Name</p><p class="value">${contractInfo.agency}</p></div>
                <div class="flex"><p class="label">Section</p><p class="value">${printFields.section}</p></div>
                <div class="flex"><p class="label">Department</p><p class="value">${printFields.department}</p></div>
            </div>
            <div class="print-details-col right-col">
                <div class="flex"><p class="label">Prop / Grp. Code</p><p class="value">${contractInfo.propOrGrpCode}</p></div>
                <div class="flex"><p class="label">Sector</p><p class="value">${contractInfo.sector}</p></div>
                <div class="flex"><p class="label">Service Type</p><p class="value">${contractInfo.serviceType}</p></div>
                ${printFields.remarks && printFields.remarks.trim() !== '' ? `<div class="flex"><p class="label">Remarks</p><p class="value">${printFields.remarks}</p></div>` : ``}
            </div>
        </div>
        `;
    }

    // --- Signatories Injection ---
    const signatoriesOnlyHtml = `
        <div id="print-signatories-container" class="print-only-container">
            <div class="grid gap-x-4 gap-y-2 text-center print-signatories">
                <div class="prepared-by">
                    <p class="text-sm font-bold text-black line-break border-t pt-1">${preparedBy.name.trim()}</p>
                    <p class="text-xs font-normal text-black pb-1">${preparedBy.designation.trim()}</p>
                    <p class="text-xs font-bold text-black pt-1">Prepared By</p>
                </div>
                ${checkedByColumnsHtml}
                <div class="approved-by">
                    <p class="text-sm font-bold text-black line-break border-t pt-1">${approvedBy.name.trim()}</p>
                    <p class="text-xs font-normal text-black pb-1">${approvedBy.designation.trim()}</p>
                    <p class="text-xs font-bold text-black pt-1">Approved By</p>
                </div>
            </div>
        </div>
    `;

    // --- Supporting Documents (Extra Page) ---
    let supportingDocsHtml = '';
    if (relatedContracts && relatedContracts.length > 0) {
        const tableRows = relatedContracts.map(item => `
            <tr>
                <td>${item.grpId}</td>
                <td>${item.kindSfc}</td>
                <td>${item.refNum}</td>
                <td>${item.ballWith}</td>
            </tr>
        `).join('');

        supportingDocsHtml = `
            <div id="print-supporting-docs-container" class="print-only-container page-break-before">
                <h2 class="supporting-docs-title">Supporting Documents: Contract Group References</h2>
                <p style="font-size: 10pt; margin-bottom: 5px;">Group ID: <strong>${currentContract.id}</strong></p>
                
                <table class="supporting-docs-table">
                    <thead>
                        <tr>
                            <th>CONTRACT GRP ID</th>
                            <th>Kind of SFC</th>
                            <th>Ref #</th>
                            <th>SFC Ball with?</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${tableRows}
                    </tbody>
                </table>
                
                <div style="margin-top: 20px; font-size: 8pt; color: #555;">
                    <p>Printed Reference #: ${refNum}</p>
                    <p>Date Printed: ${formattedTime}</p>
                </div>
            </div>
        `;
    }

    // --- INJECTION EXECUTION ---
    const contractDetailsGrid = document.getElementById('contract-details-grid');
    
    // Clean up old elements
    ['agency-header-standalone', 'print-details-unified-container', 'print-signatories-container', 'print-supporting-docs-container', 'security-text-container'].forEach(id => {
        const el = document.getElementById(id);
        if (el) el.remove();
    });

    if (contractDetailsGrid) {
        // Inject Header BEFORE the grid 
        contractDetailsGrid.insertAdjacentHTML('afterend', headerHtml);
        contractDetailsGrid.classList.add('print-hidden'); 
    } 

    // Inject Signatories at bottom
    document.body.insertAdjacentHTML('beforeend', signatoriesOnlyHtml);
    
    // Inject Supporting Docs
    if (supportingDocsHtml) {
        document.body.insertAdjacentHTML('beforeend', supportingDocsHtml);
    }

    // --- Modal Confirmation & Restore Logic ---
    const setupModalAndPrint = () => {
        const modal = document.getElementById('print-confirm-modal');
        const message = document.getElementById('print-confirm-message');
        const okBtn = document.getElementById('confirm-print-ok-btn');
        const cancelBtn = document.getElementById('confirm-print-cancel-btn');
        
        message.innerHTML = `We need to verify if the document was successfully printed. Did you proceed with printing the document (Reference #: <span class="font-bold text-blue-600">${refNum}</span>)?`;
        
        const restoreUI = () => {
            modal.classList.add('hidden');
            document.querySelectorAll('.print-hidden').forEach(row => {
                if (dynamicallyHiddenRows.includes(row) || row.classList.contains('print-empty-row')) {
                    row.classList.remove('print-hidden');
                }
            });
            reloadPlanAndCheckExistence(); 
            if (printRefElement) printRefElement.remove();
            
            // CLEAN UP INJECTED ELEMENTS
            const elementsToRemove = [
                'agency-header-standalone', // Added cleanup for new header
                'print-details-unified-container', 
                'print-signatories-container', 
                'print-supporting-docs-container',
                'security-text-container' 
            ];
            
            elementsToRemove.forEach(id => {
                const el = document.getElementById(id);
                if (el) el.remove();
            });
            
            if (contractDetailsGrid) contractDetailsGrid.classList.remove('print-hidden');
            if (timestampDisplay) {
                timestampDisplay.classList.add('print-hidden');
                timestampDisplay.textContent = '';
            }
            const inputs = document.querySelectorAll('#attendance-table-container input');
            inputs.forEach(input => input.classList.remove('print-read-only'));
            
            window.onafterprint = null; 
            okBtn.removeEventListener('click', handleOk);
            cancelBtn.removeEventListener('click', handleCancel);
        };

        const handleOk = () => {
            toggleUiLock(true, 'Confirming print log, locking schedules, and saving PDF...');
          
            savePdfOfPrintLayout(refNum, sfcRef, year, month, shift, printedPersonnelIds);

            google.script.run
                .withSuccessHandler(() => {
                    showNotification(`Print action (Ref# ${refNum}) successfully logged and locked. Refreshing...`, true);
                    restoreUI();
                })
                .withFailureHandler((error) => {
                    showNotification(`Warning: Failed to record print log/lock (Ref# ${refNum}). Error: ${error.message}`, false);
                    restoreUI();
                })
                .recordPrintLogEntry(refNum, printGroup, printFields.subProperty, printFields, signatories, sfcRef, contractInfo, year, month, shift, printedPersonnelIds); 
        };

        const handleCancel = () => {
            restoreUI();
            showNotification(`Print log (Ref# ${refNum}) discarded by user. No schedules were locked.`, false);
        };
        
        okBtn.addEventListener('click', handleOk);
        cancelBtn.addEventListener('click', handleCancel);

        window.onafterprint = function() {
            modal.classList.remove('hidden');
        };
    };
    
    const rowsToRestore = applySequentialPrintNumberingAndHiding(dynamicallyHiddenRows, printedPersonnelIds); 
    document.querySelectorAll('.print-empty-row').forEach(row => row.classList.add('print-hidden'));
    
    const inputs = document.querySelectorAll('#attendance-table-container input');
    inputs.forEach(input => input.classList.add('print-read-only'));

    setupModalAndPrint();

    window.print();
}

// --- NEW HELPER: Get Cell Coordinates (Absolute row index, 0-based column index) ---
function getCellCoordinates(cell) {
    if (!cell) return null;
    
    if (!cell.classList.contains('cell-container') && !cell.classList.contains('security-bulk-cell')) return null;
    
    const row = cell.parentNode;
    const rowIndex = row.rowIndex; 
    
    const colIndex = cell.cellIndex; 
    
    return { R: rowIndex, C: colIndex };
}

// --- NEW HELPER: Check if a Row is Active (Non-blank) ---
function isRowActive(rowElement) {
    const idInput = rowElement.querySelector('[data-field="id"]');
    const nameInput = rowElement.querySelector('[data-field="name"]');
    
    return (idInput?.value || '').trim() !== '' || (nameInput?.value || '').trim() !== '';
}

// --- NEW FUNCTION: CRITICAL DRAG LOGIC (Additive) ---
function visualizeAdditiveRange(startCell, endCell) {
    const startCoords = getCellCoordinates(startCell);
    const endCoords = getCellCoordinates(endCell);

    if (!startCoords || !endCoords) return;

    const table = startCell.closest('table');
    if (!table) return;

    const R_min = Math.min(startCoords.R, endCoords.R);
    const R_max = Math.max(startCoords.R, endCoords.R);
    const C_min_target = Math.min(startCoords.C, endCoords.C);
    const C_max_target = Math.max(startCoords.C, endCoords.C);
    
    const isSecurity = currentContract && currentContract.serviceType === 'SECURITY SERVICES';
    const COL_START_INDEX = isSecurity ? 4 : 5; 
    
    const C_min = Math.max(COL_START_INDEX, C_min_target);
    const C_max = Math.max(COL_START_INDEX, C_max_target);

    // Select appropriate cells based on type
    const cellSelector = isSecurity ? 'td.security-bulk-cell' : 'td.cell-container';
    const allCells = Array.from(table.querySelectorAll(cellSelector));

    // Clear previous drag selection NOT in main selection
    cellsFromCurrentDrag.forEach(cell => {
        if (!bulkSelectedCells.includes(cell)) {
             cell.classList.remove('cell-selected');
        }
    });
    cellsFromCurrentDrag = []; 

    allCells.forEach(cell => {
        const coords = getCellCoordinates(cell);
        if (!coords) return; 

        const cellRow = cell.closest('tr');
        if (!isRowActive(cellRow)) {
            return; 
        }

        const isInRange = coords.R >= R_min && coords.R <= R_max && 
                          coords.C >= C_min && coords.C <= C_max;
        
        const isLocked = cellRow.classList.contains('line-through') || cellRow.classList.contains('locked-row');

        if (isInRange && !isLocked) {
             cell.classList.add('cell-selected'); 
             cellsFromCurrentDrag.push(cell);
        }
    });
    
    const uniqueSelectedCount = new Set([...bulkSelectedCells, ...cellsFromCurrentDrag]).size;
    document.getElementById('bulk-cell-count').textContent = uniqueSelectedCount;
}

// --- NEW FUNCTION: Handle Drag Start ---
function handleDragStart(event) {
    if (!isBulkSelectionMode || event.button !== 0) return; 

    // Allow dragging on both cell-container (Standard) and security-bulk-cell (Security)
    const targetCell = event.target.closest('.cell-container, .security-bulk-cell');
    if (!targetCell) return;
    
    const row = targetCell.closest('tr');
    
    if (!isRowActive(row)) {
        showNotification('Cannot drag: Start row must contain active employee details.', false);
        return; 
    }
    const isCellLocked = row.classList.contains('line-through') || row.classList.contains('locked-row');
    if (isCellLocked) {
        return; 
    }
    
    event.preventDefault(); 

    isDragging = true;
    dragStartCell = targetCell;
    dragEndCell = targetCell;
    
    document.addEventListener('mousemove', handleDragging);
    document.addEventListener('mouseup', handleDragEnd); 
}

// --- NEW FUNCTION: Handle Dragging (Hakbang 2) ---
function handleDragging(event) {
    if (!isDragging) return;
    
    const currentCell = event.target.closest('.cell-container, .security-bulk-cell');
    
    if (!currentCell || currentCell.closest('tr').classList.contains('line-through') || currentCell.closest('tr').classList.contains('locked-row')) {
        return;
    }
    
    if (currentCell !== dragEndCell) {
        dragEndCell = currentCell;
        visualizeAdditiveRange(dragStartCell, dragEndCell); 
    }
}

// --- NEW FUNCTION: Handle Drag End (Hakbang 3) ---
function handleDragEnd(event) {
    if (!isDragging) return;
    
    if (dragStartCell === dragEndCell) {
        toggleCellSelection(dragStartCell); 
    } 
    
    if (dragStartCell !== dragEndCell) {
        cellsFromCurrentDrag.forEach(cell => {
             if (!bulkSelectedCells.includes(cell)) {
                 bulkSelectedCells.push(cell);
             }
        });
    }
    
    cellsFromCurrentDrag = []; 
    
    isDragging = false;
    dragStartCell = null;
    dragEndCell = null;
    
    document.removeEventListener('mousemove', handleDragging);
    document.removeEventListener('mouseup', handleDragEnd);
}

// Function to start the bulk selection process
function startBulkSelectionMode() {
    if (isBulkSelectionMode) return; 
    isBulkSelectionMode = true;
    bulkSelectedCells = []; 

    const isSecurity = currentContract.serviceType === 'SECURITY SERVICES';

    if (isSecurity) {
        // SECURITY LOGIC
        document.querySelectorAll('.security-bulk-cell input, .security-bulk-cell select').forEach(el => {
            el.classList.add('pointer-events-none'); 
        });
        
        document.querySelectorAll('.security-bulk-cell').forEach(cell => {
             cell.classList.add('cursor-crosshair');
             cell.addEventListener('click', handleCellSelectionClick);
        });
    } else {
        // STANDARD LOGIC
        document.querySelectorAll('.cell-container').forEach(cell => {
            cell.removeEventListener('click', handleCellClick);
            const row = cell.closest('tr');
            if (!row.classList.contains('line-through') && !row.classList.contains('locked-row')) {
                cell.addEventListener('click', handleCellSelectionClick); 
                cell.classList.add('cursor-crosshair'); 
            }
            cell.classList.remove('cell-selected'); 
        });
    }
    
    // ENABLE DRAG FOR BOTH MODES
    const gridContainer = document.getElementById('attendance-grid');
    if (gridContainer) gridContainer.addEventListener('mousedown', handleDragStart, false); 
    
    // Update Button UI
    const bulkBtn = document.getElementById('start-bulk-select-btn');
    bulkBtn.textContent = 'Apply Selection';
    bulkBtn.classList.remove('bg-yellow-600', 'hover:bg-yellow-700');
    bulkBtn.classList.add('bg-blue-600', 'hover:bg-blue-700');
    bulkBtn.removeEventListener('click', startBulkSelectionMode); 
    bulkBtn.addEventListener('click', openBulkScheduleModal); 

    showNotification('Bulk Selection Mode: Click or Drag to select cells/rows.', true);
}

// Function to return to normal mode (called after save or cancel)
function exitBulkSelectionMode() {
    isBulkSelectionMode = false;
    const isSecurity = currentContract && currentContract.serviceType === 'SECURITY SERVICES';

    if (isSecurity) {
         // SECURITY CLEANUP: Re-enable inputs
         document.querySelectorAll('.security-bulk-cell input, .security-bulk-cell select').forEach(el => {
            el.classList.remove('pointer-events-none'); 
        });
         document.querySelectorAll('.security-bulk-cell').forEach(cell => {
             cell.classList.remove('cursor-crosshair', 'cell-selected');
             cell.removeEventListener('click', handleCellSelectionClick);
        });
    } else {
        // STANDARD CLEANUP
        document.querySelectorAll('.cell-container').forEach(cell => {
            cell.removeEventListener('click', handleCellSelectionClick);
            const row = cell.closest('tr');
            if (!row.classList.contains('line-through') && !row.classList.contains('locked-row')) {
               cell.addEventListener('click', handleCellClick); 
            }
            cell.classList.remove('cell-selected', 'cursor-crosshair');
        });
    }
    
    // CLEANUP DRAG LISTENERS FOR BOTH
    const gridContainer = document.getElementById('attendance-grid');
    if (gridContainer) gridContainer.removeEventListener('mousedown', handleDragStart, false); 
    document.removeEventListener('mousemove', handleDragging);
    document.removeEventListener('mouseup', handleDragEnd); 
    
    bulkSelectedCells = [];
    cellsFromCurrentDrag = []; 
    document.getElementById('bulk-cell-count').textContent = '0';
    document.getElementById('floating-bulk-modal').classList.add('hidden');
    
    const bulkBtn = document.getElementById('start-bulk-select-btn');
    bulkBtn.textContent = 'Start Bulk Select';
    bulkBtn.classList.remove('bg-blue-600', 'hover:bg-blue-700');
    bulkBtn.classList.add('bg-yellow-600', 'hover:bg-yellow-700');
    bulkBtn.removeEventListener('click', openBulkScheduleModal); 
    bulkBtn.addEventListener('click', startBulkSelectionMode); 

    showNotification('Bulk Selection Mode ended.', false);
}

function toggleCellSelection(cell) {
    const index = bulkSelectedCells.indexOf(cell);
    if (index > -1) {
        bulkSelectedCells.splice(index, 1);
        cell.classList.remove('cell-selected');
    } else {
        bulkSelectedCells.push(cell);
        cell.classList.add('cell-selected');
    }
    document.getElementById('bulk-cell-count').textContent = bulkSelectedCells.length;
}

function handleCellSelectionClick(event) {
    const targetCell = event.currentTarget || event; 
    const row = targetCell.closest('tr');
    
    if (!isRowActive(row)) {
        showNotification('Cannot select: This row does not contain active employee details.', false);
        return;
    }
    const isCellLocked = row.classList.contains('line-through') || row.classList.contains('locked-row');
    if (isCellLocked) {
        const originalId = targetCell.dataset.originalId || '';
        showNotification('Cannot select: Row is marked for deletion or is locked (Ref #'+ lockedIdRefMap[originalId] +').', false);
        return;
    }
    
    const idInput = row.querySelector('[data-field="id"]');
    const personnelId = (idInput?.value || '').trim();
    
    if (!personnelId || !PERSONNEL_ID_REGEX.test(personnelId)) { 
        showNotification('Cannot select: Personnel ID is empty or invalid (must be numbers only). Please correct the ID field first.', false);
        return;
    }
    
    toggleCellSelection(targetCell);
}

// Function to open the Bulk Modal
function openBulkScheduleModal() {
    if (bulkSelectedCells.length === 0) {
        showNotification('Please select at least one cell/row first.', false);
        return;
    }
    
    const modal = document.getElementById('floating-bulk-modal');
    const isSecurity = currentContract.serviceType === 'SECURITY SERVICES';
    
    const stdFields = document.getElementById('standard-bulk-fields');
    const secFields = document.getElementById('security-bulk-fields');

    if (isSecurity) {
        // SHOW SECURITY FIELDS
        stdFields.classList.add('hidden');
        secFields.classList.remove('hidden');

        // DETECT SELECTED COLUMNS
        const selectedFields = new Set();
        bulkSelectedCells.forEach(cell => {
            const input = cell.querySelector('[data-security-field]');
            if (input) {
                selectedFields.add(input.dataset.securityField);
            }
        });

        // Helper to Toggle Visibility
        const toggleInputVisibility = (inputId, fieldName) => {
            const el = document.getElementById(inputId);
            if (el) {
                const container = el.parentElement; 
                if (selectedFields.has(fieldName)) {
                    container.classList.remove('hidden');
                } else {
                    container.classList.add('hidden');
                }
                el.value = ''; // Reset value
            }
        };

        // Populate Security Time Dropdown
        const timeSelect = document.getElementById('bulk-sec-time-shift');
        timeSelect.innerHTML = '<option value="">-- Select Time --</option>';
        for (let h = 0; h < 24; h++) {
            for (let m = 0; m < 60; m += 30) {
                const startStr = formatTime12H(h, m);
                const endH_raw = (h + 12) % 24;
                const endStr = formatTime12H(endH_raw, m);
                
                const shiftStr = `${startStr}-${endStr}`;
                const opt = document.createElement('option');
                opt.value = shiftStr; opt.text = shiftStr;
                timeSelect.appendChild(opt);
            }
        }

        // Toggle visibility based on selection
        toggleInputVisibility('bulk-sec-time-shift', 'timeOfShift');
        toggleInputVisibility('bulk-sec-fa-type', 'faType');
        toggleInputVisibility('bulk-sec-fa-make', 'faMake');
        toggleInputVisibility('bulk-sec-fa-caliber', 'faCaliber');

    } else {
        // SHOW STANDARD FIELDS
        stdFields.classList.remove('hidden');
        secFields.classList.add('hidden');

        // Populate Standard Time Options
        const inputStartTime = document.getElementById('bulk-start-time');
        const inputEndTime = document.getElementById('bulk-end-time');
        const fixedOptionsContainer = document.getElementById('bulk-fixed-status-options-container');

        fixedOptionsContainer.innerHTML = '';
        fixedStatusOptions.forEach(option => {
            const button = document.createElement('button');
            button.type = 'button';
            button.textContent = option.label;
            button.value = option.value;
            button.className = `w-full px-4 py-2 text-sm rounded-lg border hover:shadow-md transition duration-150 ${option.color} bg-opacity-50 border-gray-300`;
            button.addEventListener('click', (e) => saveBulkSchedule(e, option.value)); 
            fixedOptionsContainer.appendChild(button);
        });
        
        inputStartTime.innerHTML = '<option value="">-- Start Time --</option>';
        inputEndTime.innerHTML = '<option value="">-- End Time --</option>';

        TIME_OPTIONS.forEach(time => {
            let optionStart = document.createElement('option');
            optionStart.value = time; optionStart.textContent = time;
            inputStartTime.appendChild(optionStart);
            let optionEnd = document.createElement('option');
            optionEnd.value = time; optionEnd.textContent = time;
            inputEndTime.appendChild(optionEnd);
        });
        inputStartTime.value = ''; inputEndTime.value = '';
    }

    document.getElementById('bulk-cell-count').textContent = bulkSelectedCells.length;
    modal.classList.remove('hidden');
    document.getElementById('bulk-save-btn').disabled = false;
}

// Function to save the schedule to all selected cells
function saveBulkSchedule(event, fixedStatusValue) {
    document.getElementById('floating-bulk-modal').classList.add('hidden');
    const isSecurity = currentContract.serviceType === 'SECURITY SERVICES';

    if (isSecurity) {
        const valMap = {
            'timeOfShift': document.getElementById('bulk-sec-time-shift').value,
            'faType': document.getElementById('bulk-sec-fa-type').value.toUpperCase().trim(),
            'faMake': document.getElementById('bulk-sec-fa-make').value.toUpperCase().trim(),
            'faCaliber': document.getElementById('bulk-sec-fa-caliber').value.toUpperCase().trim()
        };
        
        let appliedCount = 0;
        let skippedCount = 0; 

        bulkSelectedCells.forEach(cell => {
            const row = cell.closest('tr');
            if (row.classList.contains('line-through') || row.classList.contains('locked-row')) return;

            const input = cell.querySelector('[data-security-field]');
            if (!input) return;

            const fieldType = input.dataset.securityField;
            const newValue = valMap[fieldType];

            if (newValue && newValue !== '') {
                if (['faMake', 'faCaliber'].includes(fieldType)) {
                    const typeInput = row.querySelector('[data-security-field="faType"]');
                    const currentType = typeInput ? typeInput.value.trim() : '';
                    
                    const isTypeSelectedAndChanging = bulkSelectedCells.includes(typeInput.closest('td')) && valMap['faType'];
                    const effectiveType = isTypeSelectedAndChanging ? valMap['faType'] : currentType;

                    if (!effectiveType) {
                        skippedCount++;
                        return; 
                    }
                }

                // Apply Change
                input.value = newValue;
                input.dispatchEvent(new Event('change', { bubbles: true }));

                if (fieldType === 'faType') {
                    updateFirearmDependentFields(row);
                }

                // Visual feedback for Time of Shift
                if (fieldType === 'timeOfShift') {
                     cell.style.backgroundColor = '#dcfce7'; 
                     cell.classList.add('shift-colored-cell');
                }

                appliedCount++;
            }
        });

        let msg = `Security details updated for ${appliedCount} cells.`;
        if (skippedCount > 0) {
            msg += ` (Skipped ${skippedCount} cells because 'Type' was empty).`;
        }
        showNotification(`${msg} Click "Save All Changes" to save.`, skippedCount === 0);

    } else {
        // === STANDARD BULK SAVE LOGIC ===
        let finalStatus = '';
        
        if (event.type === 'click' && fixedStatusValue !== null) {
            finalStatus = fixedStatusValue;
        } else {
            const inputStartTime = document.getElementById('bulk-start-time').value.trim();
            const inputEndTime = document.getElementById('bulk-end-time').value.trim();

            if (inputStartTime && inputEndTime) {
                finalStatus = `${inputStartTime}-${inputEndTime}`;
            } else if (inputStartTime || inputEndTime) {
                showNotification('Please select both start and end times, or use the fixed status buttons.', false); 
                setTimeout(openBulkScheduleModal, 100); 
                return;
            } else {
                finalStatus = '';
            }
        }
        
        if (!fixedStatusCodes.includes(finalStatus) && finalStatus.length > 0) {
            if (!TIME_FORMAT_REGEX.test(finalStatus)) {
                showNotification('Invalid schedule format detected.', false);
                setTimeout(openBulkScheduleModal, 100); 
                return;
            }
        }
        
        let changesAppliedCount = 0;
        bulkSelectedCells.forEach(cellElement => {
            const row = cellElement.closest('tr');
            const idInput = row.querySelector('[data-field="id"]');
            const personnelId = (idInput?.value || '').trim();
            const originalId = cellElement.dataset.originalId; 
            const dayKey = cellElement.dataset.dayKey;
            const shiftKey = cellElement.dataset.shiftKey;
            
            if (lockedIdRefMap[originalId]) return;
            if (!personnelId || !PERSONNEL_ID_REGEX.test(personnelId)) return; 

            const currentPlanKey = `${personnelId}_${dayKey}_${shiftKey}`;
            const originalPlanKey = `${originalId}_${dayKey}_${shiftKey}`;
            const originalStatus = currentContract.planMap[originalPlanKey] || '';
            
            if (originalStatus !== finalStatus) {
                pendingAttendanceChanges[currentPlanKey] = finalStatus; 
            } else {
                delete pendingAttendanceChanges[currentPlanKey];
            }
            updateCellVisuals(cellElement, finalStatus, dayKey);
            changesAppliedCount++;
        });
        showNotification(`Bulk schedule applied to ${changesAppliedCount} cells. Click "Save All Changes" to save.`, true);
    }

    exitBulkSelectionMode();
    checkPlanSheetLockState(); 
}

// --- NEW HELPER: Get List of Employees for Deletion Modal ---
function getDeletableEmployeesForModal() {
    const deletableList = [];
    
    // 1. Regular Employees (Iterate over the SAVED roster: currentContract.employees)
    // Hindi na gagamitin ang getActiveEmployeesInGrid() para maiwasan ang TEMP_ entries.
    (currentContract?.employees || []).forEach(employee => {
        const stableKey = employee.id; // Saved ID ang stable key
        
        // SKIP if walang saved ID (dahil ito ay isang replacement slot or old placeholder)
        if (!stableKey) return;

        // Check for pending deletion mark
        const isMarkedForDeletion = pendingEmployeeInfoChanges[stableKey]?.isDeleted; 
        
        // Check for lock status
        const isLocked = !!lockedIdRefMap[stableKey];
        
        // Tanging unlocked at hindi pa marked for deletion ang pwedeng i-delete
        if (!isLocked && !isMarkedForDeletion) {
            const isSelected = bulkDeleteSelected.includes(stableKey);
            
            // Gumamit ng pending info para sa display name/ID kung merong local edit
            const pendingInfo = pendingEmployeeInfoChanges[stableKey]; 
            const displayName = (pendingInfo && pendingInfo.name) ? pendingInfo.name : employee.name;
            const displayId = (pendingInfo && pendingInfo.id) ? pendingInfo.id : employee.id;
            
            deletableList.push({
                stableKey: stableKey,
                id: displayId,
                name: displayName,
                isSelected: isSelected,
                isReliever: false, // Distinction
            });
        }
    });
    
    // 2. Saved Reliever Employees (Iterate over the SAVED reliever list)
    savedRelieverList.forEach(reliever => {
        const stableKey = reliever.id; // Saved ID ang stable key
        
        // SKIP if walang saved ID
        if (!stableKey) return; 
        
        const isLocked = !!lockedIdRefMap[reliever.id]; 
        // Note: For saved relievers, we check pendingRelieverChanges
        const isMarkedForDeletion = pendingRelieverChanges[stableKey]?.isDeleted; 
        
        if (!isLocked && !isMarkedForDeletion) {
             const isSelected = bulkDeleteSelected.includes(stableKey);
             deletableList.push({
                stableKey: stableKey, // Saved ID is the stable key for relievers
                id: reliever.id,
                name: reliever.name,
                isSelected: isSelected,
                isReliever: true, // Distinction
            });
        }
    });
    
    // Sort by name
    deletableList.sort((a, b) => a.name.localeCompare(b.name));

    return deletableList;
}

// --- NEW FUNCTION: Open the Bulk Delete Modal ---
function openBulkDeleteModal() {
    if (!currentContract) {
        showNotification('Please select a Contract Group ID first.', false);
        return;
    }
    
    const deletableEmployees = getDeletableEmployeesForModal();
    const listContainer = document.getElementById('delete-employee-list-container');
    const modal = document.getElementById('bulk-delete-selection-modal');
    const selectAllCheckbox = document.getElementById('select-all-delete');
    
    if (deletableEmployees.length === 0) {
        showNotification('No unlocked employees found to delete for this period.', false);
        return;
    }

    listContainer.innerHTML = '';
    bulkDeleteSelected = bulkDeleteSelected.filter(key => deletableEmployees.some(e => e.stableKey === key)); // Filter out invalid keys
    
    deletableEmployees.forEach(emp => {
        const listItem = document.createElement('li');
        const itemBgClass = emp.isSelected ? 'bg-red-50 border-red-400' : 'bg-gray-50 border-gray-200';
        
        listItem.className = `flex items-center space-x-3 p-2 rounded-lg border hover:bg-red-50 transition duration-150 cursor-pointer ${itemBgClass}`;
        
        const designationTag = emp.isReliever ? 
            '<span class="text-xs font-semibold text-purple-700 bg-purple-100 px-1 py-0.5 rounded-full whitespace-nowrap ml-2">RELIEVER</span>' : 
            '';
        
        listItem.innerHTML = `
            <input type="checkbox" id="delete-check-${emp.stableKey}" 
                   data-key="${emp.stableKey}" 
                   data-is-reliever="${emp.isReliever}" // Critical data attribute
                   class="delete-checkbox h-4 w-4 text-red-600 border-gray-300 rounded focus:ring-red-500" 
                   ${emp.isSelected ? 'checked' : ''}>
            <label for="delete-check-${emp.stableKey}" class="flex-grow text-sm font-medium text-gray-800">
                <span class="font-bold">${emp.name}</span> 
                ${designationTag} 
                <span class="text-xs text-gray-500 ml-1">(ID: ${emp.id})</span>
            </label>
        `;
        // --- END: DISTINCTION CHANGE ---
        
        const checkbox = listItem.querySelector('.delete-checkbox');
        checkbox.addEventListener('change', (e) => {
            updateBulkDeleteSelection(e);
            listItem.classList.toggle('bg-red-50', e.target.checked);
            listItem.classList.toggle('border-red-400', e.target.checked);
            listItem.classList.toggle('bg-gray-50', !e.target.checked);
            listItem.classList.toggle('border-gray-200', !e.target.checked);
        });
        
        listItem.addEventListener('click', (e) => {
            // Exclude span clicks (for the tag) para di mag-trigger
            if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'SPAN') { 
                checkbox.checked = !checkbox.checked;
                checkbox.dispatchEvent(new Event('change'));
            }
        });
        
        listContainer.appendChild(listItem);
    });
    
    const totalDeletable = deletableEmployees.length;
    selectAllCheckbox.checked = (totalDeletable > 0 && bulkDeleteSelected.length === totalDeletable);
    
    selectAllCheckbox.removeEventListener('change', toggleSelectAllDelete);
    selectAllCheckbox.addEventListener('change', toggleSelectAllDelete);

    updateDeleteModalState(totalDeletable);

    document.getElementById('delete-modal-cancel-btn').onclick = () => {
        modal.classList.add('hidden');
        bulkDeleteSelected = []; // Clear selection on cancel
        renderAttendancePlan(); // Re-render to clear any visual marks if needed, though they shouldn't exist yet
    };
    
    document.getElementById('delete-modal-confirm-btn').onclick = handleBulkDeleteConfirm; 

    modal.classList.remove('hidden');
}

// --- NEW FUNCTION: Select All/None for Delete Modal ---
function toggleSelectAllDelete(event) {
    const isChecked = event.target.checked;
    const checkboxes = document.querySelectorAll('#delete-employee-list-container .delete-checkbox');
    
    bulkDeleteSelected = []; 

    checkboxes.forEach(checkbox => {
        checkbox.checked = isChecked;
        
        const stableKey = checkbox.dataset.key;
        const listItem = checkbox.closest('li');
        
        if (isChecked) {
            bulkDeleteSelected.push(stableKey);
            listItem.classList.add('bg-red-50', 'border-red-400');
            listItem.classList.remove('bg-gray-50', 'border-gray-200');
        } else {
            listItem.classList.remove('bg-red-50', 'border-red-400');
            listItem.classList.add('bg-gray-50', 'border-gray-200');
        }
    });
    
    updateDeleteModalState(getDeletableEmployeesForModal().length);
}

// --- NEW HELPER: Update bulkDeleteSelected array ---
function updateBulkDeleteSelection(event) {
    const checkbox = event.target;
    const stableKey = checkbox.dataset.key;
    const isChecked = checkbox.checked;

    const existingIndex = bulkDeleteSelected.indexOf(stableKey);

    if (isChecked && existingIndex === -1) {
        bulkDeleteSelected.push(stableKey);
    } else if (!isChecked && existingIndex > -1) {
        bulkDeleteSelected.splice(existingIndex, 1);
    }
    
    const deletableCount = getDeletableEmployeesForModal().length;
    const selectAllCheckbox = document.getElementById('select-all-delete');

    if (selectAllCheckbox) {
        selectAllCheckbox.checked = (bulkDeleteSelected.length === deletableCount);
    }
    
    updateDeleteModalState(deletableCount);
}

// --- NEW HELPER: Update Delete Modal UI state ---
function updateDeleteModalState(totalDeletable) {
    const count = bulkDeleteSelected.length;
    const confirmBtn = document.getElementById('delete-modal-confirm-btn');
    
    document.getElementById('delete-selection-count').textContent = count;
    confirmBtn.disabled = count === 0;
    confirmBtn.textContent = `Mark for Deletion (${count})`;
}

// --- NEW FUNCTION: Handle Bulk Delete Confirmation (Marks for Deletion Locally) ---
function handleBulkDeleteConfirm() {
    document.getElementById('bulk-delete-selection-modal').classList.add('hidden');
    
    let deletedCount = 0;
    
    bulkDeleteSelected.forEach(stableKey => {
        
        // 1. Determine if it is a REGULAR Employee or a SAVED RELIEVER
        const isReliever = savedRelieverList.some(r => r.id === stableKey);
        
        if (isReliever) {
             // --- LOGIC FOR RELIEVER DELETION ---
             const reliever = savedRelieverList.find(r => r.id === stableKey);
             if (!reliever) return; 

             let pendingChange = pendingRelieverChanges[stableKey] || {
                 id: reliever.id, 
                 name: reliever.name, 
                 position: 'RELIEVER', 
                 area: 'RELIEVER',
                 isNew: false, 
                 isDeleted: false 
             };
             
             pendingChange.isDeleted = true;
             pendingRelieverChanges[stableKey] = pendingChange;
             
             deletedCount++;
             
        } else {
            // --- LOGIC FOR REGULAR EMPLOYEE DELETION ---
            const employee = currentContract.employees.find(e => e.id === stableKey) || { 
                id: stableKey, 
                name: 'N/A', 
                position: '', 
                area: '' 
            };
            
            // 1. Mark for deletion in pendingEmployeeInfoChanges
            let pendingChange = pendingEmployeeInfoChanges[stableKey] || {
                id: employee.id, 
                name: employee.name, 
                position: employee.position, 
                area: employee.area,
                isNew: !employee.id,
                originalEmployeeId: employee.id,
                isDeleted: false 
            };
            
            pendingChange.isDeleted = true;
            pendingEmployeeInfoChanges[stableKey] = pendingChange;
            
            // 2. Clear any pending local schedule changes
            const idToClear = pendingChange.id;
            if (idToClear) {
                Object.keys(pendingAttendanceChanges).forEach(key => {
                    if (key.startsWith(idToClear + '_')) { 
                        delete pendingAttendanceChanges[key];
                    }
                });
            }
            deletedCount++;
        }
    });
    
    // Clear the selection array after action
    bulkDeleteSelected = [];
    
    showNotification(`Successfully marked ${deletedCount} employees for DELETION. Click 'Save All Changes to Sheets' to finalize.`, false);
    
    renderAttendancePlan(); 
    renderRelieverTable(); // NEW: Trigger render for reliever table visibility
    checkPlanSheetLockState(); 
}

// --- NEW HELPER: Get Row Schedule Status ---
function getRowScheduleStatus(row, currentShift) {
    const idInput = row.querySelector('[data-field="id"]');
    const personnelId = (idInput?.value || '').trim();
    
    if (!personnelId) return { id: null, isPrintable: false };
    const isSecurityRow = row.querySelector('[data-security-field="timeOfShift"]') !== null;

    if (isSecurityRow) {
        const timeShiftInput = row.querySelector('[data-security-field="timeOfShift"]');
        const hasTimeShift = timeShiftInput && timeShiftInput.value.trim() !== '';
        
        return { id: personnelId, isPrintable: hasTimeShift };
    } 
    
    // --- STANDARD PLAN LOGIC (Existing) ---
    const startColIndex = 1;
    const endColIndex = 16;
    const year = currentPlanningDate.getFullYear();
    const month = currentPlanningDate.getMonth();
    const startDayOfMonth = currentShift === '1stHalf' ? 1 : 16;
    const daysInMonth = getDaysInMonth(year, month);
    
    let hasActualSchedule = false;
    const originalId = row.dataset.stableKey.startsWith('TEMP_') ? '' : row.dataset.stableKey;

    // Find the cell elements in the row
    // Note: Adjust logic kung paano naha-handle ang columns sa Standard Plan
    for(let colIndex = startColIndex; colIndex <= endColIndex; colIndex++) {
        const d = startDayOfMonth + colIndex - 1; 
        if (d > daysInMonth) continue; 
        if (currentShift === '1stHalf' && d > 15) continue; 

        const dayKey = `${year}-${month + 1}-${d}`;
        const originalKey = `${originalId}_${dayKey}_${currentShift}`;
        
        // Hanapin ang status sa pending changes o sa saved map
        let status = pendingAttendanceChanges[`${personnelId}_${dayKey}_${currentShift}`];
        if (status === undefined) {
             status = currentContract.planMap[originalKey] || '';
        }
        
        status = status.toString().trim();

        if (status && status !== 'NA' && status !== 'DELETED' && status !== 'LOCKED') {
            hasActualSchedule = true;
            break;
        }
    }

    return { id: personnelId, isPrintable: hasActualSchedule };
}
// --- NEW FUNCTION: Check Plan Sheet Global Lock State (Disables Print Button) ---
function checkPlanSheetLockState() {
    if (!currentContract) {
        isPlanSheetFullyLocked = false;
        updatePrintButtonState();
        return;
    }
    
    if (currentContract.employees.length === 0 && Object.keys(pendingEmployeeInfoChanges).length === 0) {
        isPlanSheetFullyLocked = false;
        updatePrintButtonState();
        return;
    }

    const gridRows = document.querySelectorAll('#attendance-table-container tbody tr');
    const currentShift = document.getElementById('shift-period-select').value;
    
    let totalPrintableAndUnlocked = 0;

    gridRows.forEach(row => {
        if (row.classList.contains('line-through') || row.classList.contains('print-empty-row')) return;
        
        const { id: personnelId, isPrintable } = getRowScheduleStatus(row, currentShift);
        
        if (isPrintable) {
            if (!lockedIdRefMap[personnelId]) {
                totalPrintableAndUnlocked++;
            }
        }
    });

    isPlanSheetFullyLocked = (totalPrintableAndUnlocked === 0);
    updatePrintButtonState();
}

// --- NEW FUNCTION: Update Print Button Visuals ---
function updatePrintButtonState() {
    const printBtn = document.getElementById('print-plan-btn');

    if (isPlanSheetFullyLocked) {
        printBtn.disabled = true;
        printBtn.classList.add('opacity-50', 'cursor-not-allowed');
        printBtn.title = 'Cannot print: All active schedules are already logged and locked for this period.';
    } else {
        printBtn.disabled = false;
        printBtn.classList.remove('opacity-50', 'cursor-not-allowed');
        printBtn.title = 'Print Plan';
    }
}

function renderRelieverTable() {
    
    // 1. Get saved relievers and merge with pending changes/new entries
    const savedRelievers = savedRelieverList.slice() || []; 
    let relieversToRender = [];
    
    // 1.a. Start with saved relievers (Use ID as stableKey if saved)
    savedRelievers.forEach(emp => {
        const pending = pendingRelieverChanges[emp.id];
        relieversToRender.push({ 
            id: (pending && pending.id) || emp.id, 
            name: (pending && pending.name) || emp.name, 
            position: 'RELIEVER', 
            area: 'RELIEVER',
            stableKey: emp.id, // Use saved ID as stable key
            isMarkedForDeletion: pending?.isDeleted || false // NEW CHECK
        });
    });

    // 1.b. Add pending NEW relievers (using temporary keys, skip if already in saved list)
    Object.keys(pendingRelieverChanges).forEach(stableKey => {
         const change = pendingRelieverChanges[stableKey];
         // Only include NEW and non-deleted pending entries here
         if (stableKey.startsWith('RELIVER_TEMP_') && !relieversToRender.some(e => e.stableKey === stableKey) && !change.isDeleted) {
             relieversToRender.push({
                 id: change.id, 
                 name: change.name, 
                 position: change.position, 
                 area: change.area, 
                 stableKey: stableKey,
                 isMarkedForDeletion: false
             });
         }
    });

    // 2. Count active relievers (non-deleted, non-empty ID/Name)
    const activeRelievers = relieversToRender.filter(r => 
        !r.isMarkedForDeletion && (r.id && r.id.trim() !== '' && r.name && r.name.trim() !== '')
    );
    
    const requiredRows = calculateRelieverRows(currentContract?.headCount || 0);

    const tableContainer = document.getElementById('reliever-table-container');
    const relieverArea = document.getElementById('reliever-personnel-area');
    const relieverTitle = document.getElementById('reliever-title');

    if (!tableContainer || !relieverArea) return;

    // CRITICAL FIX: Laging i-alis ang 'hidden' para makita ito sa screen
    relieverArea.classList.remove('hidden'); 

    // 3. CRITICAL: Kontrolin lang ang 'print-hidden' class
    if (activeRelievers.length === 0) {
        // Hiding the entire section only for print
        relieverArea.classList.add('print-hidden'); 
    } else {
        // Showing the entire section in print
        relieverArea.classList.remove('print-hidden'); 
    }
    
    // 4. Start Rendering
    
    tableContainer.innerHTML = '';
    
    const relieverTableWrapper = document.createElement('div');
    relieverTableWrapper.className = 'reliever-print-wrapper';
    
    const table = document.createElement('table');
    table.className = 'w-full text-sm text-left text-gray-700 border-collapse';
    
    const thead = table.createTHead();
    const headerRow = thead.insertRow();
    
    // Headers: No., Personnel ID, Personnel Name, Position, Area Posting
    const relieverHeaders = ['No.', 'Personnel ID', 'Personnel Name', 'POSITION', 'AREA POSTING']; 
    
    relieverHeaders.forEach((headerText, index) => {
        const th = document.createElement('th');
        th.scope = 'col';
        th.textContent = headerText;
        th.className = 'sticky-col-header text-xs font-semibold uppercase tracking-wider p-3 bg-gray-100 border-r border-b border-gray-300 z-20'; 
        
        if (index <= 1) th.classList.add('freeze-1', 'z-30'); // No. and ID
        if (index === 2) th.classList.add('freeze-2', 'z-30'); // Name
        
        headerRow.appendChild(th);
    });
    
    const tbody = table.createTBody();

    // Loop based on required slots (Max of rendered relievers or required rows)
    const totalSlots = Math.max(requiredRows, relieversToRender.length);

    for (let i = 0; i < totalSlots; i++) {
        const reliever = relieversToRender[i] || { 
            stableKey: `RELIVER_TEMP_${i + 1}`,
            id: '', 
            name: '', 
            position: '', 
            area: '',
            isMarkedForDeletion: false
        };
        
        const finalStableKey = reliever.stableKey; 
        
        // Final display values
        const displayId = reliever.id || '';
        const displayName = reliever.name || '';
        const displayPosition = reliever.position || '';
        const displayArea = reliever.area || '';
        
        const isSavedReliever = displayId.trim() !== '' && !reliever.stableKey.startsWith('RELIVER_TEMP_'); 
        const isMarkedForDeletion = reliever.isMarkedForDeletion; // Get the state
        
        const tr = tbody.insertRow();
        tr.dataset.stableKey = finalStableKey; 
        
        if (isMarkedForDeletion) {
            tr.classList.add('bg-red-200', 'opacity-50', 'line-through');
        }
        
        // No. Cell (Index 0)
        let td = tr.insertCell();
        td.className = 'sticky-col text-center p-0 bg-gray-50 font-bold border-r border-b z-10 freeze-1'; 
        td.innerHTML = `<span class="block py-2">${i + 1}</span>`;
        
        // Personnel ID Input (Index 1)
        td = tr.insertCell();
        let input = document.createElement('input');
        input.type = 'text';
        input.value = displayId;
        input.setAttribute('list', 'employee-id-list'); 
        input.placeholder = 'ID';
        input.maxLength = 20; 
        input.dataset.field = 'id';
        input.dataset.reliever = 'true'; 
        input.dataset.rowNo = i + 1; 
        
        // CRITICAL: ID should be read-only if saved OR marked for deletion
        input.readOnly = isSavedReliever || isMarkedForDeletion; 

        input.className = 'personnel-info-input text-center p-1 border-none focus:ring-blue-400 w-full bg-transparent ' + (input.readOnly ? 'read-only' : ''); 
        td.appendChild(input);
        td.className = 'sticky-col p-0 bg-white border-r border-b z-10 freeze-1'; 
        
        // Personnel Name Input (Index 2)
        td = tr.insertCell();
        input = document.createElement('input');
        input.type = 'text';
        input.value = displayName;
        input.setAttribute('list', 'employee-name-list'); 
        input.placeholder = 'Full Name';
        input.dataset.field = 'name';
        input.dataset.reliever = 'true';
        
        // CRITICAL: Name should be read-only if saved OR marked for deletion
        input.readOnly = isSavedReliever || isMarkedForDeletion; 

        input.className = 'personnel-info-input p-1 border-none focus:ring-blue-400 w-full bg-transparent ' + (input.readOnly ? 'read-only' : ''); 
        td.appendChild(input);
        td.className = 'sticky-col p-0 bg-white border-r border-b z-10 freeze-2';
        
        // Position Input (Index 3) - Remains Read-Only
        td = tr.insertCell();
        input = document.createElement('input');
        input.type = 'text';
        input.value = displayPosition;
        input.placeholder = 'Position (RELIEVER)';
        input.readOnly = true; // Always read-only, but should reflect deletion if marked
        input.dataset.field = 'position';
        input.dataset.reliever = 'true';
        input.className = 'personnel-info-input p-1 border-none focus:ring-blue-400 w-full bg-transparent read-only'; 
        td.appendChild(input);
        td.className = 'p-0 bg-white border-r border-b';
        
        // Area Posting Input (Index 4) - Remains Read-Only
        td = tr.insertCell();
        input = document.createElement('input');
        input.type = 'text';
        input.value = displayArea;
        input.placeholder = 'Area (RELIEVER)';
        input.readOnly = true; // Always read-only, but should reflect deletion if marked
        input.dataset.field = 'area';
        input.dataset.reliever = 'true';
        input.className = 'personnel-info-input p-1 border-none focus:ring-blue-400 w-full bg-transparent read-only'; 
        td.appendChild(input);
        td.className = 'p-0 bg-white border-r border-b';
        
        // 5. Attach Listeners (Attach ONLY if NOT saved AND NOT marked for deletion)
        const idInput = tr.querySelector('[data-field="id"]');
        const nameInput = tr.querySelector('[data-field="name"]');
        
        if(!isSavedReliever && !isMarkedForDeletion) { 
            if(idInput) {
                idInput.addEventListener('input', handleRelieverInfoChange);
                idInput.addEventListener('change', handleRelieverInfoChange);
                idInput.addEventListener('input', filterDatalistOptions);
            }
            if(nameInput) {
                nameInput.addEventListener('input', handleRelieverInfoChange);
                nameInput.addEventListener('change', handleRelieverInfoChange);
                nameInput.addEventListener('input', filterDatalistOptions);
            }
        } else if (isMarkedForDeletion) {
             // Add an empty listener just for the notification check if they try to edit a deleted input
             tr.querySelectorAll('.personnel-info-input').forEach(infoInput => {
                infoInput.addEventListener('click', (e) => {
                    showNotification('Cannot edit: Row is marked for deletion. Save changes or refresh to undo.', false);
                });
             });
        }
    }
    
    relieverTableWrapper.appendChild(table); 
    tableContainer.appendChild(relieverTableWrapper); 
}

function calculateRelieverRows(headCount) {
    if (!headCount || isNaN(headCount) || headCount < 0) return 1;
    
    // 1. Calculate 20% and round it
    const calculated = Math.round(headCount * 0.20);
    
    // 2. Apply Min/Max constraints (min 1, max 10)
    const minRows = 1;
    const maxRows = 10;
    
    return Math.min(maxRows, Math.max(minRows, calculated));
}

function handleRelieverInfoChange(event) {
    const input = event.target;
    const field = input.dataset.field;
    const row = input.closest('tr');
    const stableKey = row.dataset.stableKey; 
    let newValue = input.value;
    
    if (input.readOnly) {
         showNotification('Cannot edit: This reliever row is already saved or marked for deletion.', false);
         input.value = pendingRelieverChanges[stableKey]?.[field] || savedRelieverList.find(r => r.id === stableKey)?.[field] || '';
         return;
    }
    
    const positionInput = row.querySelector('[data-field="position"]');
    const areaInput = row.querySelector('[data-field="area"]');
    const idInput = row.querySelector('[data-field="id"]');
    const nameInput = row.querySelector('[data-field="name"]');
    
    let pendingChange = pendingRelieverChanges[stableKey] || {
        id: '', name: '', position: '', area: '', isNew: true
    };
    
    let masterRecordFound = null; 
    let masterRecord = null;
    
    const ALLOWED_NAME_CHARS_REGEX = /[^A-Z\s.,-]/g; 
    const ALLOWED_ID_CHARS_REGEX = /[^0-9]/g; 
    
    if (field === 'id') {
         newValue = newValue.replace(ALLOWED_ID_CHARS_REGEX, ''); 
    } else if (field === 'name') {
         newValue = newValue.toUpperCase().replace(ALLOWED_NAME_CHARS_REGEX, ''); 
    } else {
         newValue = newValue.toUpperCase(); 
    }
    
    input.value = newValue; 
    const upperNewValue = newValue.trim().toUpperCase(); 
    
    const clearRowAndState = () => {
         idInput.value = ''; nameInput.value = ''; positionInput.value = ''; areaInput.value = '';
         pendingChange.id = ''; pendingChange.name = ''; pendingChange.position = ''; pendingChange.area = '';
         delete pendingRelieverChanges[stableKey];
    };
    
    // --- SIMULA: REAL-TIME VALIDATION (Change Event Only) ---
    if (event.type === 'change') {
        const currentId = idInput?.value.trim() || '';
        const currentName = nameInput?.value.trim() || '';
        
        // 1. BLACKLIST CHECK
        const blacklistCheckResult = checkIsBlacklisted(currentId, currentName);
        if (blacklistCheckResult.isBlacklisted) {
            showNotification(`FATAL: Cannot use Personnel ID/Name. Employee is BLACKLISTED! ${blacklistCheckResult.reason}`, false);
            clearRowAndState();
            showPersonnelWarning(row, null); 
            return; 
        }
        
        // 2. 201 CHECK
        if (upperNewValue.length > 0) { 
            if (field === 'id' || field === 'name') {
                const is201Employee = all201PersonnelList.some(e => {
                    if (field === 'id') return e.id === currentId;
                    else {
                        const normalizedInputName = normalizeNameForComparison(currentName.toUpperCase());
                        return normalizeNameForComparison(e.name) === normalizedInputName;
                    }
                });

                if (!is201Employee) { 
                    showNotification(`FATAL: Personnel ${field.toUpperCase()} "${newValue}" not found in the 201 Master File.`, false);
                    clearRowAndState();
                    showPersonnelWarning(row, null); 
                    return; 
                }
            }
        }
        
        // 3. NEW: CROSS-CONTRACT CONFLICT CHECK (Trigger only if Name is present)
        if (currentName.length > 0) {
             triggerCrossContractCheck(row, currentName, 'reliever');
        }

        if (field === 'id' || field === 'name') showPersonnelWarning(row, null); 
    } 
    // --- END: REAL-TIME VALIDATION ---

    if (field === 'id') {
         masterRecord = employeeMasterList.find(e => e.id === upperNewValue);
         pendingChange.id = upperNewValue; 
    } else if (field === 'name') {
         const normalizedInputName = normalizeNameForComparison(upperNewValue);
         masterRecord = employeeMasterList.find(e => normalizeNameForComparison(e.name) === normalizedInputName);
         pendingChange.name = newValue; 
    }

    if (field === 'id' && pendingChange.id === '') {
        if (nameInput.value.trim() !== '') { nameInput.value = ''; pendingChange.name = ''; }
    } else if (field === 'name' && pendingChange.name === '') {
        if (idInput.value.trim() !== '') { idInput.value = ''; pendingChange.id = ''; }
    }

    const isRowInputting = (pendingChange.id.trim() !== '' || pendingChange.name.trim() !== '');

    if (isRowInputting) {
        positionInput.value = 'RELIEVER'; areaInput.value = 'RELIEVER';
        pendingChange.position = 'RELIEVER'; pendingChange.area = 'RELIEVER';
    } else {
        positionInput.value = ''; areaInput.value = '';
        pendingChange.position = ''; pendingChange.area = '';
    }

    if (masterRecord) {
        masterRecordFound = masterRecord; 
        idInput.value = masterRecord.id;
        nameInput.value = masterRecord.name;
        pendingChange.id = masterRecord.id;
        pendingChange.name = masterRecord.name;
        showNotification(`Employee details auto-filled for ${masterRecord.name}. Position/Area set to RELIEVER.`, true);
        
        // Re-trigger conflict check specifically for the autofilled name
        triggerCrossContractCheck(row, masterRecord.name, 'reliever');
    } 

    if (field === 'id' && pendingChange.id) {
        if (!PERSONNEL_ID_REGEX.test(pendingChange.id)) {
             showNotification('Personnel ID must contain numbers only.', false);
             clearRowAndState(); 
             return; 
        }
        if (isDuplicateId(pendingChange.id, stableKey, 0)) { 
            showNotification(`FATAL: Personnel ID "${pendingChange.id}" is already used in another row.`, false);
            clearRowAndState(); 
            return; 
        }
    } 
    
    else if (field === 'name' && pendingChange.name) {
        if (isDuplicateName(pendingChange.name, stableKey, 0)) {
            showNotification(`FATAL ERROR: Personnel Name "${pendingChange.name}" is already used by another employee.`, false);
            clearRowAndState(); 
            return; 
        }
    }

    const isRowComplete = pendingChange.id.trim() !== '' && pendingChange.name.trim() !== '';

    if (isRowComplete) {
        pendingRelieverChanges[stableKey] = {
            id: pendingChange.id.trim(),
            name: pendingChange.name.trim(),
            position: 'RELIEVER',
            area: 'RELIEVER',
            isNew: true
        };
    } else {
        delete pendingRelieverChanges[stableKey];
    }
}

// --- NEW FUNCTION: TRIGGERS CROSS-CONTRACT CONFLICT CHECK ---
function triggerCrossContractCheck(rowElement, personnelName, fieldType) {
    const currentName = (personnelName || '').trim();
    if (!currentName) return;

    const currentSfc = currentContract?.sfcRef;
    const currentYear = currentPlanningDate.getFullYear();
    const currentMonth = currentPlanningDate.getMonth();
    const currentShift = document.getElementById('shift-period-select').value;

    google.script.run
        .withSuccessHandler((result) => {
            // Check if the input value is still the same (user didn't type something else quickly)
            const latestNameInput = rowElement.querySelector('[data-field="name"]');
            if (latestNameInput.value.trim() !== currentName) return;

            if (result.hasConflict) {
                // CLEAR THE ROW
                showNotification(`CONFLICT ALERT: ${currentName} is ${result.conflictDetails}. Cannot add to this contract.`, false);
                
                // Clear UI Inputs
                const idInput = rowElement.querySelector('[data-field="id"]');
                const nameInput = rowElement.querySelector('[data-field="name"]');
                const posInput = rowElement.querySelector('[data-field="position"]');
                const areaInput = rowElement.querySelector('[data-field="area"]');

                if (idInput) idInput.value = '';
                if (nameInput) nameInput.value = '';
                if (posInput && !posInput.readOnly) posInput.value = ''; // Don't clear if read-only (Reliever)
                if (areaInput && !areaInput.readOnly) areaInput.value = '';

                updateSecurityRowState(rowElement, '');

                // Remove from Pending Changes State
                const stableKey = rowElement.dataset.stableKey;
                if (fieldType === 'regular') {
                    delete pendingEmployeeInfoChanges[stableKey];
                } else if (fieldType === 'reliever') {
                    delete pendingRelieverChanges[stableKey];
                }

                showPersonnelWarning(rowElement, `CONFLICT: ${result.conflictDetails}`);
            } else {
                // Clear warning if valid
                showPersonnelWarning(rowElement, null);
            }
        })
        .withFailureHandler((error) => {
            console.error("Cross-contract check failed", error);
        })
        .checkCrossContractConflict(currentName, currentSfc, currentYear, currentMonth, currentShift);
}

function savePdfOfPrintLayout(refNum, sfcRef, year, month, shift, personnelIds) {
    
    const cloneDoc = document.documentElement.cloneNode(true);
    
    const selector = 'input:not([type="hidden"]), textarea, select';
    const liveInputs = document.querySelectorAll(selector);
    const cloneInputs = cloneDoc.querySelectorAll(selector);
    
    for (let i = 0; i < liveInputs.length; i++) {
        if (!cloneInputs[i]) continue; // Safety check

        const liveInput = liveInputs[i];
        const cloneInput = cloneInputs[i];
        let displayValue = liveInput.value;

        if (liveInput.tagName === 'SELECT') {
            if (liveInput.selectedIndex >= 0) {
                displayValue = liveInput.options[liveInput.selectedIndex].text;
            }
            if (displayValue === '- Select -' || displayValue === '- Select -') {
                displayValue = '';
            }
        } 
        else if (liveInput.type === 'checkbox' || liveInput.type === 'radio') {
            if (!liveInput.checked) displayValue = ''; // Hide kung hindi checked
        }

        const textDiv = document.createElement('div');
        textDiv.textContent = displayValue;
        textDiv.className = cloneInput.className; 
        
        textDiv.style.cssText = `
            white-space: pre-wrap !important;
            word-wrap: break-word !important;
            overflow: visible !important;
            border: none !important;
            background: transparent !important;
            color: #000000 !important;
            width: 100% !important;
            min-height: 15px !important;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
        `;

        if (cloneInput.parentNode) {
            cloneInput.parentNode.replaceChild(textDiv, cloneInput);
        }
    }

    const refDisplay = cloneDoc.querySelector('#print-ref-display');
    if (refDisplay) {
        refDisplay.style.cssText = `
            display: block !important;
            position: absolute !important;
            top: 0px !important;       
            right: 20px !important;    
            z-index: 99999 !important;
            background-color: transparent !important; 
            padding: 0px !important;
            border: none !important;   
            font-weight: bold !important;
            font-size: 9px !important;
            color: #000 !important;
        `;
    }

    let htmlContent = cloneDoc.outerHTML;

    const pdfStyles = `
    <style>
        /* A. CUSTOM LANDSCAPE SIZE (13in x 8.5in) */
        @page {
            size: 13in 8.5in; 
            margin: 0.25in; 
        }

        /* B. GLOBAL RESET & FONT UNIFORMITY */
        body, html {
            width: 100% !important;
            margin: 0 !important;
            padding: 0 !important;
            background-color: #ffffff !important;
            -webkit-print-color-adjust: exact !important;
            padding-top: 5px !important; 
        }

        /* C. TABLE & FONT SIZING FIX */
        table {
            width: 100% !important;
            border-collapse: collapse !important;
            table-layout: fixed !important; 
        }
        
        /* IISANG FONT SIZE: 11px */
        th, td, div, span, p {
            font-size: 9px !important; 
            line-height: 1.2 !important;
        }

        th, td {
            border: 1px solid #000 !important;
            word-wrap: break-word !important;
            white-space: normal !important;
            vertical-align: middle !important;
            padding: 2px !important;
        }

        .sticky-col, .sticky-col-header, th, td {
            position: static !important;
            overflow: visible !important;
        }

        /* D. HIDE UI ELEMENTS */
        #full-screen-overlay, #loading-alert, .print-hidden, #notification-area, 
        #print-confirm-modal, #print-selection-modal, #print-setup-modal, 
        #ui-datepicker-div, .ui-datepicker { 
            display: none !important;
        }
    </style>
    `;

    if (htmlContent.includes('</head>')) {
        htmlContent = htmlContent.replace('</head>', pdfStyles + '</head>');
    } else {
        htmlContent = pdfStyles + htmlContent;
    }

    // --- STEP 6: SEND TO SERVER ---
    const date = new Date(year, month, 1);
    const monthName = date.toLocaleString('en-US', { month: 'short' });
    const yearStr = date.getFullYear();
    const cleanSfc = sfcRef.replace(/[^a-zA-Z0-9]/g, ''); 
    const fileName = `AttendancePlan_${cleanSfc}_${monthName}${yearStr}_${shift}_${refNum}.pdf`;

    console.log("Generating PDF (Version 9 - Live Value Sync)...");

    google.script.run
        .withSuccessHandler((response) => {
            if (response && response.success) {
                console.log('PDF Saved:', response.url);
                showNotification('PDF Copy saved successfully.', true);
            } else {
                showNotification('Warning: PDF Save failed. ' + (response.message || ''), false);
            }
        })
        .withFailureHandler((error) => {
            console.error('PDF Save Server Error:', error);
        })
        .savePrintToPdfAndLog(htmlContent, fileName, sfcRef, year, month, shift, personnelIds);
}

  // --- INITIALIZATION ---
  window.onload = function() {
    toggleLoading(true);
    google.script.run
      .withSuccessHandler(handleContractList)
      .withFailureHandler(handleError)
      .getContracts();
      
    document.getElementById('print-setup-confirm-btn').addEventListener('click', handlePrintSetupConfirm);
    document.getElementById('print-setup-cancel-btn').addEventListener('click', hidePrintSetupModal);
    
    // *** NEW: Fetch Print Field Master Data on load ***
    fetchPrintFieldMasterData();
    fetchSecuritySuggestions();
    
    // NEW: Attach Bulk Delete Modal Listeners
    document.getElementById('delete-modal-cancel-btn').addEventListener('click', () => {
         document.getElementById('bulk-delete-selection-modal').classList.add('hidden');
         bulkDeleteSelected = []; 
         renderAttendancePlan(); 
    });
    document.getElementById('delete-modal-confirm-btn').addEventListener('click', handleBulkDeleteConfirm);
    document.getElementById('open-bulk-delete-btn').addEventListener('click', openBulkDeleteModal);
    
    // PREPARED BY (Name Input)
    const preparedByNameInput = document.getElementById('signatory-prepared-by');
    if (preparedByNameInput) {
        preparedByNameInput.addEventListener('input', (e) => handleSignatoryInputChange(e, 'preparedBy'));
        preparedByNameInput.addEventListener('change', (e) => handleSignatoryInputChange(e, 'preparedBy')); 
        preparedByNameInput.addEventListener('input', filterDatalistOptions); 
    }
    
    // PREPARED BY (Designation Input) - NEW LISTENER
    document.getElementById('signatory-prepared-by-designation').addEventListener('input', (e) => handleSignatoryDesignationChange(e, 'preparedBy'));
    document.getElementById('signatory-prepared-by-designation').addEventListener('change', (e) => handleSignatoryDesignationChange(e, 'preparedBy'));

    // APPROVED BY (Name Input)
    document.getElementById('signatory-approved-by').addEventListener('input', (e) => handleSignatoryInputChange(e, 'approvedBy'));
    document.getElementById('signatory-approved-by').addEventListener('change', (e) => handleSignatoryInputChange(e, 'approvedBy')); 
    
    // APPROVED BY (Designation Input)
    document.getElementById('signatory-approved-by-designation').addEventListener('input', (e) => handleSignatoryDesignationChange(e, 'approvedBy'));
    document.getElementById('signatory-approved-by-designation').addEventListener('change', (e) => handleSignatoryDesignationChange(e, 'approvedBy'));

    for(let i = 0; i < 5; i++) {
        const inputName = document.getElementById(`signatory-checked-by-${i}`);
        const inputDesignation = document.getElementById(`signatory-checked-by-${i}-designation`);
        
        if(inputName) {
            // CHECKED BY (Name Input)
            inputName.addEventListener('input', (e) => handleSignatoryInputChange(e, 'checkedBy', i));
            inputName.addEventListener('change', (e) => handleSignatoryInputChange(e, 'checkedBy', i)); 
        }
        
        if(inputDesignation) {
             // CHECKED BY (Designation Input)
            inputDesignation.addEventListener('input', (e) => handleSignatoryDesignationChange(e, 'checkedBy', i));
            inputDesignation.addEventListener('change', (e) => handleSignatoryDesignationChange(e, 'checkedBy', i));
        }
    }
    
    // ************************ NEW PRINT FIELD LISTENERS (FOR DATALIST FILTERING) ************************
    const remarksInput = document.getElementById('remarks-input');
    if (remarksInput) {
        remarksInput.addEventListener('input', filterDatalistOptions); 
    }
  }
</script>
